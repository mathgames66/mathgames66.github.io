(function () {
    var t = this, k = k || {};
    return k.game = null, k.WEBGL_RENDERER = 0, k.CANVAS_RENDERER = 1, k.VERSION = "v2.2.9", k._UID = 0, "undefined" != typeof Float32Array ? (k.Float32Array = Float32Array, k.Uint16Array = Uint16Array, k.Uint32Array = Uint32Array, k.ArrayBuffer = ArrayBuffer) : (k.Float32Array = Array, k.Uint16Array = Array), k.PI_2 = 2 * Math.PI, k.RAD_TO_DEG = 180 / Math.PI, k.DEG_TO_RAD = Math.PI / 180, k.RETINA_PREFIX = "@2x", k.DisplayObject = function () {
        this.position = new k.Point(0, 0), this.scale = new k.Point(1, 1), this.pivot = new k.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new k.Matrix, this.worldPosition = new k.Point(0, 0), this.worldScale = new k.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new k.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
    }, k.DisplayObject.prototype.constructor = k.DisplayObject, k.DisplayObject.prototype = {
        destroy: function () {
            if (this.children) {
                for (var t = this.children.length; t--;) this.children[t].destroy();
                this.children = []
            }
            this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
        }, updateTransform: function (t) {
            if (!t && !this.parent && !this.game) return this;
            var e = this.parent;
            t ? e = t : this.parent || (e = this.game.world);
            var i, s, n, r, o, a, h = e.worldTransform, l = this.worldTransform;
            return this.rotation % k.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, n = -this._sr * this.scale.y, r = this._cr * this.scale.y, o = this.position.x, a = this.position.y, (this.pivot.x || this.pivot.y) && (o -= this.pivot.x * i + this.pivot.y * n, a -= this.pivot.x * s + this.pivot.y * r), l.a = i * h.a + s * h.c, l.b = i * h.b + s * h.d, l.c = n * h.a + r * h.c, l.d = n * h.b + r * h.d) : (i = this.scale.x, r = this.scale.y, o = this.position.x - this.pivot.x * i, a = this.position.y - this.pivot.y * r, l.a = i * h.a, l.b = i * h.b, l.c = r * h.c, l.d = r * h.d), l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty, this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.set(l.tx, l.ty), this.worldScale.set(this.scale.x * Math.sqrt(l.a * l.a + l.c * l.c), this.scale.y * Math.sqrt(l.b * l.b + l.d * l.d)), this.worldRotation = Math.atan2(-l.c, l.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h), this
        }, preUpdate: function () {
        }, generateTexture: function (t, e, i) {
            var s = this.getLocalBounds(), n = new k.RenderTexture(0 | s.width, 0 | s.height, i, e, t);
            return k.DisplayObject._tempMatrix.tx = -s.x, k.DisplayObject._tempMatrix.ty = -s.y, n.render(this, k.DisplayObject._tempMatrix), n
        }, updateCache: function () {
            return this._generateCachedSprite(), this
        }, toGlobal: function (t) {
            return this.updateTransform(), this.worldTransform.apply(t)
        }, toLocal: function (t, e) {
            return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
        }, _renderCachedSprite: function (t) {
            this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? k.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : k.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
        }, _generateCachedSprite: function () {
            this._cacheAsBitmap = !1;
            var t = this.getLocalBounds();
            if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height); else {
                var e = new k.RenderTexture(t.width, t.height);
                this._cachedSprite = new k.Sprite(e), this._cachedSprite.worldTransform = this.worldTransform
            }
            var i = this._filters;
            this._filters = null, this._cachedSprite.filters = i, k.DisplayObject._tempMatrix.tx = -t.x, k.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, k.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = i, this._cacheAsBitmap = !0
        }, _destroyCachedSprite: function () {
            this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
        }
    }, k.DisplayObject.prototype.displayObjectUpdateTransform = k.DisplayObject.prototype.updateTransform, Object.defineProperties(k.DisplayObject.prototype, {
        x: {
            get: function () {
                return this.position.x
            }, set: function (t) {
                this.position.x = t
            }
        }, y: {
            get: function () {
                return this.position.y
            }, set: function (t) {
                this.position.y = t
            }
        }, worldVisible: {
            get: function () {
                if (this.visible) {
                    var t = this.parent;
                    if (!t) return this.visible;
                    do {
                        if (!t.visible) return !1;
                        t = t.parent
                    } while (t);
                    return !0
                }
                return !1
            }
        }, mask: {
            get: function () {
                return this._mask
            }, set: function (t) {
                this._mask && (this._mask.isMask = !1), (this._mask = t) && (this._mask.isMask = !0)
            }
        }, filters: {
            get: function () {
                return this._filters
            }, set: function (t) {
                if (Array.isArray(t)) {
                    for (var e = [], i = 0; i < t.length; i++) for (var s = t[i].passes, n = 0; n < s.length; n++) e.push(s[n]);
                    this._filterBlock = {target: this, filterPasses: e}
                }
                this._filters = t, this.blendMode && this.blendMode === k.blendModes.MULTIPLY && (this.blendMode = k.blendModes.NORMAL)
            }
        }, cacheAsBitmap: {
            get: function () {
                return this._cacheAsBitmap
            }, set: function (t) {
                this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
            }
        }
    }), k.DisplayObjectContainer = function () {
        k.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
    }, k.DisplayObjectContainer.prototype = Object.create(k.DisplayObject.prototype), k.DisplayObjectContainer.prototype.constructor = k.DisplayObjectContainer, k.DisplayObjectContainer.prototype.addChild = function (t) {
        return this.addChildAt(t, this.children.length)
    }, k.DisplayObjectContainer.prototype.addChildAt = function (t, e) {
        if (0 <= e && e <= this.children.length) return t.parent && t.parent.removeChild(t), (t.parent = this).children.splice(e, 0, t), t;
        throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
    }, k.DisplayObjectContainer.prototype.swapChildren = function (t, e) {
        if (t !== e) {
            var i = this.getChildIndex(t), s = this.getChildIndex(e);
            if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[i] = e, this.children[s] = t
        }
    }, k.DisplayObjectContainer.prototype.getChildIndex = function (t) {
        var e = this.children.indexOf(t);
        if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
        return e
    }, k.DisplayObjectContainer.prototype.setChildIndex = function (t, e) {
        if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
        var i = this.getChildIndex(t);
        this.children.splice(i, 1), this.children.splice(e, 0, t)
    }, k.DisplayObjectContainer.prototype.getChildAt = function (t) {
        if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[t]
    }, k.DisplayObjectContainer.prototype.removeChild = function (t) {
        var e = this.children.indexOf(t);
        if (-1 !== e) return this.removeChildAt(e)
    }, k.DisplayObjectContainer.prototype.removeChildAt = function (t) {
        var e = this.getChildAt(t);
        return e && (e.parent = void 0, this.children.splice(t, 1)), e
    }, k.DisplayObjectContainer.prototype.removeChildren = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
        var i = e - t;
        if (0 < i && i <= e) {
            for (var s = this.children.splice(begin, i), n = 0; n < s.length; n++) {
                s[n].parent = void 0
            }
            return s
        }
        if (0 === i && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
    }, k.DisplayObjectContainer.prototype.updateTransform = function () {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    }, k.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = k.DisplayObjectContainer.prototype.updateTransform, k.DisplayObjectContainer.prototype.getBounds = function (t) {
        var e, i = t && t instanceof k.DisplayObject, s = !0;
        if (i ? s = t instanceof k.DisplayObjectContainer && t.contains(this) : t = this, i) {
            var n = t.worldTransform;
            for (t.worldTransform = k.identityMatrix, e = 0; e < t.children.length; e++) t.children[e].updateTransform()
        }
        var r, o, a, h = 1 / 0, l = 1 / 0, c = -1 / 0, u = -1 / 0, d = !1;
        for (e = 0; e < this.children.length; e++) {
            this.children[e].visible && (d = !0, h = h < (r = this.children[e].getBounds()).x ? h : r.x, l = l < r.y ? l : r.y, c = (o = r.width + r.x) < c ? c : o, u = (a = r.height + r.y) < u ? u : a)
        }
        var p = this._bounds;
        if (!d) {
            var f = (p = new k.Rectangle).x, g = p.width + p.x, m = p.y, y = p.height + p.y, v = this.worldTransform,
                x = v.a, b = v.b, _ = v.c, w = v.d, T = v.tx, P = v.ty, S = x * g + _ * y + T, C = w * y + b * g + P,
                I = x * f + _ * y + T, M = w * y + b * f + P, E = x * f + _ * m + T, A = w * m + b * f + P,
                R = x * g + _ * m + T, O = w * m + b * g + P;
            h = R < (h = E < (h = I < (h = c = S) ? I : h) ? E : h) ? R : h, l = O < (l = A < (l = M < (l = u = C) ? M : l) ? A : l) ? O : l, c = (c = (c = c < I ? I : c) < E ? E : c) < R ? R : c, u = (u = (u = u < M ? M : u) < A ? A : u) < O ? O : u
        }
        if (p.x = h, p.y = l, p.width = c - h, p.height = u - l, i) for (t.worldTransform = n, e = 0; e < t.children.length; e++) t.children[e].updateTransform();
        if (!s) {
            var L = t.getBounds();
            p.x -= L.x, p.y -= L.y
        }
        return p
    }, k.DisplayObjectContainer.prototype.getLocalBounds = function () {
        return this.getBounds(this)
    }, k.DisplayObjectContainer.prototype.contains = function (t) {
        return !!t && (t === this || this.contains(t.parent))
    }, k.DisplayObjectContainer.prototype._renderWebGL = function (t) {
        var e;
        if (this.visible && !(this.alpha <= 0)) if (this._cacheAsBitmap) this._renderCachedSprite(t); else if (this._mask || this._filters) {
            for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
        } else for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
    }, k.DisplayObjectContainer.prototype._renderCanvas = function (t) {
        if (!1 !== this.visible && 0 !== this.alpha) if (this._cacheAsBitmap) this._renderCachedSprite(t); else {
            this._mask && t.maskManager.pushMask(this._mask, t);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    }, Object.defineProperty(k.DisplayObjectContainer.prototype, "width", {
        get: function () {
            return this.getLocalBounds().width * this.scale.x
        }, set: function (t) {
            var e = this.getLocalBounds().width;
            this.scale.x = 0 !== e ? t / e : 1, this._width = t
        }
    }), Object.defineProperty(k.DisplayObjectContainer.prototype, "height", {
        get: function () {
            return this.getLocalBounds().height * this.scale.y
        }, set: function (t) {
            var e = this.getLocalBounds().height;
            this.scale.y = 0 !== e ? t / e : 1, this._height = t
        }
    }), k.Sprite = function (t) {
        k.DisplayObjectContainer.call(this), this.anchor = new k.Point, this.texture = t || k.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = k.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
    }, k.Sprite.prototype = Object.create(k.DisplayObjectContainer.prototype), k.Sprite.prototype.constructor = k.Sprite, Object.defineProperty(k.Sprite.prototype, "width", {
        get: function () {
            return this.scale.x * this.texture.frame.width
        }, set: function (t) {
            this.scale.x = t / this.texture.frame.width, this._width = t
        }
    }), Object.defineProperty(k.Sprite.prototype, "height", {
        get: function () {
            return this.scale.y * this.texture.frame.height
        }, set: function (t) {
            this.scale.y = t / this.texture.frame.height, this._height = t
        }
    }), k.Sprite.prototype.setTexture = function (t, e) {
        void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
    }, k.Sprite.prototype.onTextureUpdate = function () {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
    }, k.Sprite.prototype.getBounds = function (t) {
        var e = this.texture.frame.width, i = this.texture.frame.height, s = e * (1 - this.anchor.x),
            n = e * -this.anchor.x, r = i * (1 - this.anchor.y), o = i * -this.anchor.y, a = t || this.worldTransform,
            h = a.a, l = a.b, c = a.c, u = a.d, d = a.tx, p = a.ty, f = -1 / 0, g = -1 / 0, m = 1 / 0, y = 1 / 0;
        if (0 === l && 0 === c) {
            if (h < 0) {
                h *= -1;
                var v = s;
                s = -n, n = -v
            }
            if (u < 0) {
                u *= -1;
                v = r;
                r = -o, o = -v
            }
            m = h * n + d, f = h * s + d, y = u * o + p, g = u * r + p
        } else {
            var x = h * n + c * o + d, b = u * o + l * n + p, _ = h * s + c * o + d, w = u * o + l * s + p,
                T = h * s + c * r + d, P = u * r + l * s + p, S = h * n + c * r + d, C = u * r + l * n + p;
            m = S < (m = T < (m = _ < (m = x < m ? x : m) ? _ : m) ? T : m) ? S : m, y = C < (y = P < (y = w < (y = b < y ? b : y) ? w : y) ? P : y) ? C : y, f = (f = (f = (f = f < x ? x : f) < _ ? _ : f) < T ? T : f) < S ? S : f, g = (g = (g = (g = g < b ? b : g) < w ? w : g) < P ? P : g) < C ? C : g
        }
        var I = this._bounds;
        return I.x = m, I.width = f - m, I.y = y, I.height = g - y, this._currentBounds = I
    }, k.Sprite.prototype.getLocalBounds = function () {
        var t = this.worldTransform;
        this.worldTransform = k.identityMatrix;
        for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        var i = this.getBounds();
        for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        return i
    }, k.Sprite.prototype._renderWebGL = function (t, e) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var i = this.worldTransform;
            if (e && (i = e), this._mask || this._filters) {
                var s = t.spriteBatch;
                this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this);
                for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
            } else {
                t.spriteBatch.render(this);
                for (n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i)
            }
        }
    }, k.Sprite.prototype._renderCanvas = function (t, e) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            var i = this.worldTransform;
            // console.log('t', t);
            // console.log('e',  e);
            // console.log('this', this);
            if (e && (i = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = k.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                var s = this.texture.baseTexture.resolution / t.resolution;
                t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === k.scaleModes.LINEAR);
                var n = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                    r = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                    o = i.tx * t.resolution + t.shakeX, a = i.ty * t.resolution + t.shakeY;
                t.roundPixels ? (t.context.setTransform(i.a, i.b, i.c, i.d, 0 | o, 0 | a), n |= 0, r |= 0) : t.context.setTransform(i.a, i.b, i.c, i.d, o, a);
                var h = this.texture.crop.width, l = this.texture.crop.height;
                if (n /= s, r /= s, 16777215 !== this.tint) (this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = k.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, h, l, n, r, h / s, l / s); else {
                    var c = this.texture.crop.x, u = this.texture.crop.y;
                    t.context.drawImage(this.texture.baseTexture.source, c, u, h, l, n, r, h / s, l / s)
                }
            }
            for (var d = 0; d < this.children.length; d++) this.children[d]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    }, k.SpriteBatch = function (t) {
        k.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
    }, k.SpriteBatch.prototype = Object.create(k.DisplayObjectContainer.prototype), k.SpriteBatch.prototype.constructor = k.SpriteBatch, k.SpriteBatch.prototype.initWebGL = function (t) {
        this.fastSpriteBatch = new k.WebGLFastSpriteBatch(t), this.ready = !0
    }, k.SpriteBatch.prototype.updateTransform = function () {
        this.displayObjectUpdateTransform()
    }, k.SpriteBatch.prototype._renderWebGL = function (t) {
        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
    }, k.SpriteBatch.prototype._renderCanvas = function (t) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var e = t.context;
            e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
            for (var i = this.worldTransform, s = !0, n = 0; n < this.children.length; n++) {
                var r = this.children[n];
                if (r.visible) {
                    var o = r.texture, a = o.frame;
                    if (e.globalAlpha = this.worldAlpha * r.alpha, r.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * (-a.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * (-a.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, a.width * r.scale.x, a.height * r.scale.y); else {
                        s || (s = !0), r.displayObjectUpdateTransform();
                        var h = r.worldTransform, l = h.tx * t.resolution + t.shakeX,
                            c = h.ty * t.resolution + t.shakeY;
                        t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * -a.width + .5 | 0, r.anchor.y * -a.height + .5 | 0, a.width, a.height)
                    }
                }
            }
        }
    }, k.hex2rgb = function (t) {
        return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
    }, k.rgb2hex = function (t) {
        return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
    }, k.canUseNewCanvasBlendModes = function () {
        if (void 0 === document) return !1;
        var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
            e = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==", i = new Image;
        i.src = t + "AP804Oa6" + e;
        var s = new Image;
        s.src = t + "/wCKxvRF" + e;
        var n = k.CanvasPool.create(this, 6, 1).getContext("2d");
        if (n.globalCompositeOperation = "multiply", n.drawImage(i, 0, 0), n.drawImage(s, 2, 0), !n.getImageData(2, 0, 1, 1)) return !1;
        var r = n.getImageData(2, 0, 1, 1).data;
        return k.CanvasPool.remove(this), 255 === r[0] && 0 === r[1] && 0 === r[2]
    }, k.getNextPowerOfTwo = function (t) {
        if (0 < t && 0 == (t & t - 1)) return t;
        for (var e = 1; e < t;) e <<= 1;
        return e
    }, k.isPowerOfTwo = function (t, e) {
        return 0 < t && 0 == (t & t - 1) && 0 < e && 0 == (e & e - 1)
    }, k.CanvasPool = {
        create: function (t, e, i) {
            var s, n = k.CanvasPool.getFirst();
            if (-1 === n) {
                var r = {parent: t, canvas: document.createElement("canvas")};
                k.CanvasPool.pool.push(r), s = r.canvas
            } else k.CanvasPool.pool[n].parent = t, s = k.CanvasPool.pool[n].canvas;
            return void 0 !== e && (s.width = e, s.height = i), s
        }, getFirst: function () {
            for (var t = k.CanvasPool.pool, e = 0; e < t.length; e++) if (!t[e].parent) return e;
            return -1
        }, remove: function (t) {
            for (var e = k.CanvasPool.pool, i = 0; i < e.length; i++) e[i].parent === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
        }, removeByCanvas: function (t) {
            for (var e = k.CanvasPool.pool, i = 0; i < e.length; i++) e[i].canvas === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
        }, getTotal: function () {
            for (var t = k.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent && e++;
            return e
        }, getFree: function () {
            for (var t = k.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent || e++;
            return e
        }
    }, k.CanvasPool.pool = [], k.initDefaultShaders = function () {
    }, k.CompileVertexShader = function (t, e) {
        return k._CompileShader(t, e, t.VERTEX_SHADER)
    }, k.CompileFragmentShader = function (t, e) {
        return k._CompileShader(t, e, t.FRAGMENT_SHADER)
    }, k._CompileShader = function (t, e, i) {
        var s = e;
        Array.isArray(e) && (s = e.join("\n"));
        var n = t.createShader(i);
        return t.shaderSource(n, s), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)), null)
    }, k.compileProgram = function (t, e, i) {
        var s = k.CompileFragmentShader(t, i), n = k.CompileVertexShader(t, e), r = t.createProgram();
        return t.attachShader(r, n), t.attachShader(r, s), t.linkProgram(r), t.getProgramParameter(r, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(r)), window.console.log("Could not initialise shaders")), r
    }, k.PixiShader = function (t) {
        this._UID = k._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
    }, k.PixiShader.prototype.constructor = k.PixiShader, k.PixiShader.prototype.init = function () {
        var t = this.gl, e = k.compileProgram(t, this.vertexSrc || k.PixiShader.defaultVertexSrc, this.fragmentSrc);
        for (var i in t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute], this.uniforms) this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
        this.initUniforms(), this.program = e
    }, k.PixiShader.prototype.initUniforms = function () {
        this.textureCount = 1;
        var t, e = this.gl;
        for (var i in this.uniforms) {
            var s = (t = this.uniforms[i]).type;
            "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
        }
    }, k.PixiShader.prototype.initSampler2D = function (t) {
        if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
            var e = this.gl;
            if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                var i = t.textureData, s = i.magFilter ? i.magFilter : e.LINEAR,
                    n = i.minFilter ? i.minFilter : e.LINEAR, r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                    o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE, a = i.luminance ? e.LUMINANCE : e.RGBA;
                if (i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                    var h = i.width ? i.width : 512, l = i.height ? i.height : 2, c = i.border ? i.border : 0;
                    e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null)
                } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
            }
            e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
        }
    }, k.PixiShader.prototype.syncUniforms = function () {
        var t;
        this.textureCount = 1;
        var e = this.gl;
        for (var i in this.uniforms) 1 === (t = this.uniforms[i]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? k.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
    }, k.PixiShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, k.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], k.PixiFastShader = function (t) {
        this._UID = k._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
    }, k.PixiFastShader.prototype.constructor = k.PixiFastShader, k.PixiFastShader.prototype.init = function () {
        var t = this.gl, e = k.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = e
    }, k.PixiFastShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, k.StripShader = function (t) {
        this._UID = k._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
    }, k.StripShader.prototype.constructor = k.StripShader, k.StripShader.prototype.init = function () {
        var t = this.gl, e = k.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, k.StripShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, k.PrimitiveShader = function (t) {
        this._UID = k._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
    }, k.PrimitiveShader.prototype.constructor = k.PrimitiveShader, k.PrimitiveShader.prototype.init = function () {
        var t = this.gl, e = k.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, k.PrimitiveShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, k.ComplexPrimitiveShader = function (t) {
        this._UID = k._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
    }, k.ComplexPrimitiveShader.prototype.constructor = k.ComplexPrimitiveShader, k.ComplexPrimitiveShader.prototype.init = function () {
        var t = this.gl, e = k.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, k.ComplexPrimitiveShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, k.glContexts = [], k.instances = [], k.WebGLRenderer = function (t) {
        this.game = t, k.defaultRenderer || (k.defaultRenderer = this), this.type = k.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
            alpha: this.transparent,
            antialias: t.antialias,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: this.preserveDrawingBuffer
        }, this.projection = new k.Point, this.offset = new k.Point, this.shaderManager = new k.WebGLShaderManager, this.spriteBatch = new k.WebGLSpriteBatch, this.maskManager = new k.WebGLMaskManager, this.filterManager = new k.WebGLFilterManager, this.stencilManager = new k.WebGLStencilManager, this.blendModeManager = new k.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, (this.renderSession.renderer = this).renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes()
    }, k.WebGLRenderer.prototype.constructor = k.WebGLRenderer, k.WebGLRenderer.prototype.initContext = function () {
        var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (!(this.gl = t)) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = t.id = k.WebGLRenderer.glContextId++, k.glContexts[this.glContextId] = t, k.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
    }, k.WebGLRenderer.prototype.render = function (t) {
        if (!this.contextLost) {
            var e = this.gl;
            e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
        }
    }, k.WebGLRenderer.prototype.renderDisplayObject = function (t, e, i, s) {
        this.renderSession.blendModeManager.setBlendMode(k.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = i ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, i), t._renderWebGL(this.renderSession, s), this.spriteBatch.end()
    }, k.WebGLRenderer.prototype.resize = function (t, e) {
        this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
    }, k.WebGLRenderer.prototype.updateTexture = function (t) {
        if (!t.hasLoaded) return !1;
        var e = this.gl;
        return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === k.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && k.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === k.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === k.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), !(t._dirty[e.id] = !1)
    }, k.WebGLRenderer.prototype.destroy = function () {
        k.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, k.CanvasPool.remove(this), k.instances[this.glContextId] = null, k.WebGLRenderer.glContextId--
    }, k.WebGLRenderer.prototype.mapBlendModes = function () {
        var t = this.gl;
        if (!k.blendModesWebGL) {
            var e = [], i = k.blendModes;
            e[i.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[i.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[i.SCREEN] = [t.SRC_ALPHA, t.ONE], e[i.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], k.blendModesWebGL = e
        }
    },k.WebGLRenderer.glContextId = 0,k.WebGLBlendModeManager = function () {
        this.currentBlendMode = 99999
    },k.WebGLBlendModeManager.prototype.constructor = k.WebGLBlendModeManager,k.WebGLBlendModeManager.prototype.setContext = function (t) {
        this.gl = t
    },k.WebGLBlendModeManager.prototype.setBlendMode = function (t) {
        if (this.currentBlendMode === t) return !1;
        this.currentBlendMode = t;
        var e = k.blendModesWebGL[this.currentBlendMode];
        return e && this.gl.blendFunc(e[0], e[1]), !0
    },k.WebGLBlendModeManager.prototype.destroy = function () {
        this.gl = null
    },k.WebGLMaskManager = function () {
    },k.WebGLMaskManager.prototype.constructor = k.WebGLMaskManager,k.WebGLMaskManager.prototype.setContext = function (t) {
        this.gl = t
    },k.WebGLMaskManager.prototype.pushMask = function (t, e) {
        var i = e.gl;
        t.dirty && k.WebGLGraphics.updateGraphics(t, i), void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
    },k.WebGLMaskManager.prototype.popMask = function (t, e) {
        var i = this.gl;
        void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
    },k.WebGLMaskManager.prototype.destroy = function () {
        this.gl = null
    },k.WebGLStencilManager = function () {
        this.stencilStack = [], this.reverse = !0, this.count = 0
    },k.WebGLStencilManager.prototype.setContext = function (t) {
        this.gl = t
    },k.WebGLStencilManager.prototype.pushStencil = function (t, e, i) {
        var s = this.gl;
        this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
        var n = this.count;
        s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
    },k.WebGLStencilManager.prototype.bindGraphics = function (t, e, i) {
        this._currentGraphics = t;
        var s, n = this.gl, r = i.projection, o = i.offset;
        1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), n.uniform1f(s.flipY, i.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, k.hex2rgb(t.tint)), n.uniform3fv(s.color, e.color), n.uniform1f(s.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, i.flipY), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, k.hex2rgb(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8)), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)
    },k.WebGLStencilManager.prototype.popStencil = function (t, e, i) {
        var s = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST); else {
            var n = this.count;
            this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0)), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
        }
    },k.WebGLStencilManager.prototype.destroy = function () {
        this.stencilStack = null, this.gl = null
    },k.WebGLShaderManager = function () {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
        this.stack = []
    },k.WebGLShaderManager.prototype.constructor = k.WebGLShaderManager,k.WebGLShaderManager.prototype.setContext = function (t) {
        this.gl = t, this.primitiveShader = new k.PrimitiveShader(t), this.complexPrimitiveShader = new k.ComplexPrimitiveShader(t), this.defaultShader = new k.PixiShader(t), this.fastShader = new k.PixiFastShader(t), this.stripShader = new k.StripShader(t), this.setShader(this.defaultShader)
    },k.WebGLShaderManager.prototype.setAttribs = function (t) {
        var e;
        for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
        for (e = 0; e < t.length; e++) {
            var i = t[e];
            this.tempAttribState[i] = !0
        }
        var s = this.gl;
        for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
    },k.WebGLShaderManager.prototype.setShader = function (t) {
        return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
    },k.WebGLShaderManager.prototype.destroy = function () {
        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
    },k.WebGLSpriteBatch = function () {
        this.vertSize = 5, this.size = 2e3;
        var t = 4 * this.size * 4 * this.vertSize, e = 6 * this.size;
        this.vertices = new k.ArrayBuffer(t), this.positions = new k.Float32Array(this.vertices), this.colors = new k.Uint32Array(this.vertices), this.indices = new k.Uint16Array(e);
        for (var i = this.lastIndexCount = 0, s = 0; i < e; i += 6, s += 4) this.indices[i + 0] = s + 0, this.indices[i + 1] = s + 1, this.indices[i + 2] = s + 2, this.indices[i + 3] = s + 0, this.indices[i + 4] = s + 2, this.indices[i + 5] = s + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new k.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
    },k.WebGLSpriteBatch.prototype.setContext = function (t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
        var e = new k.PixiShader(t);
        e.fragmentSrc = this.defaultShader.fragmentSrc, e.uniforms = {}, e.init(), this.defaultShader.shaders[t.id] = e
    },k.WebGLSpriteBatch.prototype.begin = function (t) {
        this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
    },k.WebGLSpriteBatch.prototype.end = function () {
        this.flush()
    },k.WebGLSpriteBatch.prototype.render = function (t, e) {
        var i = t.texture, s = t.worldTransform;
        e && (s = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
        var n = i._uvs;
        if (n) {
            var r, o, a, h, l = t.anchor.x, c = t.anchor.y;
            if (i.trim) {
                var u = i.trim;
                r = (o = u.x - l * u.width) + i.crop.width, a = (h = u.y - c * u.height) + i.crop.height
            } else r = i.frame.width * (1 - l), o = i.frame.width * -l, a = i.frame.height * (1 - c), h = i.frame.height * -c;
            var d = 4 * this.currentBatchSize * this.vertSize, p = i.baseTexture.resolution, f = s.a / p, g = s.b / p,
                m = s.c / p, y = s.d / p, v = s.tx, x = s.ty, b = this.colors, _ = this.positions;
            this.renderSession.roundPixels ? (_[d] = f * o + m * h + v | 0, _[d + 1] = y * h + g * o + x | 0, _[d + 5] = f * r + m * h + v | 0, _[d + 6] = y * h + g * r + x | 0, _[d + 10] = f * r + m * a + v | 0, _[d + 11] = y * a + g * r + x | 0, _[d + 15] = f * o + m * a + v | 0, _[d + 16] = y * a + g * o + x | 0) : (_[d] = f * o + m * h + v, _[d + 1] = y * h + g * o + x, _[d + 5] = f * r + m * h + v, _[d + 6] = y * h + g * r + x, _[d + 10] = f * r + m * a + v, _[d + 11] = y * a + g * r + x, _[d + 15] = f * o + m * a + v, _[d + 16] = y * a + g * o + x), _[d + 2] = n.x0, _[d + 3] = n.y0, _[d + 7] = n.x1, _[d + 8] = n.y1, _[d + 12] = n.x2, _[d + 13] = n.y2, _[d + 17] = n.x3, _[d + 18] = n.y3;
            var w = t.tint;
            b[d + 4] = b[d + 9] = b[d + 14] = b[d + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t
        }
    },k.WebGLSpriteBatch.prototype.renderTilingSprite = function (t) {
        var e = t.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new k.TextureUvs);
        var i = t._uvs, s = e.baseTexture.width, n = e.baseTexture.height;
        t.tilePosition.x %= s * t.tileScaleOffset.x, t.tilePosition.y %= n * t.tileScaleOffset.y;
        var r = t.tilePosition.x / (s * t.tileScaleOffset.x), o = t.tilePosition.y / (n * t.tileScaleOffset.y),
            a = t.width / s / (t.tileScale.x * t.tileScaleOffset.x),
            h = t.height / n / (t.tileScale.y * t.tileScaleOffset.y);
        i.x0 = 0 - r, i.y0 = 0 - o, i.x1 = 1 * a - r, i.y1 = 0 - o, i.x2 = 1 * a - r, i.y2 = 1 * h - o, i.x3 = 0 - r, i.y3 = 1 * h - o;
        var l = t.tint, c = (l >> 16) + (65280 & l) + ((255 & l) << 16) + (255 * t.worldAlpha << 24),
            u = this.positions, d = this.colors, p = t.width, f = t.height, g = t.anchor.x, m = t.anchor.y,
            y = p * (1 - g), v = p * -g, x = f * (1 - m), b = f * -m, _ = 4 * this.currentBatchSize * this.vertSize,
            w = e.baseTexture.resolution, T = t.worldTransform, P = T.a / w, S = T.b / w, C = T.c / w, I = T.d / w,
            M = T.tx, E = T.ty;
        u[_++] = P * v + C * b + M, u[_++] = I * b + S * v + E, u[_++] = i.x0, u[_++] = i.y0, d[_++] = c, u[_++] = P * y + C * b + M, u[_++] = I * b + S * y + E, u[_++] = i.x1, u[_++] = i.y1, d[_++] = c, u[_++] = P * y + C * x + M, u[_++] = I * x + S * y + E, u[_++] = i.x2, u[_++] = i.y2, d[_++] = c, u[_++] = P * v + C * x + M, u[_++] = I * x + S * v + E, u[_++] = i.x3, u[_++] = i.y3, d[_++] = c, this.sprites[this.currentBatchSize++] = t
    },k.WebGLSpriteBatch.prototype.flush = function () {
        if (0 !== this.currentBatchSize) {
            var t, e, i, s, n = this.gl;
            if (this.dirty) {
                this.dirty = !1, n.activeTexture(n.TEXTURE0), n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t = this.defaultShader.shaders[n.id];
                var r = 4 * this.vertSize;
                n.vertexAttribPointer(t.aVertexPosition, 2, n.FLOAT, !1, r, 0), n.vertexAttribPointer(t.aTextureCoord, 2, n.FLOAT, !1, r, 8), n.vertexAttribPointer(t.colorAttribute, 4, n.UNSIGNED_BYTE, !0, r, 16)
            }
            if (this.currentBatchSize > .5 * this.size) n.bufferSubData(n.ARRAY_BUFFER, 0, this.vertices); else {
                var o = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                n.bufferSubData(n.ARRAY_BUFFER, 0, o)
            }
            for (var a, h = 0, l = 0, c = null, u = this.renderSession.blendModeManager.currentBlendMode, d = null, p = !1, f = !1, g = 0, m = this.currentBatchSize; g < m; g++) {
                e = (a = this.sprites[g]).tilingTexture ? a.tilingTexture.baseTexture : a.texture.baseTexture, p = u !== (i = a.blendMode), f = d !== (s = a.shader || this.defaultShader);
                var y = e.skipRender;
                if (y && 0 < a.children.length && (y = !1), (c !== e && !y || p || f) && (this.renderBatch(c, h, l), l = g, h = 0, c = e, p && (u = i, this.renderSession.blendModeManager.setBlendMode(u)), f)) {
                    (t = (d = s).shaders[n.id]) || ((t = new k.PixiShader(n)).fragmentSrc = d.fragmentSrc, t.uniforms = d.uniforms, t.init(), d.shaders[n.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                    var v = this.renderSession.projection;
                    n.uniform2f(t.projectionVector, v.x, v.y);
                    var x = this.renderSession.offset;
                    n.uniform2f(t.offsetVector, x.x, x.y)
                }
                h++
            }
            this.renderBatch(c, h, l), this.currentBatchSize = 0
        }
    },k.WebGLSpriteBatch.prototype.renderBatch = function (t, e, i) {
        if (0 !== e) {
            var s = this.gl;
            if (t._dirty[s.id]) {
                if (!this.renderSession.renderer.updateTexture(t)) return
            } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
            s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
        }
    },k.WebGLSpriteBatch.prototype.stop = function () {
        this.flush(), this.dirty = !0
    },k.WebGLSpriteBatch.prototype.start = function () {
        this.dirty = !0
    },k.WebGLSpriteBatch.prototype.destroy = function () {
        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
    },k.WebGLFastSpriteBatch = function (t) {
        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
        var e = 4 * this.size * this.vertSize, i = 6 * this.maxSize;
        this.vertices = new k.Float32Array(e), this.indices = new k.Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null;
        for (var s = this.lastIndexCount = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
    },k.WebGLFastSpriteBatch.prototype.constructor = k.WebGLFastSpriteBatch,k.WebGLFastSpriteBatch.prototype.setContext = function (t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
    },k.WebGLFastSpriteBatch.prototype.begin = function (t, e) {
        this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
    },k.WebGLFastSpriteBatch.prototype.end = function () {
        this.flush()
    },k.WebGLFastSpriteBatch.prototype.render = function (t) {
        var e = t.children, i = e[0];
        if (i.texture._uvs) {
            this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
            for (var s = 0, n = e.length; s < n; s++) this.renderSprite(e[s]);
            this.flush()
        }
    },k.WebGLFastSpriteBatch.prototype.renderSprite = function (t) {
        if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) {
            var e, i, s, n, r, o, a = this.vertices;
            if (e = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim) {
                var h = t.texture.trim;
                i = (s = h.x - t.anchor.x * h.width) + t.texture.crop.width, n = (r = h.y - t.anchor.y * h.height) + t.texture.crop.height
            } else i = t.texture.frame.width * (1 - t.anchor.x), s = t.texture.frame.width * -t.anchor.x, n = t.texture.frame.height * (1 - t.anchor.y), r = t.texture.frame.height * -t.anchor.y;
            o = 4 * this.currentBatchSize * this.vertSize, a[o++] = s, a[o++] = r, a[o++] = t.position.x, a[o++] = t.position.y, a[o++] = t.scale.x, a[o++] = t.scale.y, a[o++] = t.rotation, a[o++] = e.x0, a[o++] = e.y1, a[o++] = t.alpha, a[o++] = i, a[o++] = r, a[o++] = t.position.x, a[o++] = t.position.y, a[o++] = t.scale.x, a[o++] = t.scale.y, a[o++] = t.rotation, a[o++] = e.x1, a[o++] = e.y1, a[o++] = t.alpha, a[o++] = i, a[o++] = n, a[o++] = t.position.x, a[o++] = t.position.y, a[o++] = t.scale.x, a[o++] = t.scale.y, a[o++] = t.rotation, a[o++] = e.x2, a[o++] = e.y2, a[o++] = t.alpha, a[o++] = s, a[o++] = n, a[o++] = t.position.x, a[o++] = t.position.y, a[o++] = t.scale.x, a[o++] = t.scale.y, a[o++] = t.rotation, a[o++] = e.x3, a[o++] = e.y3, a[o++] = t.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
        }
    },k.WebGLFastSpriteBatch.prototype.flush = function () {
        if (0 !== this.currentBatchSize) {
            var t = this.gl;
            if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices); else {
                var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                t.bufferSubData(t.ARRAY_BUFFER, 0, e)
            }
            t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
        }
    },k.WebGLFastSpriteBatch.prototype.stop = function () {
        this.flush()
    },k.WebGLFastSpriteBatch.prototype.start = function () {
        var t = this.gl;
        t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var e = this.renderSession.projection;
        t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var i = 4 * this.vertSize;
        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
    },k.WebGLFilterManager = function () {
        this.filterStack = [], this.offsetX = 0, this.offsetY = 0
    },k.WebGLFilterManager.prototype.constructor = k.WebGLFilterManager,k.WebGLFilterManager.prototype.setContext = function (t) {
        this.gl = t, this.texturePool = [], this.initShaderBuffers()
    },k.WebGLFilterManager.prototype.begin = function (t, e) {
        this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
        var i = this.renderSession.projection;
        this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
    },k.WebGLFilterManager.prototype.pushFilter = function (t) {
        var e = this.gl, i = this.renderSession.projection, s = this.renderSession.offset;
        t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new k.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
        var n = t.filterPasses[0];
        this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
        var r = this.texturePool.pop();
        r ? r.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : r = new k.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, r.texture);
        var o = t._filterArea, a = n.padding;
        o.x -= a, o.y -= a, o.width += 2 * a, o.height += 2 * a, o.x < 0 && (o.x = 0), o.width > this.width && (o.width = this.width), o.y < 0 && (o.y = 0), o.height > this.height && (o.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, r.frameBuffer), e.viewport(0, 0, o.width * this.renderSession.resolution, o.height * this.renderSession.resolution), i.x = o.width / 2, i.y = -o.height / 2, s.x = -o.x, s.y = -o.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = r
    },k.WebGLFilterManager.prototype.popFilter = function () {
        var t = this.gl, e = this.filterStack.pop(), i = e._filterArea, s = e._glFilterTexture,
            n = this.renderSession.projection, r = this.renderSession.offset;
        if (1 < e.filterPasses.length) {
            t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = i.height, this.vertexArray[2] = i.width, this.vertexArray[3] = i.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = i.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
            var o = s, a = this.texturePool.pop();
            a || (a = new k.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), a.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, a.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
            for (var h = 0; h < e.filterPasses.length - 1; h++) {
                var l = e.filterPasses[h];
                t.bindFramebuffer(t.FRAMEBUFFER, a.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o.texture), this.applyFilterPass(l, i, i.width, i.height);
                var c = o;
                o = a, a = c
            }
            t.enable(t.BLEND), s = o, this.texturePool.push(a)
        }
        var u = e.filterPasses[e.filterPasses.length - 1];
        this.offsetX -= i.x, this.offsetY -= i.y;
        var d = this.width, p = this.height, f = 0, g = 0, m = this.buffer;
        if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0); else {
            var y = this.filterStack[this.filterStack.length - 1];
            d = (i = y._filterArea).width, p = i.height, f = i.x, g = i.y, m = y._glFilterTexture.frameBuffer
        }
        n.x = d / 2, n.y = -p / 2, r.x = f, r.y = g;
        var v = (i = e._filterArea).x - f, x = i.y - g;
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = v, this.vertexArray[1] = x + i.height, this.vertexArray[2] = v + i.width, this.vertexArray[3] = x + i.height, this.vertexArray[4] = v, this.vertexArray[5] = x, this.vertexArray[6] = v + i.width, this.vertexArray[7] = x, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, d * this.renderSession.resolution, p * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, m), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, s.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, 0 < this.renderSession.stencilManager.count ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(u, i, d, p), this.texturePool.push(s), e._glFilterTexture = null
    },k.WebGLFilterManager.prototype.applyFilterPass = function (t, e, i, s) {
        var n = this.gl, r = t.shaders[n.id];
        r || ((r = new k.PixiShader(n)).fragmentSrc = t.fragmentSrc, r.uniforms = t.uniforms, r.init(), t.shaders[n.id] = r), this.renderSession.shaderManager.setShader(r), n.uniform2f(r.projectionVector, i / 2, -s / 2), n.uniform2f(r.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), r.syncUniforms(), n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), n.vertexAttribPointer(r.aVertexPosition, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this.uvBuffer), n.vertexAttribPointer(r.aTextureCoord, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this.colorBuffer), n.vertexAttribPointer(r.colorAttribute, 2, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.indexBuffer), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
    },k.WebGLFilterManager.prototype.initShaderBuffers = function () {
        var t = this.gl;
        this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new k.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new k.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new k.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
    },k.WebGLFilterManager.prototype.destroy = function () {
        var t = this.gl;
        this.filterStack = null, this.offsetX = 0;
        for (var e = this.offsetY = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
        this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
    },k.FilterTexture = function (t, e, i, s) {
        this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), s = s || k.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, s === k.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, s === k.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(e, i)
    },k.FilterTexture.prototype.constructor = k.FilterTexture,k.FilterTexture.prototype.clear = function () {
        var t = this.gl;
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
    },k.FilterTexture.prototype.resize = function (t, e) {
        if (this.width !== t || this.height !== e) {
            this.width = t, this.height = e;
            var i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
        }
    },k.FilterTexture.prototype.destroy = function () {
        var t = this.gl;
        t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
    },k.CanvasBuffer = function (t, e) {
        this.width = t, this.height = e, this.canvas = k.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
    },k.CanvasBuffer.prototype.constructor = k.CanvasBuffer,k.CanvasBuffer.prototype.clear = function () {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
    },k.CanvasBuffer.prototype.resize = function (t, e) {
        this.width = this.canvas.width = t, this.height = this.canvas.height = e
    },k.CanvasBuffer.prototype.destroy = function () {
        k.CanvasPool.remove(this)
    },k.CanvasMaskManager = function () {
    },k.CanvasMaskManager.prototype.constructor = k.CanvasMaskManager,k.CanvasMaskManager.prototype.pushMask = function (t, e) {
        var i = e.context;
        i.save();
        var s = t.alpha, n = t.worldTransform, r = e.resolution;
        i.setTransform(n.a * r, n.b * r, n.c * r, n.d * r, n.tx * r, n.ty * r), k.CanvasGraphics.renderGraphicsMask(t, i), i.clip(), t.worldAlpha = s
    },k.CanvasMaskManager.prototype.popMask = function (t) {
        t.context.restore()
    },k.CanvasTinter = function () {
    },k.CanvasTinter.getTintedTexture = function (t, e) {
        var i = t.tintedTexture || k.CanvasPool.create(this);
        return k.CanvasTinter.tintMethod(t.texture, e, i), i
    },k.CanvasTinter.tintWithMultiply = function (t, e, i) {
        var s = i.getContext("2d"), n = t.crop;
        i.width === n.width && i.height === n.height || (i.width = n.width, i.height = n.height), s.clearRect(0, 0, n.width, n.height), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, n.width, n.height), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
    },k.CanvasTinter.tintWithPerPixel = function (t, e, i) {
        var s = i.getContext("2d"), n = t.crop;
        i.width = n.width, i.height = n.height, s.globalCompositeOperation = "copy", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height);
        for (var r = k.hex2rgb(e), o = r[0], a = r[1], h = r[2], l = s.getImageData(0, 0, n.width, n.height), c = l.data, u = 0; u < c.length; u += 4) if (c[u + 0] *= o, c[u + 1] *= a, c[u + 2] *= h, !k.CanvasTinter.canHandleAlpha) {
            var d = c[u + 3];
            c[u + 0] /= 255 / d, c[u + 1] /= 255 / d, c[u + 2] /= 255 / d
        }
        s.putImageData(l, 0, 0)
    },k.CanvasTinter.checkInverseAlpha = function () {
        var t = new k.CanvasBuffer(2, 1);
        t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
        var e = t.context.getImageData(0, 0, 1, 1);
        if (null === e) return !1;
        t.context.putImageData(e, 1, 0);
        var i = t.context.getImageData(1, 0, 1, 1);
        return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]
    },k.CanvasTinter.canHandleAlpha = k.CanvasTinter.checkInverseAlpha(),k.CanvasTinter.canUseMultiply = k.canUseNewCanvasBlendModes(),k.CanvasTinter.tintMethod = k.CanvasTinter.canUseMultiply ? k.CanvasTinter.tintWithMultiply : k.CanvasTinter.tintWithPerPixel,k.CanvasRenderer = function (t) {
        this.game = t, k.defaultRenderer || (k.defaultRenderer = this), this.type = k.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {alpha: this.transparent}), this.refresh = !0, this.count = 0, this.maskManager = new k.CanvasMaskManager, this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
            roundPixels: !1
        }, this.mapBlendModes(), this.resize(this.width, this.height)
    },k.CanvasRenderer.prototype.constructor = k.CanvasRenderer,k.CanvasRenderer.prototype.render = function (t) {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
    },k.CanvasRenderer.prototype.destroy = function (t) {
        void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
    },k.CanvasRenderer.prototype.resize = function (t, e) {
        this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === k.scaleModes.LINEAR)
    },k.CanvasRenderer.prototype.renderDisplayObject = function (t, e, i) {
        this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
    },k.CanvasRenderer.prototype.mapBlendModes = function () {
        if (!k.blendModesCanvas) {
            var t = [], e = k.blendModes, i = k.canUseNewCanvasBlendModes();
            t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = i ? "multiply" : "source-over", t[e.SCREEN] = i ? "screen" : "source-over", t[e.OVERLAY] = i ? "overlay" : "source-over", t[e.DARKEN] = i ? "darken" : "source-over", t[e.LIGHTEN] = i ? "lighten" : "source-over", t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over", t[e.COLOR_BURN] = i ? "color-burn" : "source-over", t[e.HARD_LIGHT] = i ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over", t[e.DIFFERENCE] = i ? "difference" : "source-over", t[e.EXCLUSION] = i ? "exclusion" : "source-over", t[e.HUE] = i ? "hue" : "source-over", t[e.SATURATION] = i ? "saturation" : "source-over", t[e.COLOR] = i ? "color" : "source-over", t[e.LUMINOSITY] = i ? "luminosity" : "source-over", k.blendModesCanvas = t
        }
    },k.BaseTexture = function (t, e) {
        this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = e || k.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
    },k.BaseTexture.prototype.constructor = k.BaseTexture,k.BaseTexture.prototype.forceLoaded = function (t, e) {
        this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
    },k.BaseTexture.prototype.destroy = function () {
        this.source && k.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
    },k.BaseTexture.prototype.updateSourceImage = function (t) {
        console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.")
    },k.BaseTexture.prototype.dirty = function () {
        for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
    },k.BaseTexture.prototype.unloadFromGPU = function () {
        this.dirty();
        for (var t = this._glTextures.length - 1; 0 <= t; t--) {
            var e = this._glTextures[t], i = k.glContexts[t];
            i && e && i.deleteTexture(e)
        }
        this._glTextures.length = 0, this.dirty()
    },k.BaseTexture.fromCanvas = function (t, e) {
        return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new k.BaseTexture(t, e)
    },k.TextureSilentFail = !1,k.Texture = function (t, e, i, s) {
        this.noFrame = !1, e || (this.noFrame = !0, e = new k.Rectangle(0, 0, 1, 1)), t instanceof k.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = s, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = i || new k.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (e = new k.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
    },k.Texture.prototype.constructor = k.Texture,k.Texture.prototype.onBaseTextureLoaded = function () {
        var t = this.baseTexture;
        this.noFrame && (this.frame = new k.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
    },k.Texture.prototype.destroy = function (t) {
        t && this.baseTexture.destroy(), this.valid = !1
    },k.Texture.prototype.setFrame = function (t) {
        if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs(); else {
            if (!k.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            this.valid = !1
        }
    },k.Texture.prototype._updateUvs = function () {
        this._uvs || (this._uvs = new k.TextureUvs);
        var t = this.crop, e = this.baseTexture.width, i = this.baseTexture.height;
        this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / i
    },k.Texture.fromCanvas = function (t, e) {
        var i = k.BaseTexture.fromCanvas(t, e);
        return new k.Texture(i)
    },k.TextureUvs = function () {
        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
    },k.RenderTexture = function (t, e, i, s, n) {
        if (this.width = t || 100, this.height = e || 100, this.resolution = n || 1, this.frame = new k.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new k.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new k.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = s || k.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, k.Texture.call(this, this.baseTexture, new k.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = i || k.defaultRenderer, this.renderer.type === k.WEBGL_RENDERER) {
            var r = this.renderer.gl;
            this.baseTexture._dirty[r.id] = !1, this.textureBuffer = new k.FilterTexture(r, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[r.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new k.Point(.5 * this.width, .5 * -this.height)
        } else this.render = this.renderCanvas, this.textureBuffer = new k.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
    },k.RenderTexture.prototype = Object.create(k.Texture.prototype),k.RenderTexture.prototype.constructor = k.RenderTexture,k.RenderTexture.prototype.resize = function (t, e, i) {
        t === this.width && e === this.height || (this.valid = 0 < t && 0 < e, this.width = t, this.height = e, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = e * this.resolution, i && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === k.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
    },k.RenderTexture.prototype.clear = function () {
        this.valid && (this.renderer.type === k.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
    },k.RenderTexture.prototype.renderWebGL = function (t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var s = t.worldTransform;
            s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
            for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
            var r = this.renderer.gl;
            r.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0
        }
    },k.RenderTexture.prototype.renderCanvas = function (t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var s = t.worldTransform;
            s.identity(), e && s.append(e);
            for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
            i && this.textureBuffer.clear();
            var r = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = r
        }
    },k.RenderTexture.prototype.getImage = function () {
        var t = new Image;
        return t.src = this.getBase64(), t
    },k.RenderTexture.prototype.getBase64 = function () {
        return this.getCanvas().toDataURL()
    },k.RenderTexture.prototype.getCanvas = function () {
        if (this.renderer.type !== k.WEBGL_RENDERER) return this.textureBuffer.canvas;
        var t = this.renderer.gl, e = this.textureBuffer.width, i = this.textureBuffer.height,
            s = new Uint8Array(4 * e * i);
        t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, s), t.bindFramebuffer(t.FRAMEBUFFER, null);
        var n = new k.CanvasBuffer(e, i), r = n.context.getImageData(0, 0, e, i);
        return r.data.set(s), n.context.putImageData(r, 0, 0), n.canvas
    },k.AbstractFilter = function (t, e) {
        this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || []
    },k.AbstractFilter.prototype.constructor = k.AbstractFilter,k.AbstractFilter.prototype.syncUniforms = function () {
        for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0
    },"undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = k), exports.PIXI = k) : "undefined" != typeof define && define.amd ? define("PIXI", t.PIXI = k) : t.PIXI = k,k
}).call(this), function () {
    var r, t = this, j = j || {
        VERSION: "2.6.2",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        CIRCLE: 21,
        RECTANGLE: 22,
        LINE: 23,
        MATRIX: 24,
        POINT: 25,
        ROUNDEDRECTANGLE: 26,
        CREATURE: 27,
        VIDEO: 28,
        PENDING_ATLAS: -1,
        HORIZONTAL: 0,
        VERTICAL: 1,
        LANDSCAPE: 0,
        PORTRAIT: 1,
        ANGLE_UP: 270,
        ANGLE_DOWN: 90,
        ANGLE_LEFT: 180,
        ANGLE_RIGHT: 0,
        ANGLE_NORTH_EAST: 315,
        ANGLE_NORTH_WEST: 225,
        ANGLE_SOUTH_EAST: 45,
        ANGLE_SOUTH_WEST: 135,
        TOP_LEFT: 0,
        TOP_CENTER: 1,
        TOP_RIGHT: 2,
        LEFT_TOP: 3,
        LEFT_CENTER: 4,
        LEFT_BOTTOM: 5,
        CENTER: 6,
        RIGHT_TOP: 7,
        RIGHT_CENTER: 8,
        RIGHT_BOTTOM: 9,
        BOTTOM_LEFT: 10,
        BOTTOM_CENTER: 11,
        BOTTOM_RIGHT: 12,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {DEFAULT: 0, LINEAR: 0, NEAREST: 1},
        PIXI: PIXI || {}
    };
    if (Math.trunc || (Math.trunc = function (t) {
        return t < 0 ? Math.ceil(t) : Math.floor(t)
    }), Function.prototype.bind || (Function.prototype.bind = (r = Array.prototype.slice, function (e) {
        var i = this, s = r.call(arguments, 1);
        if ("function" != typeof i) throw new TypeError;

        function n() {
            var t = s.concat(r.call(arguments));
            i.apply(this instanceof n ? this : e, t)
        }

        return n.prototype = function t(e) {
            if (e && (t.prototype = e), !(this instanceof t)) return new t
        }(i.prototype), n
    })), Array.isArray || (Array.isArray = function (t) {
        return "[object Array]" === Object.prototype.toString.call(t)
    }), Array.prototype.forEach || (Array.prototype.forEach = function (t) {
        "use strict";
        if (null == this) throw new TypeError;
        var e = Object(this), i = e.length >>> 0;
        if ("function" != typeof t) throw new TypeError;
        for (var s = 2 <= arguments.length ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(s, e[n], n, e)
    }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
        var e = function (t) {
            var e = new Array;
            window[t] = function (t) {
                if ("number" == typeof t) {
                    Array.call(this, t), this.length = t;
                    for (var e = 0; e < this.length; e++) this[e] = 0
                } else {
                    Array.call(this, t.length), this.length = t.length;
                    for (e = 0; e < this.length; e++) this[e] = t[e]
                }
            }, window[t].prototype = e, window[t].constructor = window[t]
        };
        e("Uint32Array"), e("Int16Array")
    }

    function s(t, e) {
        this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
    }

    for (var i in window.console || (window.console = {}, window.console.log = window.console.assert = function () {
    }, window.console.warn = window.console.assert = function () {
    }), j.Utils = {
        reverseString: function (t) {
            return t.split("").reverse().join("")
        }, getProperty: function (t, e) {
            for (var i = e.split("."), s = i.pop(), n = i.length, r = 1, o = i[0]; r < n && (t = t[o]);) o = i[r], r++;
            return t ? t[s] : null
        }, setProperty: function (t, e, i) {
            for (var s = e.split("."), n = s.pop(), r = s.length, o = 1, a = s[0]; o < r && (t = t[a]);) a = s[o], o++;
            return t && (t[n] = i), t
        }, chanceRoll: function (t) {
            return void 0 === t && (t = 50), 0 < t && 100 * Math.random() <= t
        }, randomChoice: function (t, e) {
            return Math.random() < .5 ? t : e
        }, parseDimension: function (t, e) {
            var i = 0;
            return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, 0 === e ? window.innerWidth * i : window.innerHeight * i) : parseInt(t, 10) : t
        }, pad: function (t, e, i, s) {
            if (void 0 === e) e = 0;
            if (void 0 === i) i = " ";
            if (void 0 === s) s = 3;
            var n = 0;
            if (e + 1 >= (t = t.toString()).length) switch (s) {
                case 1:
                    t = new Array(e + 1 - t.length).join(i) + t;
                    break;
                case 3:
                    var r = Math.ceil((n = e - t.length) / 2);
                    t = new Array(n - r + 1).join(i) + t + new Array(r + 1).join(i);
                    break;
                default:
                    t += new Array(e + 1 - t.length).join(i)
            }
            return t
        }, isPlainObject: function (t) {
            if ("object" != typeof t || t.nodeType || t === t.window) return !1;
            try {
                if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
            } catch (t) {
                return !1
            }
            return !0
        }, extend: function () {
            var t, e, i, s, n, r, o = arguments[0] || {}, a = 1, h = arguments.length, l = !1;
            for ("boolean" == typeof o && (l = o, o = arguments[1] || {}, a = 2), h === a && (o = this, --a); a < h; a++) if (null != (t = arguments[a])) for (e in t) i = o[e], o !== (s = t[e]) && (l && s && (j.Utils.isPlainObject(s) || (n = Array.isArray(s))) ? (r = n ? (n = !1, i && Array.isArray(i) ? i : []) : i && j.Utils.isPlainObject(i) ? i : {}, o[e] = j.Utils.extend(l, r, s)) : void 0 !== s && (o[e] = s));
            return o
        }, mixinPrototype: function (t, e, i) {
            void 0 === i && (i = !1);
            for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                var r = s[n], o = e[r];
                !i && r in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[r] = o : "function" == typeof o.clone ? t[r] = o.clone() : Object.defineProperty(t, r, o))
            }
        }, mixin: function (t, e) {
            if (!t || "object" != typeof t) return e;
            for (var i in t) {
                var s = t[i];
                if (!s.childNodes && !s.cloneNode) {
                    var n = typeof t[i];
                    t[i] && "object" === n ? typeof e[i] === n ? e[i] = j.Utils.mixin(t[i], e[i]) : e[i] = j.Utils.mixin(t[i], new s.constructor) : e[i] = t[i]
                }
            }
            return e
        }
    }, j.Circle = function (t, e, i) {
        t = t || 0, e = e || 0, i = i || 0, this.x = t, this.y = e, this._diameter = i, (this._radius = 0) < i && (this._radius = .5 * i), this.type = j.CIRCLE
    }, j.Circle.prototype = {
        circumference: function () {
            return Math.PI * this._radius * 2
        }, random: function (t) {
            void 0 === t && (t = new j.Point);
            var e = 2 * Math.PI * Math.random(), i = Math.random() + Math.random(), s = 1 < i ? 2 - i : i,
                n = s * Math.cos(e), r = s * Math.sin(e);
            return t.x = this.x + n * this.radius, t.y = this.y + r * this.radius, t
        }, getBounds: function () {
            return new j.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
        }, setTo: function (t, e, i) {
            return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
        }, copyFrom: function (t) {
            return this.setTo(t.x, t.y, t.diameter)
        }, copyTo: function (t) {
            return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
        }, distance: function (t, e) {
            var i = j.Math.distance(this.x, this.y, t.x, t.y);
            return e ? Math.round(i) : i
        }, clone: function (t) {
            return null == t ? t = new j.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
        }, contains: function (t, e) {
            return j.Circle.contains(this, t, e)
        }, circumferencePoint: function (t, e, i) {
            return j.Circle.circumferencePoint(this, t, e, i)
        }, offset: function (t, e) {
            return this.x += t, this.y += e, this
        }, offsetPoint: function (t) {
            return this.offset(t.x, t.y)
        }, toString: function () {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
        }
    }, j.Circle.prototype.constructor = j.Circle, Object.defineProperty(j.Circle.prototype, "diameter", {
        get: function () {
            return this._diameter
        }, set: function (t) {
            0 < t && (this._diameter = t, this._radius = .5 * t)
        }
    }), Object.defineProperty(j.Circle.prototype, "radius", {
        get: function () {
            return this._radius
        }, set: function (t) {
            0 < t && (this._radius = t, this._diameter = 2 * t)
        }
    }), Object.defineProperty(j.Circle.prototype, "left", {
        get: function () {
            return this.x - this._radius
        }, set: function (t) {
            t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
        }
    }), Object.defineProperty(j.Circle.prototype, "right", {
        get: function () {
            return this.x + this._radius
        }, set: function (t) {
            t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
        }
    }), Object.defineProperty(j.Circle.prototype, "top", {
        get: function () {
            return this.y - this._radius
        }, set: function (t) {
            t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
        }
    }), Object.defineProperty(j.Circle.prototype, "bottom", {
        get: function () {
            return this.y + this._radius
        }, set: function (t) {
            t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
        }
    }), Object.defineProperty(j.Circle.prototype, "area", {
        get: function () {
            return 0 < this._radius ? Math.PI * this._radius * this._radius : 0
        }
    }), Object.defineProperty(j.Circle.prototype, "empty", {
        get: function () {
            return 0 === this._diameter
        }, set: function (t) {
            !0 === t && this.setTo(0, 0, 0)
        }
    }), j.Circle.contains = function (t, e, i) {
        return 0 < t.radius && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
    }, j.Circle.equals = function (t, e) {
        return t.x === e.x && t.y === e.y && t.diameter === e.diameter
    }, j.Circle.intersects = function (t, e) {
        return j.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
    }, j.Circle.circumferencePoint = function (t, e, i, s) {
        return void 0 === i && (i = !1), void 0 === s && (s = new j.Point), !0 === i && (e = j.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s
    }, j.Circle.intersectsRectangle = function (t, e) {
        var i = Math.abs(t.x - e.x - e.halfWidth);
        if (e.halfWidth + t.radius < i) return !1;
        var s = Math.abs(t.y - e.y - e.halfHeight);
        if (e.halfHeight + t.radius < s) return !1;
        if (i <= e.halfWidth || s <= e.halfHeight) return !0;
        var n = i - e.halfWidth, r = s - e.halfHeight;
        return n * n + r * r <= t.radius * t.radius
    }, PIXI.Circle = j.Circle, j.Ellipse = function (t, e, i, s) {
        t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = j.ELLIPSE
    }, j.Ellipse.prototype = {
        setTo: function (t, e, i, s) {
            return this.x = t, this.y = e, this.width = i, this.height = s, this
        }, getBounds: function () {
            return new j.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
        }, copyFrom: function (t) {
            return this.setTo(t.x, t.y, t.width, t.height)
        }, copyTo: function (t) {
            return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
        }, clone: function (t) {
            return null == t ? t = new j.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
        }, contains: function (t, e) {
            return j.Ellipse.contains(this, t, e)
        }, random: function (t) {
            void 0 === t && (t = new j.Point);
            var e = Math.random() * Math.PI * 2, i = Math.random();
            return t.x = Math.sqrt(i) * Math.cos(e), t.y = Math.sqrt(i) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
        }, toString: function () {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
        }
    }, j.Ellipse.prototype.constructor = j.Ellipse, Object.defineProperty(j.Ellipse.prototype, "left", {
        get: function () {
            return this.x
        }, set: function (t) {
            this.x = t
        }
    }), Object.defineProperty(j.Ellipse.prototype, "right", {
        get: function () {
            return this.x + this.width
        }, set: function (t) {
            t < this.x ? this.width = 0 : this.width = t - this.x
        }
    }), Object.defineProperty(j.Ellipse.prototype, "top", {
        get: function () {
            return this.y
        }, set: function (t) {
            this.y = t
        }
    }), Object.defineProperty(j.Ellipse.prototype, "bottom", {
        get: function () {
            return this.y + this.height
        }, set: function (t) {
            t < this.y ? this.height = 0 : this.height = t - this.y
        }
    }), Object.defineProperty(j.Ellipse.prototype, "empty", {
        get: function () {
            return 0 === this.width || 0 === this.height
        }, set: function (t) {
            !0 === t && this.setTo(0, 0, 0, 0)
        }
    }), j.Ellipse.contains = function (t, e, i) {
        if (t.width <= 0 || t.height <= 0) return !1;
        var s = (e - t.x) / t.width - .5, n = (i - t.y) / t.height - .5;
        return (s *= s) + (n *= n) < .25
    }, PIXI.Ellipse = j.Ellipse, j.Line = function (t, e, i, s) {
        t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.start = new j.Point(t, e), this.end = new j.Point(i, s), this.type = j.LINE
    }, j.Line.prototype = {
        setTo: function (t, e, i, s) {
            return this.start.setTo(t, e), this.end.setTo(i, s), this
        }, fromSprite: function (t, e, i) {
            return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
        }, fromAngle: function (t, e, i, s) {
            return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this
        }, rotate: function (t, e) {
            var i = (this.start.x + this.end.x) / 2, s = (this.start.y + this.end.y) / 2;
            return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
        }, rotateAround: function (t, e, i, s) {
            return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this
        }, intersects: function (t, e, i) {
            return j.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, i)
        }, reflect: function (t) {
            return j.Line.reflect(this, t)
        }, midPoint: function (t) {
            return void 0 === t && (t = new j.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
        }, centerOn: function (t, e) {
            var i = t - (this.start.x + this.end.x) / 2, s = e - (this.start.y + this.end.y) / 2;
            this.start.add(i, s), this.end.add(i, s)
        }, pointOnLine: function (t, e) {
            return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y)
        }, pointOnSegment: function (t, e) {
            var i = Math.min(this.start.x, this.end.x), s = Math.max(this.start.x, this.end.x),
                n = Math.min(this.start.y, this.end.y), r = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(t, e) && i <= t && t <= s && n <= e && e <= r
        }, random: function (t) {
            void 0 === t && (t = new j.Point);
            var e = Math.random();
            return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
        }, coordinatesOnLine: function (t, e) {
            void 0 === t && (t = 1), void 0 === e && (e = []);
            var i = Math.round(this.start.x), s = Math.round(this.start.y), n = Math.round(this.end.x),
                r = Math.round(this.end.y), o = Math.abs(n - i), a = Math.abs(r - s), h = i < n ? 1 : -1,
                l = s < r ? 1 : -1, c = o - a;
            e.push([i, s]);
            for (var u = 1; i !== n || s !== r;) {
                var d = c << 1;
                -a < d && (c -= a, i += h), d < o && (c += o, s += l), u % t == 0 && e.push([i, s]), u++
            }
            return e
        }, clone: function (t) {
            return null == t ? t = new j.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
        }
    }, Object.defineProperty(j.Line.prototype, "length", {
        get: function () {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
        }
    }), Object.defineProperty(j.Line.prototype, "angle", {
        get: function () {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
        }
    }), Object.defineProperty(j.Line.prototype, "slope", {
        get: function () {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x)
        }
    }), Object.defineProperty(j.Line.prototype, "perpSlope", {
        get: function () {
            return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
        }
    }), Object.defineProperty(j.Line.prototype, "x", {
        get: function () {
            return Math.min(this.start.x, this.end.x)
        }
    }), Object.defineProperty(j.Line.prototype, "y", {
        get: function () {
            return Math.min(this.start.y, this.end.y)
        }
    }), Object.defineProperty(j.Line.prototype, "left", {
        get: function () {
            return Math.min(this.start.x, this.end.x)
        }
    }), Object.defineProperty(j.Line.prototype, "right", {
        get: function () {
            return Math.max(this.start.x, this.end.x)
        }
    }), Object.defineProperty(j.Line.prototype, "top", {
        get: function () {
            return Math.min(this.start.y, this.end.y)
        }
    }), Object.defineProperty(j.Line.prototype, "bottom", {
        get: function () {
            return Math.max(this.start.y, this.end.y)
        }
    }), Object.defineProperty(j.Line.prototype, "width", {
        get: function () {
            return Math.abs(this.start.x - this.end.x)
        }
    }), Object.defineProperty(j.Line.prototype, "height", {
        get: function () {
            return Math.abs(this.start.y - this.end.y)
        }
    }), Object.defineProperty(j.Line.prototype, "normalX", {
        get: function () {
            return Math.cos(this.angle - 1.5707963267948966)
        }
    }), Object.defineProperty(j.Line.prototype, "normalY", {
        get: function () {
            return Math.sin(this.angle - 1.5707963267948966)
        }
    }), Object.defineProperty(j.Line.prototype, "normalAngle", {
        get: function () {
            return j.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
        }
    }), j.Line.intersectsPoints = function (t, e, i, s, n, r) {
        void 0 === n && (n = !0), void 0 === r && (r = new j.Point);
        var o = e.y - t.y, a = s.y - i.y, h = t.x - e.x, l = i.x - s.x, c = e.x * t.y - t.x * e.y,
            u = s.x * i.y - i.x * s.y, d = o * l - a * h;
        if (0 === d) return null;
        if (r.x = (h * u - l * c) / d, r.y = (a * c - o * u) / d, n) {
            var p = (s.y - i.y) * (e.x - t.x) - (s.x - i.x) * (e.y - t.y),
                f = ((s.x - i.x) * (t.y - i.y) - (s.y - i.y) * (t.x - i.x)) / p,
                g = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / p;
            return 0 <= f && f <= 1 && 0 <= g && g <= 1 ? r : null
        }
        return r
    }, j.Line.intersects = function (t, e, i, s) {
        return j.Line.intersectsPoints(t.start, t.end, e.start, e.end, i, s)
    }, j.Line.intersectsRectangle = function (t, e) {
        if (!j.Rectangle.intersects(t, e)) return !1;
        var i = t.start.x, s = t.start.y, n = t.end.x, r = t.end.y, o = e.x, a = e.y, h = e.right, l = e.bottom, c = 0;
        if (o <= i && i <= h && a <= s && s <= l || o <= n && n <= h && a <= r && r <= l) return !0;
        if (i < o && o <= n) {
            if (a < (c = s + (r - s) * (o - i) / (n - i)) && c <= l) return !0
        } else if (h < i && n <= h && a <= (c = s + (r - s) * (h - i) / (n - i)) && c <= l) return !0;
        if (s < a && a <= r) {
            if (o <= (c = i + (n - i) * (a - s) / (r - s)) && c <= h) return !0
        } else if (l < s && r <= l && o <= (c = i + (n - i) * (l - s) / (r - s)) && c <= h) return !0;
        return !1
    }, j.Line.reflect = function (t, e) {
        return 2 * e.normalAngle - 3.141592653589793 - t.angle
    }, j.Matrix = function (t, e, i, s, n, r) {
        null == t && (t = 1), null == e && (e = 0), null == i && (i = 0), null == s && (s = 1), null == n && (n = 0), null == r && (r = 0), this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = r, this.type = j.MATRIX
    }, j.Matrix.prototype = {
        fromArray: function (t) {
            return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
        }, setTo: function (t, e, i, s, n, r) {
            return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = r, this
        }, clone: function (t) {
            return null == t ? t = new j.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
        }, copyTo: function (t) {
            return t.copyFrom(this), t
        }, copyFrom: function (t) {
            return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
        }, toArray: function (t, e) {
            return void 0 === e && (e = new PIXI.Float32Array(9)), e[8] = (e[7] = t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, this.ty) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0), 1), e
        }, apply: function (t, e) {
            return void 0 === e && (e = new j.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
        }, applyInverse: function (t, e) {
            void 0 === e && (e = new j.Point);
            var i = 1 / (this.a * this.d + this.c * -this.b), s = t.x, n = t.y;
            return e.x = this.d * i * s + -this.c * i * n + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * n + -this.b * i * s + (-this.ty * this.a + this.tx * this.b) * i, e
        }, translate: function (t, e) {
            return this.tx += t, this.ty += e, this
        }, scale: function (t, e) {
            return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
        }, rotate: function (t) {
            var e = Math.cos(t), i = Math.sin(t), s = this.a, n = this.c, r = this.tx;
            return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = n * e - this.d * i, this.d = n * i + this.d * e, this.tx = r * e - this.ty * i, this.ty = r * i + this.ty * e, this
        }, append: function (t) {
            var e = this.a, i = this.b, s = this.c, n = this.d;
            return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * n, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * n, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this
        }, identity: function () {
            return this.setTo(1, 0, 0, 1, 0, 0)
        }
    }, j.identityMatrix = new j.Matrix, PIXI.Matrix = j.Matrix, PIXI.identityMatrix = j.identityMatrix, j.Point = function (t, e) {
        t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = j.POINT
    }, j.Point.prototype = {
        copyFrom: function (t) {
            return this.setTo(t.x, t.y)
        }, invert: function () {
            return this.setTo(this.y, this.x)
        }, setTo: function (t, e) {
            return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
        }, set: function (t, e) {
            return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
        }, add: function (t, e) {
            return this.x += t, this.y += e, this
        }, subtract: function (t, e) {
            return this.x -= t, this.y -= e, this
        }, multiply: function (t, e) {
            return this.x *= t, this.y *= e, this
        }, divide: function (t, e) {
            return this.x /= t, this.y /= e, this
        }, clampX: function (t, e) {
            return this.x = j.Math.clamp(this.x, t, e), this
        }, clampY: function (t, e) {
            return this.y = j.Math.clamp(this.y, t, e), this
        }, clamp: function (t, e) {
            return this.x = j.Math.clamp(this.x, t, e), this.y = j.Math.clamp(this.y, t, e), this
        }, clone: function (t) {
            return null == t ? t = new j.Point(this.x, this.y) : t.setTo(this.x, this.y), t
        }, copyTo: function (t) {
            return t.x = this.x, t.y = this.y, t
        }, distance: function (t, e) {
            return j.Point.distance(this, t, e)
        }, equals: function (t) {
            return t.x === this.x && t.y === this.y
        }, angle: function (t, e) {
            return void 0 === e && (e = !1), e ? j.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
        }, rotate: function (t, e, i, s, n) {
            return j.Point.rotate(this, t, e, i, s, n)
        }, getMagnitude: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }, getMagnitudeSq: function () {
            return this.x * this.x + this.y * this.y
        }, setMagnitude: function (t) {
            return this.normalize().multiply(t, t)
        }, normalize: function () {
            if (!this.isZero()) {
                var t = this.getMagnitude();
                this.x /= t, this.y /= t
            }
            return this
        }, isZero: function () {
            return 0 === this.x && 0 === this.y
        }, dot: function (t) {
            return this.x * t.x + this.y * t.y
        }, cross: function (t) {
            return this.x * t.y - this.y * t.x
        }, perp: function () {
            return this.setTo(-this.y, this.x)
        }, rperp: function () {
            return this.setTo(this.y, -this.x)
        }, normalRightHand: function () {
            return this.setTo(-1 * this.y, this.x)
        }, floor: function () {
            return this.setTo(Math.floor(this.x), Math.floor(this.y))
        }, ceil: function () {
            return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
        }, toString: function () {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
        }
    }, j.Point.prototype.constructor = j.Point, j.Point.add = function (t, e, i) {
        return void 0 === i && (i = new j.Point), i.x = t.x + e.x, i.y = t.y + e.y, i
    }, j.Point.subtract = function (t, e, i) {
        return void 0 === i && (i = new j.Point), i.x = t.x - e.x, i.y = t.y - e.y, i
    }, j.Point.multiply = function (t, e, i) {
        return void 0 === i && (i = new j.Point), i.x = t.x * e.x, i.y = t.y * e.y, i
    }, j.Point.divide = function (t, e, i) {
        return void 0 === i && (i = new j.Point), i.x = t.x / e.x, i.y = t.y / e.y, i
    }, j.Point.equals = function (t, e) {
        return t.x === e.x && t.y === e.y
    }, j.Point.angle = function (t, e) {
        return Math.atan2(t.y - e.y, t.x - e.x)
    }, j.Point.negative = function (t, e) {
        return void 0 === e && (e = new j.Point), e.setTo(-t.x, -t.y)
    }, j.Point.multiplyAdd = function (t, e, i, s) {
        return void 0 === s && (s = new j.Point), s.setTo(t.x + e.x * i, t.y + e.y * i)
    }, j.Point.interpolate = function (t, e, i, s) {
        return void 0 === s && (s = new j.Point), s.setTo(t.x + (e.x - t.x) * i, t.y + (e.y - t.y) * i)
    }, j.Point.perp = function (t, e) {
        return void 0 === e && (e = new j.Point), e.setTo(-t.y, t.x)
    }, j.Point.rperp = function (t, e) {
        return void 0 === e && (e = new j.Point), e.setTo(t.y, -t.x)
    }, j.Point.distance = function (t, e, i) {
        var s = j.Math.distance(t.x, t.y, e.x, e.y);
        return i ? Math.round(s) : s
    }, j.Point.project = function (t, e, i) {
        void 0 === i && (i = new j.Point);
        var s = t.dot(e) / e.getMagnitudeSq();
        return 0 !== s && i.setTo(s * e.x, s * e.y), i
    }, j.Point.projectUnit = function (t, e, i) {
        void 0 === i && (i = new j.Point);
        var s = t.dot(e);
        return 0 !== s && i.setTo(s * e.x, s * e.y), i
    }, j.Point.normalRightHand = function (t, e) {
        return void 0 === e && (e = new j.Point), e.setTo(-1 * t.y, t.x)
    }, j.Point.normalize = function (t, e) {
        void 0 === e && (e = new j.Point);
        var i = t.getMagnitude();
        return 0 !== i && e.setTo(t.x / i, t.y / i), e
    }, j.Point.rotate = function (t, e, i, s, n, r) {
        if (n && (s = j.Math.degToRad(s)), void 0 === r) {
            t.subtract(e, i);
            var o = Math.sin(s), a = Math.cos(s), h = a * t.x - o * t.y, l = o * t.x + a * t.y;
            t.x = h + e, t.y = l + i
        } else {
            var c = s + Math.atan2(t.y - i, t.x - e);
            t.x = e + r * Math.cos(c), t.y = i + r * Math.sin(c)
        }
        return t
    }, j.Point.centroid = function (t, e) {
        if (void 0 === e && (e = new j.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
        var i = t.length;
        if (i < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        if (1 === i) return e.copyFrom(t[0]), e;
        for (var s = 0; s < i; s++) j.Point.add(e, t[s], e);
        return e.divide(i, i), e
    }, j.Point.parse = function (t, e, i) {
        e = e || "x", i = i || "y";
        var s = new j.Point;
        return t[e] && (s.x = parseInt(t[e], 10)), t[i] && (s.y = parseInt(t[i], 10)), s
    }, PIXI.Point = j.Point, j.Polygon = function () {
        this.area = 0, this._points = [], 0 < arguments.length && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = j.POLYGON
    }, j.Polygon.prototype = {
        toNumberArray: function (t) {
            void 0 === t && (t = []);
            for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
            return t
        }, flatten: function () {
            return this._points = this.toNumberArray(), this.flattened = !0, this
        }, clone: function (t) {
            var e = this._points.slice();
            return null == t ? t = new j.Polygon(e) : t.setTo(e), t
        }, contains: function (t, e) {
            var i = !1;
            if (this.flattened) for (var s = -2, n = this._points.length - 2; (s += 2) < this._points.length; n = s) {
                var r = this._points[s], o = this._points[s + 1], a = this._points[n], h = this._points[n + 1];
                (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
            } else for (s = -1, n = this._points.length - 1; ++s < this._points.length; n = s) {
                r = this._points[s].x, o = this._points[s].y, a = this._points[n].x, h = this._points[n].y;
                (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
            }
            return i
        }, setTo: function (t) {
            if (this.area = 0, this._points = [], 0 < arguments.length) {
                Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                    if ("number" == typeof t[i]) {
                        var n = new PIXI.Point(t[i], t[i + 1]);
                        i++
                    } else if (Array.isArray(t[i])) n = new PIXI.Point(t[i][0], t[i][1]); else n = new PIXI.Point(t[i].x, t[i].y);
                    this._points.push(n), n.y < e && (e = n.y)
                }
                this.calculateArea(e)
            }
            return this
        }, calculateArea: function (t) {
            for (var e, i, s, n, r = 0, o = this._points.length; r < o; r++) e = this._points[r], i = r === o - 1 ? this._points[0] : this._points[r + 1], s = (e.y - t + (i.y - t)) / 2, n = e.x - i.x, this.area += s * n;
            return this.area
        }
    }, j.Polygon.prototype.constructor = j.Polygon, Object.defineProperty(j.Polygon.prototype, "points", {
        get: function () {
            return this._points
        }, set: function (t) {
            null != t ? this.setTo(t) : this.setTo()
        }
    }), PIXI.Polygon = j.Polygon, j.Rectangle = function (t, e, i, s) {
        t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = j.RECTANGLE
    }, j.Rectangle.prototype = {
        offset: function (t, e) {
            return this.x += t, this.y += e, this
        }, offsetPoint: function (t) {
            return this.offset(t.x, t.y)
        }, setTo: function (t, e, i, s) {
            return this.x = t, this.y = e, this.width = i, this.height = s, this
        }, scale: function (t, e) {
            return void 0 === e && (e = t), this.width *= t, this.height *= e, this
        }, centerOn: function (t, e) {
            return this.centerX = t, this.centerY = e, this
        }, floor: function () {
            this.x = Math.floor(this.x), this.y = Math.floor(this.y)
        }, floorAll: function () {
            this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
        }, ceil: function () {
            this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
        }, ceilAll: function () {
            this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
        }, copyFrom: function (t) {
            return this.setTo(t.x, t.y, t.width, t.height)
        }, copyTo: function (t) {
            return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
        }, inflate: function (t, e) {
            return j.Rectangle.inflate(this, t, e)
        }, size: function (t) {
            return j.Rectangle.size(this, t)
        }, resize: function (t, e) {
            return this.width = t, this.height = e, this
        }, clone: function (t) {
            return j.Rectangle.clone(this, t)
        }, contains: function (t, e) {
            return j.Rectangle.contains(this, t, e)
        }, containsRect: function (t) {
            return j.Rectangle.containsRect(t, this)
        }, equals: function (t) {
            return j.Rectangle.equals(this, t)
        }, intersection: function (t, e) {
            return j.Rectangle.intersection(this, t, e)
        }, intersects: function (t) {
            return j.Rectangle.intersects(this, t)
        }, intersectsRaw: function (t, e, i, s, n) {
            return j.Rectangle.intersectsRaw(this, t, e, i, s, n)
        }, union: function (t, e) {
            return j.Rectangle.union(this, t, e)
        }, random: function (t) {
            return void 0 === t && (t = new j.Point), t.x = this.randomX, t.y = this.randomY, t
        }, getPoint: function (t, e) {
            switch (void 0 === e && (e = new j.Point), t) {
                default:
                case j.TOP_LEFT:
                    return e.set(this.x, this.y);
                case j.TOP_CENTER:
                    return e.set(this.centerX, this.y);
                case j.TOP_RIGHT:
                    return e.set(this.right, this.y);
                case j.LEFT_CENTER:
                    return e.set(this.x, this.centerY);
                case j.CENTER:
                    return e.set(this.centerX, this.centerY);
                case j.RIGHT_CENTER:
                    return e.set(this.right, this.centerY);
                case j.BOTTOM_LEFT:
                    return e.set(this.x, this.bottom);
                case j.BOTTOM_CENTER:
                    return e.set(this.centerX, this.bottom);
                case j.BOTTOM_RIGHT:
                    return e.set(this.right, this.bottom)
            }
        }, toString: function () {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
        }
    }, Object.defineProperty(j.Rectangle.prototype, "halfWidth", {
        get: function () {
            return Math.round(this.width / 2)
        }
    }), Object.defineProperty(j.Rectangle.prototype, "halfHeight", {
        get: function () {
            return Math.round(this.height / 2)
        }
    }), Object.defineProperty(j.Rectangle.prototype, "bottom", {
        get: function () {
            return this.y + this.height
        }, set: function (t) {
            t <= this.y ? this.height = 0 : this.height = t - this.y
        }
    }), Object.defineProperty(j.Rectangle.prototype, "bottomLeft", {
        get: function () {
            return new j.Point(this.x, this.bottom)
        }, set: function (t) {
            this.x = t.x, this.bottom = t.y
        }
    }), Object.defineProperty(j.Rectangle.prototype, "bottomRight", {
        get: function () {
            return new j.Point(this.right, this.bottom)
        }, set: function (t) {
            this.right = t.x, this.bottom = t.y
        }
    }), Object.defineProperty(j.Rectangle.prototype, "left", {
        get: function () {
            return this.x
        }, set: function (t) {
            t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
        }
    }), Object.defineProperty(j.Rectangle.prototype, "right", {
        get: function () {
            return this.x + this.width
        }, set: function (t) {
            t <= this.x ? this.width = 0 : this.width = t - this.x
        }
    }), Object.defineProperty(j.Rectangle.prototype, "volume", {
        get: function () {
            return this.width * this.height
        }
    }), Object.defineProperty(j.Rectangle.prototype, "perimeter", {
        get: function () {
            return 2 * this.width + 2 * this.height
        }
    }), Object.defineProperty(j.Rectangle.prototype, "centerX", {
        get: function () {
            return this.x + this.halfWidth
        }, set: function (t) {
            this.x = t - this.halfWidth
        }
    }), Object.defineProperty(j.Rectangle.prototype, "centerY", {
        get: function () {
            return this.y + this.halfHeight
        }, set: function (t) {
            this.y = t - this.halfHeight
        }
    }), Object.defineProperty(j.Rectangle.prototype, "randomX", {
        get: function () {
            return this.x + Math.random() * this.width
        }
    }), Object.defineProperty(j.Rectangle.prototype, "randomY", {
        get: function () {
            return this.y + Math.random() * this.height
        }
    }), Object.defineProperty(j.Rectangle.prototype, "top", {
        get: function () {
            return this.y
        }, set: function (t) {
            t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
        }
    }), Object.defineProperty(j.Rectangle.prototype, "topLeft", {
        get: function () {
            return new j.Point(this.x, this.y)
        }, set: function (t) {
            this.x = t.x, this.y = t.y
        }
    }), Object.defineProperty(j.Rectangle.prototype, "topRight", {
        get: function () {
            return new j.Point(this.x + this.width, this.y)
        }, set: function (t) {
            this.right = t.x, this.y = t.y
        }
    }),Object.defineProperty(j.Rectangle.prototype, "empty", {
        get: function () {
            return !this.width || !this.height
        }, set: function (t) {
            !0 === t && this.setTo(0, 0, 0, 0)
        }
    }),j.Rectangle.prototype.constructor = j.Rectangle,j.Rectangle.inflate = function (t, e, i) {
        return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
    },j.Rectangle.inflatePoint = function (t, e) {
        return j.Rectangle.inflate(t, e.x, e.y)
    },j.Rectangle.size = function (t, e) {
        return null == e ? e = new j.Point(t.width, t.height) : e.setTo(t.width, t.height), e
    },j.Rectangle.clone = function (t, e) {
        return null == e ? e = new j.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
    },j.Rectangle.contains = function (t, e, i) {
        return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
    },j.Rectangle.containsRaw = function (t, e, i, s, n, r) {
        return t <= n && n < t + i && e <= r && r < e + s
    },j.Rectangle.containsPoint = function (t, e) {
        return j.Rectangle.contains(t, e.x, e.y)
    },j.Rectangle.containsRect = function (t, e) {
        return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
    },j.Rectangle.equals = function (t, e) {
        return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
    },j.Rectangle.sameDimensions = function (t, e) {
        return t.width === e.width && t.height === e.height
    },j.Rectangle.intersection = function (t, e, i) {
        return void 0 === i && (i = new j.Rectangle), j.Rectangle.intersects(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i
    },j.Rectangle.intersects = function (t, e) {
        return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
    },j.Rectangle.intersectsRaw = function (t, e, i, s, n, r) {
        return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r)
    },j.Rectangle.union = function (t, e, i) {
        return void 0 === i && (i = new j.Rectangle), i.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
    },j.Rectangle.aabb = function (t, e) {
        void 0 === e && (e = new j.Rectangle);
        var i = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY,
            r = Number.POSITIVE_INFINITY;
        return t.forEach(function (t) {
            t.x > i && (i = t.x), t.x < s && (s = t.x), t.y > n && (n = t.y), t.y < r && (r = t.y)
        }), e.setTo(s, r, i - s, n - r), e
    },PIXI.Rectangle = j.Rectangle,PIXI.EmptyRectangle = new j.Rectangle(0, 0, 0, 0),j.RoundedRectangle = function (t, e, i, s, n) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 20), this.x = t, this.y = e, this.width = i, this.height = s, this.radius = n || 20, this.type = j.ROUNDEDRECTANGLE
    },j.RoundedRectangle.prototype = {
        clone: function () {
            return new j.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
        }, contains: function (t, e) {
            if (this.width <= 0 || this.height <= 0) return !1;
            var i = this.x;
            if (i <= t && t <= i + this.width) {
                var s = this.y;
                if (s <= e && e <= s + this.height) return !0
            }
            return !1
        }
    },j.RoundedRectangle.prototype.constructor = j.RoundedRectangle,PIXI.RoundedRectangle = j.RoundedRectangle,j.Camera = function (t, e, i, s, n, r) {
        this.game = t, this.world = t.world, this.id = 0, this.view = new j.Rectangle(i, s, n, r), this.bounds = new j.Rectangle(i, s, n, r), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
            x: !1,
            y: !1
        }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new j.Point(1, 1), this.onShakeComplete = new j.Signal, this.onFlashComplete = new j.Signal, this.onFadeComplete = new j.Signal, this.fx = null, this._targetPosition = new j.Point, this._edge = 0, this._position = new j.Point, this._shake = {
            intensity: 0,
            duration: 0,
            horizontal: !1,
            vertical: !1,
            shakeBounds: !0,
            x: 0,
            y: 0
        }, this._fxDuration = 0, this._fxType = 0
    },j.Camera.FOLLOW_LOCKON = 0,j.Camera.FOLLOW_PLATFORMER = 1,j.Camera.FOLLOW_TOPDOWN = 2,j.Camera.FOLLOW_TOPDOWN_TIGHT = 3,j.Camera.SHAKE_BOTH = 4,j.Camera.SHAKE_HORIZONTAL = 5,j.Camera.SHAKE_VERTICAL = 6,j.Camera.ENABLE_FX = !0,j.Camera.prototype = {
        boot: function () {
            this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, j.Graphics && j.Camera.ENABLE_FX && (this.fx = new j.Graphics(this.game), this.game.stage.addChild(this.fx))
        }, preUpdate: function () {
            this.totalInView = 0
        }, follow: function (t, e, i, s) {
            var n;
            switch (void 0 === e && (e = j.Camera.FOLLOW_LOCKON), void 0 === i && (i = 1), void 0 === s && (s = 1), this.target = t, this.lerp.set(i, s), e) {
                case j.Camera.FOLLOW_PLATFORMER:
                    var r = this.width / 8, o = this.height / 3;
                    this.deadzone = new j.Rectangle((this.width - r) / 2, (this.height - o) / 2 - .25 * o, r, o);
                    break;
                case j.Camera.FOLLOW_TOPDOWN:
                    n = Math.max(this.width, this.height) / 4, this.deadzone = new j.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                    break;
                case j.Camera.FOLLOW_TOPDOWN_TIGHT:
                    n = Math.max(this.width, this.height) / 8, this.deadzone = new j.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                    break;
                case j.Camera.FOLLOW_LOCKON:
                default:
                    this.deadzone = null
            }
        }, unfollow: function () {
            this.target = null
        }, focusOn: function (t) {
            this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
        }, focusOnXY: function (t, e) {
            this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
        }, shake: function (t, e, i, s, n) {
            return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === i && (i = !0), void 0 === s && (s = j.Camera.SHAKE_BOTH), void 0 === n && (n = !0), !(!i && 0 < this._shake.duration) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = n, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = s === j.Camera.SHAKE_BOTH || s === j.Camera.SHAKE_HORIZONTAL, this._shake.vertical = s === j.Camera.SHAKE_BOTH || s === j.Camera.SHAKE_VERTICAL, !0)
        }, flash: function (t, e, i) {
            return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && 0 < this._fxDuration) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, !(this._fxType = 0))
        }, fade: function (t, e, i) {
            return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && 0 < this._fxDuration) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0)
        }, update: function () {
            0 < this._fxDuration && this.updateFX(), 0 < this._shake.duration && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
        }, updateFX: function () {
            0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, 1 <= this.fx.alpha && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
        }, updateShake: function () {
            this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
        }, updateTarget: function () {
            this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
        }, setBoundsToWorld: function () {
            this.bounds && this.bounds.copyFrom(this.game.world.bounds)
        }, checkBounds: function () {
            this.atLimit.x = !1, this.atLimit.y = !1;
            var t = this.view.x + this._shake.x, e = this.view.right + this._shake.x, i = this.view.y + this._shake.y,
                s = this.view.bottom + this._shake.y;
            t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
        }, setPosition: function (t, e) {
            this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
        }, setSize: function (t, e) {
            this.view.width = t, this.view.height = e
        }, reset: function () {
            this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
        }, resetFX: function () {
            this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0
        }
    },j.Camera.prototype.constructor = j.Camera,Object.defineProperty(j.Camera.prototype, "x", {
        get: function () {
            return this.view.x
        }, set: function (t) {
            this.view.x = t, this.bounds && this.checkBounds()
        }
    }),Object.defineProperty(j.Camera.prototype, "y", {
        get: function () {
            return this.view.y
        }, set: function (t) {
            this.view.y = t, this.bounds && this.checkBounds()
        }
    }),Object.defineProperty(j.Camera.prototype, "position", {
        get: function () {
            return this._position.set(this.view.x, this.view.y), this._position
        }, set: function (t) {
            void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
        }
    }),Object.defineProperty(j.Camera.prototype, "width", {
        get: function () {
            return this.view.width
        }, set: function (t) {
            this.view.width = t
        }
    }),Object.defineProperty(j.Camera.prototype, "height", {
        get: function () {
            return this.view.height
        }, set: function (t) {
            this.view.height = t
        }
    }),Object.defineProperty(j.Camera.prototype, "shakeIntensity", {
        get: function () {
            return this._shake.intensity
        }, set: function (t) {
            this._shake.intensity = t
        }
    }),j.State = function () {
        this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
    },j.State.prototype = {
        init: function () {
        }, preload: function () {
        }, loadUpdate: function () {
        }, loadRender: function () {
        }, create: function () {
        }, update: function () {
        }, preRender: function () {
        }, render: function () {
        }, resize: function () {
        }, paused: function () {
        }, resumed: function () {
        }, pauseUpdate: function () {
        }, shutdown: function () {
        }
    },j.State.prototype.constructor = j.State,j.StateManager = function (t, e) {
        this.game = t, this.states = {}, (this._pendingState = null) != e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new j.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
    },j.StateManager.prototype = {
        boot: function () {
            this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
        }, add: function (t, e, i) {
            var s;
            return void 0 === i && (i = !1), e instanceof j.State ? s = e : "object" == typeof e ? (s = e).game = this.game : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, i && (this.game.isBooted ? this.start(t) : this._pendingState = t), s
        }, remove: function (t) {
            this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
        }, start: function (t, e, i) {
            void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, 3 < arguments.length && (this._args = Array.prototype.splice.call(arguments, 3)))
        }, restart: function (t, e) {
            void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, 2 < arguments.length && (this._args = Array.prototype.slice.call(arguments, 2))
        }, dummy: function () {
        }, preUpdate: function () {
            if (this._pendingState && this.game.isBooted) {
                var t = this.current;
                if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
            }
        }, clearCurrentState: function () {
            this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
        }, checkState: function (t) {
            return this.states[t] ? !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render) || (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
        }, link: function (t) {
            this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, (this.states[t].state = this).states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t
        }, unlink: function (t) {
            this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null)
        }, setCurrentState: function (t) {
            this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
        }, getCurrentState: function () {
            return this.states[this.current]
        }, loadComplete: function () {
            !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
        }, pause: function () {
            this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
        }, resume: function () {
            this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
        }, update: function () {
            this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        }, pauseUpdate: function () {
            this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        }, preRender: function (t) {
            this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
        }, resize: function (t, e) {
            this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
        }, render: function () {
            this._created ? this.onRenderCallback && (this.game.renderType === j.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
        }, destroy: function () {
            this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
        }
    },j.StateManager.prototype.constructor = j.StateManager,Object.defineProperty(j.StateManager.prototype, "created", {
        get: function () {
            return this._created
        }
    }),j.Signal = function () {
    },j.Signal.prototype = {
        _bindings: null,
        _prevParams: null,
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        _boundDispatch: !1,
        validateListener: function (t, e) {
            if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
        },
        _registerListener: function (t, e, i, s, n) {
            var r, o = this._indexOfListener(t, i);
            if (-1 !== o) {
                if ((r = this._bindings[o]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
            } else r = new j.SignalBinding(this, t, e, i, s, n), this._addBinding(r);
            return this.memorize && this._prevParams && r.execute(this._prevParams), r
        },
        _addBinding: function (t) {
            this._bindings || (this._bindings = []);
            for (var e = this._bindings.length; e--, this._bindings[e] && t._priority <= this._bindings[e]._priority;) ;
            this._bindings.splice(e + 1, 0, t)
        },
        _indexOfListener: function (t, e) {
            if (!this._bindings) return -1;
            void 0 === e && (e = null);
            for (var i, s = this._bindings.length; s--;) if ((i = this._bindings[s])._listener === t && i.context === e) return s;
            return -1
        },
        has: function (t, e) {
            return -1 !== this._indexOfListener(t, e)
        },
        add: function (t, e, i) {
            this.validateListener(t, "add");
            var s = [];
            if (3 < arguments.length) for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
            return this._registerListener(t, !1, e, i, s)
        },
        addOnce: function (t, e, i) {
            this.validateListener(t, "addOnce");
            var s = [];
            if (3 < arguments.length) for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
            return this._registerListener(t, !0, e, i, s)
        },
        remove: function (t, e) {
            this.validateListener(t, "remove");
            var i = this._indexOfListener(t, e);
            return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
        },
        removeAll: function (t) {
            if (void 0 === t && (t = null), this._bindings) {
                for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                t || (this._bindings.length = 0)
            }
        },
        getNumListeners: function () {
            return this._bindings ? this._bindings.length : 0
        },
        halt: function () {
            this._shouldPropagate = !1
        },
        dispatch: function () {
            if (this.active && this._bindings) {
                var t, e = Array.prototype.slice.call(arguments), i = this._bindings.length;
                if (this.memorize && (this._prevParams = e), i) for (t = this._bindings.slice(), this._shouldPropagate = !0; t[--i] && this._shouldPropagate && !1 !== t[i].execute(e);) ;
            }
        },
        forget: function () {
            this._prevParams && (this._prevParams = null)
        },
        dispose: function () {
            this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
        },
        toString: function () {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
        }
    },Object.defineProperty(j.Signal.prototype, "boundDispatch", {
        get: function () {
            var t = this;
            return this._boundDispatch || (this._boundDispatch = function () {
                return t.dispatch.apply(t, arguments)
            })
        }
    }),j.Signal.prototype.constructor = j.Signal,j.SignalBinding = function (t, e, i, s, n, r) {
        this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, n && (this._priority = n), r && r.length && (this._args = r)
    },j.SignalBinding.prototype = {
        context: null,
        _isOnce: !1,
        _priority: 0,
        _args: null,
        callCount: 0,
        active: !0,
        params: null,
        execute: function (t) {
            var e, i;
            return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
        },
        detach: function () {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null
        },
        isBound: function () {
            return !!this._signal && !!this._listener
        },
        isOnce: function () {
            return this._isOnce
        },
        getListener: function () {
            return this._listener
        },
        getSignal: function () {
            return this._signal
        },
        _destroy: function () {
            delete this._signal, delete this._listener, delete this.context
        },
        toString: function () {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
        }
    },j.SignalBinding.prototype.constructor = j.SignalBinding,j.Filter = function (t, e, i) {
        this.game = t, this.type = j.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new j.Point;
        var s = new Date;
        if (this.uniforms = {
            resolution: {type: "2f", value: {x: 256, y: 256}},
            time: {type: "1f", value: 0},
            mouse: {type: "2f", value: {x: 0, y: 0}},
            date: {
                type: "4fv",
                value: [s.getFullYear(), s.getMonth(), s.getDate(), 60 * s.getHours() * 60 + 60 * s.getMinutes() + s.getSeconds()]
            },
            sampleRate: {type: "1f", value: 44100},
            iChannel0: {type: "sampler2D", value: null, textureData: {repeat: !0}},
            iChannel1: {type: "sampler2D", value: null, textureData: {repeat: !0}},
            iChannel2: {type: "sampler2D", value: null, textureData: {repeat: !0}},
            iChannel3: {type: "sampler2D", value: null, textureData: {repeat: !0}}
        }, e) for (var n in e) this.uniforms[n] = e[n];
        this.fragmentSrc = i || ""
    },j.Filter.prototype = {
        init: function () {
        }, setResolution: function (t, e) {
            this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
        }, update: function (t) {
            if (void 0 !== t) {
                var e = t.x / this.game.width, i = 1 - t.y / this.game.height;
                e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds()
        }, addToWorld: function (t, e, i, s, n, r) {
            void 0 === n && (n = 0), void 0 === r && (r = 0), null != i ? this.width = i : i = this.width, null != s ? this.height = s : s = this.height;
            var o = this.game.add.image(t, e, "__default");
            return o.width = i, o.height = s, o.anchor.set(n, r), o.filters = [this], o
        }, destroy: function () {
            this.game = null
        }
    },j.Filter.prototype.constructor = j.Filter,Object.defineProperty(j.Filter.prototype, "width", {
        get: function () {
            return this.uniforms.resolution.value.x
        }, set: function (t) {
            this.uniforms.resolution.value.x = t
        }
    }),Object.defineProperty(j.Filter.prototype, "height", {
        get: function () {
            return this.uniforms.resolution.value.y
        }, set: function (t) {
            this.uniforms.resolution.value.y = t
        }
    }),j.Plugin = function (t, e) {
        void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
    },j.Plugin.prototype = {
        preUpdate: function () {
        }, update: function () {
        }, render: function () {
        }, postRender: function () {
        }, destroy: function () {
            this.game = null, this.parent = null, this.active = !1, this.visible = !1
        }
    },j.Plugin.prototype.constructor = j.Plugin,j.PluginManager = function (t) {
        this.game = t, this.plugins = [], this._len = 0, this._i = 0
    },j.PluginManager.prototype = {
        add: function (t) {
            var e = Array.prototype.slice.call(arguments, 1), i = !1;
            return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (i = t.hasPreUpdate = !0), "function" == typeof t.update && (i = t.hasUpdate = !0), "function" == typeof t.postUpdate && (i = t.hasPostUpdate = !0), "function" == typeof t.render && (i = t.hasRender = !0), "function" == typeof t.postRender && (i = t.hasPostRender = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
        }, remove: function (t, e) {
            for (void 0 === e && (e = !0), this._i = this._len; this._i--;) if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
        }, removeAll: function () {
            for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
            this.plugins.length = 0, this._len = 0
        }, preUpdate: function () {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
        }, update: function () {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
        }, postUpdate: function () {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
        }, render: function () {
            for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
        }, postRender: function () {
            for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
        }, destroy: function () {
            this.removeAll(), this.game = null
        }
    },j.PluginManager.prototype.constructor = j.PluginManager,j.Stage = function (t) {
        this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, (this.stage = this).currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            color: 0,
            rgba: "#000000"
        }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
    },j.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),j.Stage.prototype.constructor = j.Stage,j.Stage.prototype.parseConfig = function (t) {
        t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
    },j.Stage.prototype.boot = function () {
        j.DOM.getOffset(this.game.canvas, this.offset), j.Canvas.setUserSelect(this.game.canvas, "none"), j.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
    },j.Stage.prototype.preUpdate = function () {
        for (var t = this.currentRenderOrderID = 0; t < this.children.length; t++) this.children[t].preUpdate()
    },j.Stage.prototype.update = function () {
        for (var t = this.children.length; t--;) this.children[t].update()
    },j.Stage.prototype.postUpdate = function () {
        this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
        this.updateTransform()
    },j.Stage.prototype.updateTransform = function () {
        this.worldAlpha = 1;
        for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    },j.Stage.prototype.checkVisibility = function () {
        void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
        var e = this;
        this._onChange = function (t) {
            return e.visibilityChange(t)
        }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function () {
            j.Stage.prototype.visibilityChange.call(e, {type: "pause"})
        }), CocoonJS.App.onActivated.addEventListener(function () {
            j.Stage.prototype.visibilityChange.call(e, {type: "resume"})
        }))
    },j.Stage.prototype.visibilityChange = function (t) {
        "pagehide" !== t.type && "blur" !== t.type && "pageshow" !== t.type && "focus" !== t.type ? this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t)) : "pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t)
    },j.Stage.prototype.setBackgroundColor = function (t) {
        this.game.transparent || (j.Color.valueToColor(t, this._bgColor), j.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
    },j.Stage.prototype.destroy = function () {
        this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null
    },Object.defineProperty(j.Stage.prototype, "backgroundColor", {
        get: function () {
            return this._bgColor.color
        }, set: function (t) {
            this.setBackgroundColor(t)
        }
    }),Object.defineProperty(j.Stage.prototype, "smoothed", {
        get: function () {
            return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
        }, set: function (t) {
            PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
        }
    }),j.Group = function (t, e, i, s, n, r) {
        void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === r && (r = j.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = i || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), s ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = j.GROUP, this.physicsType = j.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = j.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new j.Signal, this.onChildInputUp = new j.Signal, this.onChildInputOver = new j.Signal, this.onChildInputOut = new j.Signal, this.enableBody = n, this.enableBodyDebug = !1, this.physicsBodyType = r, this.physicsSortDirection = null, this.onDestroy = new j.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new j.Point, this.hash = [], this._sortProperty = "z"
    },j.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),j.Group.prototype.constructor = j.Group,j.Group.RETURN_NONE = 0,j.Group.RETURN_TOTAL = 1,j.Group.RETURN_CHILD = 2,j.Group.RETURN_ALL = 3,j.Group.SORT_ASCENDING = -1,j.Group.SORT_DESCENDING = 1,j.Group.prototype.add = function (t, e, i) {
        return void 0 === e && (e = !1), t.parent === this || (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t)), t
    },j.Group.prototype.addAt = function (t, e, i) {
        this.add(t, i, e)
    },j.Group.prototype.addToHash = function (t) {
        if (t.parent === this && -1 === this.hash.indexOf(t)) return this.hash.push(t), !0;
        return !1
    },j.Group.prototype.removeFromHash = function (t) {
        if (t) {
            var e = this.hash.indexOf(t);
            if (-1 !== e) return this.hash.splice(e, 1), !0
        }
        return !1
    },j.Group.prototype.addMultiple = function (t, e) {
        if (t instanceof j.Group) t.moveAll(this, e); else if (Array.isArray(t)) for (var i = 0; i < t.length; i++) this.add(t[i], e);
        return t
    },j.Group.prototype.getAt = function (t) {
        return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
    },j.Group.prototype.create = function (t, e, i, s, n, r) {
        void 0 === n && (n = !0);
        var o = new this.classType(this.game, t, e, i, s);
        return o.exists = n, o.visible = n, o.alive = n, this.add(o, !1, r)
    },j.Group.prototype.createMultiple = function (s, t, e, n) {
        void 0 === e && (e = 0), void 0 === n && (n = !1), Array.isArray(t) || (t = [t]), Array.isArray(e) || (e = [e]);
        var r = this, o = [];
        return t.forEach(function (i) {
            e.forEach(function (t) {
                for (var e = 0; e < s; e++) o.push(r.create(0, 0, i, t, n))
            })
        }), o
    },j.Group.prototype.updateZ = function () {
        for (var t = this.children.length; t--;) this.children[t].z = t
    },j.Group.prototype.align = function (t, e, i, s, n, r) {
        if (void 0 === n && (n = j.TOP_LEFT), void 0 === r && (r = 0), 0 === this.children.length || r > this.children.length || -1 === t && -1 === e) return !1;
        for (var o = new j.Rectangle(0, 0, i, s), a = t * i, h = e * s, l = r; l < this.children.length; l++) {
            var c = this.children[l];
            if (c.alignIn) if (c.alignIn(o, n), -1 === t) o.y += s, o.y === h && (o.x += i, o.y = 0); else if (-1 === e) o.x += i, o.x === a && (o.x = 0, o.y += s); else if (o.x += i, o.x === a && (o.x = 0, o.y += s, o.y === h)) return !0
        }
        return !0
    },j.Group.prototype.resetCursor = function (t) {
        if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
    },j.Group.prototype.next = function () {
        if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
    },j.Group.prototype.previous = function () {
        if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
    },j.Group.prototype.swap = function (t, e) {
        this.swapChildren(t, e), this.updateZ()
    },j.Group.prototype.bringToTop = function (t) {
        return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
    },j.Group.prototype.sendToBack = function (t) {
        return t.parent === this && 0 < this.getIndex(t) && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
    },j.Group.prototype.moveUp = function (t) {
        if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
            var e = this.getIndex(t), i = this.getAt(e + 1);
            i && this.swap(t, i)
        }
        return t
    },j.Group.prototype.moveDown = function (t) {
        if (t.parent === this && 0 < this.getIndex(t)) {
            var e = this.getIndex(t), i = this.getAt(e - 1);
            i && this.swap(t, i)
        }
        return t
    },j.Group.prototype.xy = function (t, e, i) {
        if (t < 0 || t > this.children.length) return -1;
        this.getChildAt(t).x = e, this.getChildAt(t).y = i
    },j.Group.prototype.reverse = function () {
        this.children.reverse(), this.updateZ()
    },j.Group.prototype.getIndex = function (t) {
        return this.children.indexOf(t)
    },j.Group.prototype.getByName = function (t) {
        for (var e = 0; e < this.children.length; e++) if (this.children[e].name === t) return this.children[e];
        return null
    },j.Group.prototype.replace = function (t, e) {
        var i = this.getIndex(t);
        if (-1 !== i) return e.parent && (e.parent instanceof j.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, i), t
    },j.Group.prototype.hasProperty = function (t, e) {
        var i = e.length;
        return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
    },j.Group.prototype.setProperty = function (t, e, i, s, n) {
        if (void 0 === n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || 0 < s)) return !1;
        var r = e.length;
        return 1 === r ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === r ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
    },j.Group.prototype.checkProperty = function (t, e, i, s) {
        return void 0 === s && (s = !1), !(!j.Utils.getProperty(t, e) && s) && j.Utils.getProperty(t, e) === i
    },j.Group.prototype.set = function (t, e, i, s, n, r, o) {
        if (void 0 === o && (o = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === n && (n = !1), (!1 === s || s && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, r, o)
    },j.Group.prototype.setAll = function (t, e, i, s, n, r) {
        void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === r && (r = !1), t = t.split("."), n = n || 0;
        for (var o = 0; o < this.children.length; o++) (!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && this.setProperty(this.children[o], t, e, n, r)
    },j.Group.prototype.setAllChildren = function (t, e, i, s, n, r) {
        void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === r && (r = !1), n = n || 0;
        for (var o = 0; o < this.children.length; o++) (!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && (this.children[o] instanceof j.Group ? this.children[o].setAllChildren(t, e, i, s, n, r) : this.setProperty(this.children[o], t.split("."), e, n, r))
    },j.Group.prototype.checkAll = function (t, e, i, s, n) {
        void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1);
        for (var r = 0; r < this.children.length; r++) if ((!i || i && this.children[r].alive) && (!s || s && this.children[r].visible) && !this.checkProperty(this.children[r], t, e, n)) return !1;
        return !0
    },j.Group.prototype.addAll = function (t, e, i, s) {
        this.setAll(t, e, i, s, 1)
    },j.Group.prototype.subAll = function (t, e, i, s) {
        this.setAll(t, e, i, s, 2)
    },j.Group.prototype.multiplyAll = function (t, e, i, s) {
        this.setAll(t, e, i, s, 3)
    },j.Group.prototype.divideAll = function (t, e, i, s) {
        this.setAll(t, e, i, s, 4)
    },j.Group.prototype.callAllExists = function (t, e) {
        var i;
        if (2 < arguments.length) {
            i = [];
            for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
        }
        for (s = 0; s < this.children.length; s++) this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i)
    },j.Group.prototype.callbackFromArray = function (t, e, i) {
        if (1 === i) {
            if (t[e[0]]) return t[e[0]]
        } else if (2 === i) {
            if (t[e[0]][e[1]]) return t[e[0]][e[1]]
        } else if (3 === i) {
            if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
        } else if (4 === i) {
            if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
        } else if (t[e]) return t[e];
        return !1
    },j.Group.prototype.callAll = function (t, e) {
        if (void 0 !== t) {
            var i, s = (t = t.split(".")).length;
            if (null == e || "" === e) e = null; else if ("string" == typeof e) var n = (e = e.split(".")).length;
            if (2 < arguments.length) {
                i = [];
                for (var r = 2; r < arguments.length; r++) i.push(arguments[r])
            }
            var o = null, a = null;
            for (r = 0; r < this.children.length; r++) o = this.callbackFromArray(this.children[r], t, s), e && o ? (a = this.callbackFromArray(this.children[r], e, n), o && o.apply(a, i)) : o && o.apply(this.children[r], i)
        }
    },j.Group.prototype.preUpdate = function () {
        if (this.pendingDestroy) return this.destroy(), !1;
        if (!this.exists || !this.parent.exists) return !(this.renderOrderID = -1);
        for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
        return !0
    },j.Group.prototype.update = function () {
        for (var t = this.children.length; t--;) this.children[t].update()
    },j.Group.prototype.postUpdate = function () {
        this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
    },j.Group.prototype.filter = function (t, e) {
        for (var i = -1, s = this.children.length, n = []; ++i < s;) {
            var r = this.children[i];
            (!e || e && r.exists) && t(r, i, this.children) && n.push(r)
        }
        return new j.ArraySet(n)
    },j.Group.prototype.forEach = function (t, e, i) {
        if (void 0 === i && (i = !1), arguments.length <= 3) for (var s = 0; s < this.children.length; s++) (!i || i && this.children[s].exists) && t.call(e, this.children[s], s); else {
            var n = [null];
            for (s = 3; s < arguments.length; s++) n.push(arguments[s]);
            for (s = 0; s < this.children.length; s++) (!i || i && this.children[s].exists) && (n[0] = this.children[s], t.apply(e, n.concat([s])))
        }
    },j.Group.prototype.forEachExists = function (t, e) {
        var i;
        if (2 < arguments.length) {
            i = [null];
            for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
        }
        this.iterate("exists", !0, j.Group.RETURN_TOTAL, t, e, i)
    },j.Group.prototype.forEachAlive = function (t, e) {
        var i;
        if (2 < arguments.length) {
            i = [null];
            for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
        }
        this.iterate("alive", !0, j.Group.RETURN_TOTAL, t, e, i)
    },j.Group.prototype.forEachDead = function (t, e) {
        var i;
        if (2 < arguments.length) {
            i = [null];
            for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
        }
        this.iterate("alive", !1, j.Group.RETURN_TOTAL, t, e, i)
    },j.Group.prototype.sort = function (t, e) {
        this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = j.Group.SORT_ASCENDING), this._sortProperty = t, e === j.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
    },j.Group.prototype.customSort = function (t, e) {
        this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
    },j.Group.prototype.ascendingSortHandler = function (t, e) {
        return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
    },j.Group.prototype.descendingSortHandler = function (t, e) {
        return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
    },j.Group.prototype.iterate = function (t, e, i, s, n, r) {
        if (0 === this.children.length) {
            if (i === j.Group.RETURN_TOTAL) return 0;
            if (i === j.Group.RETURN_ALL) return []
        }
        var o = 0;
        if (i === j.Group.RETURN_ALL) var a = [];
        for (var h = 0; h < this.children.length; h++) if (this.children[h][t] === e) {
            if (o++, s && (r ? (r[0] = this.children[h], s.apply(n, r)) : s.call(n, this.children[h])), i === j.Group.RETURN_CHILD) return this.children[h];
            i === j.Group.RETURN_ALL && a.push(this.children[h])
        }
        return i === j.Group.RETURN_TOTAL ? o : i === j.Group.RETURN_ALL ? a : null
    },j.Group.prototype.getFirstExists = function (t, e, i, s, n, r) {
        void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
        var o = this.iterate("exists", t, j.Group.RETURN_CHILD);
        return null === o && e ? this.create(i, s, n, r) : this.resetChild(o, i, s, n, r)
    },j.Group.prototype.getFirstAlive = function (t, e, i, s, n) {
        void 0 === t && (t = !1);
        var r = this.iterate("alive", !0, j.Group.RETURN_CHILD);
        return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
    },j.Group.prototype.getFirstDead = function (t, e, i, s, n) {
        void 0 === t && (t = !1);
        var r = this.iterate("alive", !1, j.Group.RETURN_CHILD);
        return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
    },j.Group.prototype.resetChild = function (t, e, i, s, n) {
        return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, n), t)
    },j.Group.prototype.getTop = function () {
        if (0 < this.children.length) return this.children[this.children.length - 1]
    },j.Group.prototype.getBottom = function () {
        if (0 < this.children.length) return this.children[0]
    },j.Group.prototype.getClosestTo = function (t, e, i) {
        for (var s = Number.MAX_VALUE, n = 0, r = null, o = 0; o < this.children.length; o++) {
            var a = this.children[o];
            a.exists && (n = Math.abs(j.Point.distance(t, a))) < s && (!e || e.call(i, a, n)) && (s = n, r = a)
        }
        return r
    },j.Group.prototype.getFurthestFrom = function (t, e, i) {
        for (var s = 0, n = 0, r = null, o = 0; o < this.children.length; o++) {
            var a = this.children[o];
            a.exists && s < (n = Math.abs(j.Point.distance(t, a))) && (!e || e.call(i, a, n)) && (s = n, r = a)
        }
        return r
    },j.Group.prototype.countLiving = function () {
        return this.iterate("alive", !0, j.Group.RETURN_TOTAL)
    },j.Group.prototype.countDead = function () {
        return this.iterate("alive", !1, j.Group.RETURN_TOTAL)
    },j.Group.prototype.getRandom = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : j.ArrayUtils.getRandomItem(this.children, t, e)
    },j.Group.prototype.getRandomExists = function (t, e) {
        var i = this.getAll("exists", !0, t, e);
        return this.game.rnd.pick(i)
    },j.Group.prototype.getAll = function (t, e, i, s) {
        void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
        for (var n = [], r = i; r < s; r++) {
            var o = this.children[r];
            t && o[t] === e && n.push(o)
        }
        return n
    },j.Group.prototype.remove = function (t, e, i) {
        if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
        i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
        var s = this.removeChild(t);
        return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
    },j.Group.prototype.moveAll = function (t, e) {
        if (void 0 === e && (e = !1), 0 < this.children.length && t instanceof j.Group) {
            for (; t.add(this.children[0], e), 0 < this.children.length;) ;
            this.hash = [], this.cursor = null
        }
        return t
    },j.Group.prototype.removeAll = function (t, e, i) {
        if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
            do {
                !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                var s = this.removeChild(this.children[0]);
                this.removeFromHash(s), t && s && s.destroy(!0, i)
            } while (0 < this.children.length);
            this.hash = [], this.cursor = null
        }
    },j.Group.prototype.removeBetween = function (t, e, i, s) {
        if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
            if (e < t || t < 0 || e > this.children.length) return !1;
            for (var n = e; t <= n;) {
                !s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                var r = this.removeChild(this.children[n]);
                this.removeFromHash(r), i && r && r.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n--
            }
            this.updateZ()
        }
    },j.Group.prototype.destroy = function (t, e) {
        null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
    },Object.defineProperty(j.Group.prototype, "total", {
        get: function () {
            return this.iterate("exists", !0, j.Group.RETURN_TOTAL)
        }
    }),Object.defineProperty(j.Group.prototype, "length", {
        get: function () {
            return this.children.length
        }
    }),Object.defineProperty(j.Group.prototype, "angle", {
        get: function () {
            return j.Math.radToDeg(this.rotation)
        }, set: function (t) {
            this.rotation = j.Math.degToRad(t)
        }
    }),Object.defineProperty(j.Group.prototype, "centerX", {
        get: function () {
            return this.getBounds(this.parent).centerX
        }, set: function (t) {
            var e = this.getBounds(this.parent), i = this.x - e.x;
            this.x = t + i - e.halfWidth
        }
    }),Object.defineProperty(j.Group.prototype, "centerY", {
        get: function () {
            return this.getBounds(this.parent).centerY
        }, set: function (t) {
            var e = this.getBounds(this.parent), i = this.y - e.y;
            this.y = t + i - e.halfHeight
        }
    }),Object.defineProperty(j.Group.prototype, "left", {
        get: function () {
            return this.getBounds(this.parent).left
        }, set: function (t) {
            var e = this.getBounds(this.parent), i = this.x - e.x;
            this.x = t + i
        }
    }),Object.defineProperty(j.Group.prototype, "right", {
        get: function () {
            return this.getBounds(this.parent).right
        }, set: function (t) {
            var e = this.getBounds(this.parent), i = this.x - e.x;
            this.x = t + i - e.width
        }
    }),Object.defineProperty(j.Group.prototype, "top", {
        get: function () {
            return this.getBounds(this.parent).top
        }, set: function (t) {
            var e = this.getBounds(this.parent), i = this.y - e.y;
            this.y = t + i
        }
    }),Object.defineProperty(j.Group.prototype, "bottom", {
        get: function () {
            return this.getBounds(this.parent).bottom
        }, set: function (t) {
            var e = this.getBounds(this.parent), i = this.y - e.y;
            this.y = t + i - e.height
        }
    }),j.World = function (t) {
        j.Group.call(this, t, null, "__world", !1), this.bounds = new j.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
    },j.World.prototype = Object.create(j.Group.prototype),j.World.prototype.constructor = j.World,j.World.prototype.boot = function () {
        this.camera = new j.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
    },j.World.prototype.stateChange = function () {
        this.x = 0, this.y = 0, this.camera.reset()
    },j.World.prototype.setBounds = function (t, e, i, s) {
        this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld()
    },j.World.prototype.resize = function (t, e) {
        this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
    },j.World.prototype.shutdown = function () {
        this.destroy(!0, !0)
    },j.World.prototype.wrap = function (t, e, i, s, n) {
        void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === n && (n = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
    },Object.defineProperty(j.World.prototype, "width", {
        get: function () {
            return this.bounds.width
        }, set: function (t) {
            t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
        }
    }),Object.defineProperty(j.World.prototype, "height", {
        get: function () {
            return this.bounds.height
        }, set: function (t) {
            t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
        }
    }),Object.defineProperty(j.World.prototype, "centerX", {
        get: function () {
            return this.bounds.halfWidth + this.bounds.x
        }
    }),Object.defineProperty(j.World.prototype, "centerY", {
        get: function () {
            return this.bounds.halfHeight + this.bounds.y
        }
    }),Object.defineProperty(j.World.prototype, "randomX", {
        get: function () {
            return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
        }
    }),Object.defineProperty(j.World.prototype, "randomY", {
        get: function () {
            return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
        }
    }),j.Game = function (t, e, i, s, n, r, o, a) {
        return this.id = j.GAMES.push(this) - 1, this.config = null, this.physicsConfig = a, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = j.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = j.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new j.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof t ? this.parseConfig(t) : (this.config = {enableDebug: !0}, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== i && (this.renderType = i), void 0 !== s && (this.parent = s), void 0 !== r && (this.transparent = r), void 0 !== o && (this.antialias = o), this.rnd = new j.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new j.StateManager(this, n)), this.device.whenReady(this.boot, this), this
    },j.Game.prototype = {
        parseConfig: function (t) {
            void 0 === (this.config = t).enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
            var e = [(Date.now() * Math.random()).toString()];
            t.seed && (e = t.seed), this.rnd = new j.RandomDataGenerator(e);
            var i = null;
            t.state && (i = t.state), this.state = new j.StateManager(this, i)
        }, boot: function () {
            this.isBooted || (this.onPause = new j.Signal, this.onResume = new j.Signal, this.onBlur = new j.Signal, this.onFocus = new j.Signal, this.isBooted = !0, (PIXI.game = this).math = j.Math, this.scale = new j.ScaleManager(this, this._width, this._height), this.stage = new j.Stage(this), this.setUpRenderer(), this.world = new j.World(this), this.add = new j.GameObjectFactory(this), this.make = new j.GameObjectCreator(this), this.cache = new j.Cache(this), this.load = new j.Loader(this), this.time = new j.Time(this), this.tweens = new j.TweenManager(this), this.input = new j.Input(this), this.sound = new j.SoundManager(this), this.physics = new j.Physics(this, this.physicsConfig), this.particles = new j.Particles(this), this.create = new j.Create(this), this.plugins = new j.PluginManager(this), this.net = new j.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new j.Utils.Debug(this), this.debug.boot()) : this.debug = {
                preUpdate: function () {
                }, update: function () {
                }, reset: function () {
                }
            }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new j.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new j.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
        }, showDebugHeader: function () {
            if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                var t = j.VERSION, e = "Canvas", i = "HTML Audio", s = 1;
                if (this.renderType === j.WEBGL ? (e = "WebGL", s++) : this.renderType === j.HEADLESS && (e = "Headless"), this.device.webAudio && (i = "WebAudio", s++), this.device.chrome) {
                    for (var n = ["%c %c %c Phaser v" + t + " | Pixi.js | " + e + " | " + i + "  %c %c %c http://phaser.io %c%c%c", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], r = 0; r < 3; r++) r < s ? n.push("color: #ff2424; background: #fff") : n.push("color: #959595; background: #fff");
                    console.log.apply(console, n)
                } else window.console && console.log("Phaser v" + t + " | Pixi.js " + PIXI.VERSION + " | " + e + " | " + i + " | http://phaser.io")
            }
        }, setUpRenderer: function () {
            if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = j.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === j.HEADLESS || this.renderType === j.CANVAS || this.renderType === j.AUTO && !this.device.webGL) {
                if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                this.renderType = j.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
            } else this.renderType = j.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
            this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === j.CANVAS), this.renderType !== j.HEADLESS && (this.stage.smoothed = this.antialias, j.Canvas.addToDOM(this.canvas, this.parent, !1), j.Canvas.setTouchAction(this.canvas))
        }, contextLost: function (t) {
            t.preventDefault(), this.renderer.contextLost = !0
        }, contextRestored: function () {
            this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
        }, update: function (t) {
            if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void (this._kickstart = !1);
            if (1 < this._spiraling && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps); else {
                var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                var i = 0;
                for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
            }
        }, updateLogic: function (t) {
            this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
        }, updateRender: function (t) {
            this.lockRender || (this.state.preRender(t), this.renderType !== j.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
        }, enableStep: function () {
            this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
        }, disableStep: function () {
            this.stepping = !1, this.pendingStep = !1
        }, step: function () {
            this.pendingStep = !1, this.stepCount++
        }, destroy: function () {
            this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), j.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, j.GAMES[this.id] = null
        }, gamePaused: function (t) {
            this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
        }, gameResumed: function (t) {
            this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
        }, focusLoss: function (t) {
            this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
        }, focusGain: function (t) {
            this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
        }
    },j.Game.prototype.constructor = j.Game,Object.defineProperty(j.Game.prototype, "paused", {
        get: function () {
            return this._paused
        }, set: function (t) {
            this._codePaused = !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), !1)
        }
    }),j.Input = function (t) {
        this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = j.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new j.ArraySet, this._localPoint = new j.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
    },j.Input.MOUSE_OVERRIDES_TOUCH = 0,j.Input.TOUCH_OVERRIDES_MOUSE = 1,j.Input.MOUSE_TOUCH_COMBINE = 2,j.Input.MAX_POINTERS = 10,j.Input.prototype = {
        boot: function () {
            this.mousePointer = new j.Pointer(this.game, 0, j.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new j.Mouse(this.game), this.touch = new j.Touch(this.game), this.mspointer = new j.MSPointer(this.game), j.Keyboard && (this.keyboard = new j.Keyboard(this.game)), j.Gamepad && (this.gamepad = new j.Gamepad(this.game)), this.onDown = new j.Signal, this.onUp = new j.Signal, this.onTap = new j.Signal, this.onHold = new j.Signal, this.scale = new j.Point(1, 1), this.speed = new j.Point, this.position = new j.Point, this._oldPosition = new j.Point, this.circle = new j.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
            var e = this;
            this._onClickTrampoline = function (t) {
                e.onClickTrampoline(t)
            }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
        }, destroy: function () {
            this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
        }, setInteractiveCandidateHandler: function (t, e) {
            this.customCandidateHandler = t, this.customCandidateHandlerContext = e
        }, addMoveCallback: function (t, e) {
            this.moveCallbacks.push({callback: t, context: e})
        }, deleteMoveCallback: function (t, e) {
            for (var i = this.moveCallbacks.length; i--;) if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
        }, addPointer: function () {
            if (this.pointers.length >= j.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + j.Input.MAX_POINTERS + " pointers reached."), null;
            var t = this.pointers.length + 1, e = new j.Pointer(this.game, t, j.PointerMode.TOUCH);
            return this.pointers.push(e), this["pointer" + t] = e
        }, update: function () {
            if (this.keyboard && this.keyboard.update(), 0 < this.pollRate && this._pollCounter < this.pollRate) this._pollCounter++; else {
                this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                this._pollCounter = 0
            }
        }, reset: function (t) {
            if (this.game.isBooted && !this.resetLocked) {
                void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset();
                for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new j.Signal, this.onUp = new j.Signal, this.onTap = new j.Signal, this.onHold = new j.Signal, this.moveCallbacks = []), this._pollCounter = 0
            }
        }, resetSpeed: function (t, e) {
            this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
        }, startPointer: function (t) {
            if (0 <= this.maxPointers && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
            if (!this.pointer1.active) return this.pointer1.start(t);
            if (!this.pointer2.active) return this.pointer2.start(t);
            for (var e = 2; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (!i.active) return i.start(t)
            }
            return null
        }, updatePointer: function (t) {
            if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
            if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
            for (var e = 2; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.active && i.identifier === t.identifier) return i.move(t)
            }
            return null
        }, stopPointer: function (t) {
            if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
            if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
            for (var e = 2; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.active && i.identifier === t.identifier) return i.stop(t)
            }
            return null
        }, countActivePointers: function (t) {
            void 0 === t && (t = this.pointers.length);
            for (var e = t, i = 0; i < this.pointers.length && 0 < e; i++) {
                this.pointers[i].active && e--
            }
            return t - e
        }, getPointer: function (t) {
            void 0 === t && (t = !1);
            for (var e = 0; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.active === t) return i
            }
            return null
        }, getPointerFromIdentifier: function (t) {
            for (var e = 0; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.identifier === t) return i
            }
            return null
        }, getPointerFromId: function (t) {
            for (var e = 0; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.pointerId === t) return i
            }
            return null
        }, getLocalPosition: function (t, e, i) {
            void 0 === i && (i = new j.Point);
            var s = t.worldTransform, n = 1 / (s.a * s.d + s.c * -s.b);
            return i.setTo(s.d * n * e.x + -s.c * n * e.y + (s.ty * s.c - s.tx * s.d) * n, s.a * n * e.y + -s.b * n * e.x + (-s.ty * s.a + s.tx * s.b) * n)
        }, hitTest: function (t, e, i) {
            if (!t.worldVisible) return !1;
            if (this.getLocalPosition(t, e, this._localPoint), i.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
            if (t instanceof j.TileSprite) {
                var s = t.width, n = t.height, r = -s * t.anchor.x;
                if (this._localPoint.x >= r && this._localPoint.x < r + s) {
                    var o = -n * t.anchor.y;
                    if (this._localPoint.y >= o && this._localPoint.y < o + n) return !0
                }
            } else if (t instanceof PIXI.Sprite) {
                s = t.texture.frame.width, n = t.texture.frame.height, r = -s * t.anchor.x;
                if (this._localPoint.x >= r && this._localPoint.x < r + s) {
                    o = -n * t.anchor.y;
                    if (this._localPoint.y >= o && this._localPoint.y < o + n) return !0
                }
            } else if (t instanceof j.Graphics) for (var a = 0; a < t.graphicsData.length; a++) {
                var h = t.graphicsData[a];
                if (h.fill && (h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y))) return !0
            }
            for (a = 0; a < t.children.length; a++) if (this.hitTest(t.children[a], e, i)) return !0;
            return !1
        }, onClickTrampoline: function () {
            this.activePointer.processClickTrampolines()
        }
    },j.Input.prototype.constructor = j.Input,Object.defineProperty(j.Input.prototype, "x", {
        get: function () {
            return this._x
        }, set: function (t) {
            this._x = Math.floor(t)
        }
    }),Object.defineProperty(j.Input.prototype, "y", {
        get: function () {
            return this._y
        }, set: function (t) {
            this._y = Math.floor(t)
        }
    }),Object.defineProperty(j.Input.prototype, "pollLocked", {
        get: function () {
            return 0 < this.pollRate && this._pollCounter < this.pollRate
        }
    }),Object.defineProperty(j.Input.prototype, "totalInactivePointers", {
        get: function () {
            return this.pointers.length - this.countActivePointers()
        }
    }),Object.defineProperty(j.Input.prototype, "totalActivePointers", {
        get: function () {
            return this.countActivePointers()
        }
    }),Object.defineProperty(j.Input.prototype, "worldX", {
        get: function () {
            return this.game.camera.view.x + this.x
        }
    }),Object.defineProperty(j.Input.prototype, "worldY", {
        get: function () {
            return this.game.camera.view.y + this.y
        }
    }),j.Mouse = function (t) {
        this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new j.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
    },j.Mouse.NO_BUTTON = -1,j.Mouse.LEFT_BUTTON = 0,j.Mouse.MIDDLE_BUTTON = 1,j.Mouse.RIGHT_BUTTON = 2,j.Mouse.BACK_BUTTON = 3,j.Mouse.FORWARD_BUTTON = 4,j.Mouse.WHEEL_UP = 1,j.Mouse.WHEEL_DOWN = -1,j.Mouse.prototype = {
        start: function () {
            if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                var e = this;
                this._onMouseDown = function (t) {
                    return e.onMouseDown(t)
                }, this._onMouseMove = function (t) {
                    return e.onMouseMove(t)
                }, this._onMouseUp = function (t) {
                    return e.onMouseUp(t)
                }, this._onMouseUpGlobal = function (t) {
                    return e.onMouseUpGlobal(t)
                }, this._onMouseOutGlobal = function (t) {
                    return e.onMouseOutGlobal(t)
                }, this._onMouseOut = function (t) {
                    return e.onMouseOut(t)
                }, this._onMouseOver = function (t) {
                    return e.onMouseOver(t)
                }, this._onMouseWheel = function (t) {
                    return e.onMouseWheel(t)
                };
                var t = this.game.canvas;
                t.addEventListener("mousedown", this._onMouseDown, !0), t.addEventListener("mousemove", this._onMouseMove, !0), t.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), t.addEventListener("mouseover", this._onMouseOver, !0), t.addEventListener("mouseout", this._onMouseOut, !0));
                var i = this.game.device.wheelEvent;
                i && (t.addEventListener(i, this._onMouseWheel, !0), "mousewheel" === i ? this._wheelEvent = new s(-.025, 1) : "DOMMouseScroll" === i && (this._wheelEvent = new s(1, 1)))
            }
        }, onMouseDown: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
        }, onMouseMove: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
        }, onMouseUp: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
        }, onMouseUpGlobal: function (t) {
            this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
        }, onMouseOutGlobal: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t))
        }, onMouseOut: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t))
        }, onMouseOver: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
        }, onMouseWheel: function (t) {
            this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = j.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
        }, requestPointerLock: function () {
            if (this.game.device.pointerLock) {
                var t = this.game.canvas;
                t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                var e = this;
                this._pointerLockChange = function (t) {
                    return e.pointerLockChange(t)
                }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }
        }, pointerLockChange: function (t) {
            var e = this.game.canvas;
            document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
        }, releasePointerLock: function () {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
        }, stop: function () {
            var t = this.game.canvas;
            t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
            var e = this.game.device.wheelEvent;
            e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
        }
    },j.Mouse.prototype.constructor = j.Mouse,((s.prototype = {}).constructor = s).prototype.bindEvent = function (t) {
        if (!s._stubsGenerated && t) {
            var e = function (e) {
                return function () {
                    var t = this.originalEvent[e];
                    return "function" != typeof t ? t : t.bind(this.originalEvent)
                }
            };
            for (var i in t) i in s.prototype || Object.defineProperty(s.prototype, i, {get: e(i)});
            s._stubsGenerated = !0
        }
        return this.originalEvent = t, this
    },Object.defineProperties(s.prototype, {
        type: {value: "wheel"}, deltaMode: {
            get: function () {
                return this._deltaMode
            }
        }, deltaY: {
            get: function () {
                return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
            }
        }, deltaX: {
            get: function () {
                return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
            }
        }, deltaZ: {value: 0}
    }),j.MSPointer = function (t) {
        this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
    },j.MSPointer.prototype = {
        start: function () {
            if (null === this._onMSPointerDown) {
                var e = this;
                if (this.game.device.mspointer) {
                    this._onMSPointerDown = function (t) {
                        return e.onPointerDown(t)
                    }, this._onMSPointerMove = function (t) {
                        return e.onPointerMove(t)
                    }, this._onMSPointerUp = function (t) {
                        return e.onPointerUp(t)
                    }, this._onMSPointerUpGlobal = function (t) {
                        return e.onPointerUpGlobal(t)
                    }, this._onMSPointerOut = function (t) {
                        return e.onPointerOut(t)
                    }, this._onMSPointerOver = function (t) {
                        return e.onPointerOver(t)
                    };
                    var t = this.game.canvas;
                    t.addEventListener("MSPointerDown", this._onMSPointerDown, !1), t.addEventListener("MSPointerMove", this._onMSPointerMove, !1), t.addEventListener("MSPointerUp", this._onMSPointerUp, !1), t.addEventListener("pointerdown", this._onMSPointerDown, !1), t.addEventListener("pointermove", this._onMSPointerMove, !1), t.addEventListener("pointerup", this._onMSPointerUp, !1), t.style["-ms-content-zooming"] = "none", t.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.addEventListener("MSPointerOver", this._onMSPointerOver, !0), t.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.addEventListener("pointerover", this._onMSPointerOver, !0), t.addEventListener("pointerout", this._onMSPointerOut, !0))
                }
            }
        }, onPointerDown: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
        }, onPointerMove: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
        }, onPointerUp: function (t) {
            this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
        }, onPointerUpGlobal: function (t) {
            if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                var e = this.input.getPointerFromIdentifier(t.identifier);
                e && e.withinGame && this.onPointerUp(t)
            } else this.onPointerUp(t)
        }, onPointerOut: function (t) {
            if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1; else {
                var e = this.input.getPointerFromIdentifier(t.identifier);
                e && (e.withinGame = !1)
            }
            this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
        }, onPointerOver: function (t) {
            if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0; else {
                var e = this.input.getPointerFromIdentifier(t.identifier);
                e && (e.withinGame = !0)
            }
            this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
        }, stop: function () {
            var t = this.game.canvas;
            t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
        }
    },j.MSPointer.prototype.constructor = j.MSPointer,j.DeviceButton = function (t, e) {
        this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new j.Signal, this.onUp = new j.Signal, this.onFloat = new j.Signal
    },j.DeviceButton.prototype = {
        start: function (t, e) {
            this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
        }, stop: function (t, e) {
            this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
        }, padFloat: function (t) {
            this.value = t, this.onFloat.dispatch(this, t)
        }, justPressed: function (t) {
            return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
        }, justReleased: function (t) {
            return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
        }, reset: function () {
            this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
        }, destroy: function () {
            this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
        }
    },j.DeviceButton.prototype.constructor = j.DeviceButton,Object.defineProperty(j.DeviceButton.prototype, "duration", {
        get: function () {
            return this.isUp ? -1 : this.game.time.time - this.timeDown
        }
    }),j.Pointer = function (t, e, i) {
        this.game = t, this.id = e, this.type = j.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = i || j.PointerMode.CURSOR | j.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new j.DeviceButton(this, j.Pointer.LEFT_BUTTON), this.middleButton = new j.DeviceButton(this, j.Pointer.MIDDLE_BUTTON), this.rightButton = new j.DeviceButton(this, j.Pointer.RIGHT_BUTTON), this.backButton = new j.DeviceButton(this, j.Pointer.BACK_BUTTON), this.forwardButton = new j.DeviceButton(this, j.Pointer.FORWARD_BUTTON), this.eraserButton = new j.DeviceButton(this, j.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new j.Point, this.positionDown = new j.Point, this.positionUp = new j.Point, this.circle = new j.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
    },j.Pointer.NO_BUTTON = 0,j.Pointer.LEFT_BUTTON = 1,j.Pointer.RIGHT_BUTTON = 2,j.Pointer.MIDDLE_BUTTON = 4,j.Pointer.BACK_BUTTON = 8,j.Pointer.FORWARD_BUTTON = 16,j.Pointer.ERASER_BUTTON = 32,j.Pointer.prototype = {
        resetButtons: function () {
            this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
        }, processButtonsDown: function (t, e) {
            j.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), j.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), j.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), j.Pointer.BACK_BUTTON & t && this.backButton.start(e), j.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), j.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
        }, processButtonsUp: function (t, e) {
            t === j.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === j.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === j.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === j.Mouse.BACK_BUTTON && this.backButton.stop(e), t === j.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e)
        }, updateButtons: function (t) {
            this.button = t.button;
            var e = "down" === t.type.toLowerCase().substr(-4);
            void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
        }, start: function (t) {
            var e = this.game.input;
            return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === j.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === j.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === j.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
        }, update: function () {
            var t = this.game.input;
            this.active && (this.dirty && (0 < t.interactiveItems.total && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === j.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === j.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === j.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                x: this.position.x,
                y: this.position.y
            }), this._history.length > t.recordLimit && this._history.shift()))
        }, move: function (t, e) {
            var i = this.game.input;
            if (!i.pollLocked) {
                if (void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && i.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * i.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * i.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (i.multiInputOverride === j.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === j.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === j.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.activePointer = this, i.x = this.x, i.y = this.y, i.position.setTo(i.x, i.y), i.circle.x = i.x, i.circle.y = i.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                for (var s = i.moveCallbacks.length; s--;) i.moveCallbacks[s].callback.call(i.moveCallbacks[s].context, this, this.x, this.y, e);
                return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : 0 < i.interactiveItems.total && this.processInteractiveObjects(e), this
            }
        }, processInteractiveObjects: function (t) {
            var e = 0, i = -1, s = null, n = this.game.input.interactiveItems.first;
            for (this.interactiveCandidates = []; n;) n.checked = !1, n.validForInput(i, e, !1) && (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n))), n = this.game.input.interactiveItems.next;
            for (n = this.game.input.interactiveItems.first; n;) !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n)), n = this.game.input.interactiveItems.next;
            return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
        }, swapTarget: function (t, e) {
            void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t)._pointerOverHandler(this, e) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
        }, leave: function (t) {
            this.withinGame = !1, this.move(t, !1)
        }, stop: function (t) {
            var e = this.game.input;
            if (!this._stateReset || !this.withinGame) return this.timeUp = this.game.time.time, (e.multiInputOverride === j.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === j.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === j.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), 0 <= this.duration && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), 0 < this.id && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this;
            t.preventDefault()
        }, justPressed: function (t) {
            return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
        }, justReleased: function (t) {
            return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
        }, addClickTrampoline: function (t, e, i, s) {
            if (this.isDown) {
                for (var n = this._clickTrampolines = this._clickTrampolines || [], r = 0; r < n.length; r++) if (n[r].name === t) {
                    n.splice(r, 1);
                    break
                }
                n.push({name: t, targetObject: this.targetObject, callback: e, callbackContext: i, callbackArgs: s})
            }
        }, processClickTrampolines: function () {
            var t = this._clickTrampolines;
            if (t) {
                for (var e = 0; e < t.length; e++) {
                    var i = t[e];
                    i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                }
                this._clickTrampolines = null, this._trampolineTargetObject = null
            }
        }, reset: function () {
            !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
        }, resetMovement: function () {
            this.movementX = 0, this.movementY = 0
        }
    },j.Pointer.prototype.constructor = j.Pointer,Object.defineProperty(j.Pointer.prototype, "duration", {
        get: function () {
            return this.isUp ? -1 : this.game.time.time - this.timeDown
        }
    }),Object.defineProperty(j.Pointer.prototype, "worldX", {
        get: function () {
            return this.game.world.camera.x + this.x
        }
    }),Object.defineProperty(j.Pointer.prototype, "worldY", {
        get: function () {
            return this.game.world.camera.y + this.y
        }
    }),j.PointerMode = {CURSOR: 1, CONTACT: 2},j.Touch = function (t) {
        this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
    },j.Touch.prototype = {
        start: function () {
            if (null === this._onTouchStart) {
                var e = this;
                this.game.device.touch && (this._onTouchStart = function (t) {
                    return e.onTouchStart(t)
                }, this._onTouchMove = function (t) {
                    return e.onTouchMove(t)
                }, this._onTouchEnd = function (t) {
                    return e.onTouchEnd(t)
                }, this._onTouchEnter = function (t) {
                    return e.onTouchEnter(t)
                }, this._onTouchLeave = function (t) {
                    return e.onTouchLeave(t)
                }, this._onTouchCancel = function (t) {
                    return e.onTouchCancel(t)
                }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
            }
        }, consumeDocumentTouches: function () {
            this._documentTouchMove = function (t) {
                t.preventDefault()
            }, document.addEventListener("touchmove", this._documentTouchMove, !1)
        }, addTouchLockCallback: function (t, e, i) {
            void 0 === i && (i = !1), this.touchLockCallbacks.push({callback: t, context: e, onEnd: i})
        }, removeTouchLockCallback: function (t, e) {
            for (var i = this.touchLockCallbacks.length; i--;) if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
            return !1
        }, onTouchStart: function (t) {
            for (var e = this.touchLockCallbacks.length; e--;) {
                var i = this.touchLockCallbacks[e];
                !i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
            }
            if (this.event = t, this.game.input.enabled && this.enabled) {
                this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for (e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
            }
        }, onTouchCancel: function (t) {
            if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
            }
        }, onTouchEnter: function (t) {
            this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
        }, onTouchLeave: function (t) {
            this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
        }, onTouchMove: function (t) {
            this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
        }, onTouchEnd: function (t) {
            for (var e = this.touchLockCallbacks.length; e--;) {
                var i = this.touchLockCallbacks[e];
                i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
            }
            this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
            for (e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
        }, stop: function () {
            this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
        }
    },j.Touch.prototype.constructor = j.Touch,j.InputHandler = function (t) {
        this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new j.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new j.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new j.Point, this.snapPoint = new j.Point, this._dragPoint = new j.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new j.Point, this._pointerData = [], this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            camX: 0,
            camY: 0,
            isDown: !1,
            isUp: !1,
            isOver: !1,
            isOut: !1,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: !1
        })
    },j.InputHandler.prototype = {
        start: function (t, e) {
            if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                for (var i = 0; i < 10; i++) this._pointerData[i] = {
                    id: i,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                };
                this.snapOffset = new j.Point, this.enabled = !0, this._wasEnabled = !0
            }
            return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
        }, addedToGroup: function () {
            this._dragPhase || this._wasEnabled && !this.enabled && this.start()
        }, removedFromGroup: function () {
            this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
        }, reset: function () {
            this.enabled = !1;
            for (var t = 0; t < 10; t++) this._pointerData[t] = {
                id: t,
                x: 0,
                y: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            }
        }, stop: function () {
            !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
        }, destroy: function () {
            this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
        }, validForInput: function (t, e, i) {
            return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
        }, isPixelPerfect: function () {
            return this.pixelPerfectClick || this.pixelPerfectOver
        }, pointerX: function (t) {
            return t = t || 0, this._pointerData[t].x
        }, pointerY: function (t) {
            return t = t || 0, this._pointerData[t].y
        }, pointerDown: function (t) {
            return t = t || 0, this._pointerData[t].isDown
        }, pointerUp: function (t) {
            return t = t || 0, this._pointerData[t].isUp
        }, pointerTimeDown: function (t) {
            return t = t || 0, this._pointerData[t].timeDown
        }, pointerTimeUp: function (t) {
            return t = t || 0, this._pointerData[t].timeUp
        }, pointerOver: function (t) {
            if (!this.enabled) return !1;
            if (void 0 !== t) return this._pointerData[t].isOver;
            for (var e = 0; e < 10; e++) if (this._pointerData[e].isOver) return !0;
            return !1
        }, pointerOut: function (t) {
            if (!this.enabled) return !1;
            if (void 0 !== t) return this._pointerData[t].isOut;
            for (var e = 0; e < 10; e++) if (this._pointerData[e].isOut) return !0
        }, pointerTimeOver: function (t) {
            return t = t || 0, this._pointerData[t].timeOver
        }, pointerTimeOut: function (t) {
            return t = t || 0, this._pointerData[t].timeOut
        }, pointerDragged: function (t) {
            return t = t || 0, this._pointerData[t].isDragged
        }, checkPointerDown: function (t, e) {
            return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
        }, checkPointerOver: function (t, e) {
            return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
        }, checkPixel: function (t, e, i) {
            if (this.sprite.texture.baseTexture.source) {
                if (null === t && null === e) {
                    this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                    t = this._tempPoint.x, e = this._tempPoint.y
                }
                if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
            }
            return !1
        }, update: function (t) {
            if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = j.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
        }, _pointerOverHandler: function (t, e) {
            if (null !== this.sprite) {
                var i = this._pointerData[t.id];
                if (!1 === i.isOver || t.dirty) {
                    var s = !1 === i.isOver;
                    i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === j.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                }
            }
        }, _pointerOutHandler: function (t, e) {
            if (null !== this.sprite) {
                var i = this._pointerData[t.id];
                i.isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === j.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
            }
        }, _touchedHandler: function (t) {
            if (null !== this.sprite) {
                var e = this._pointerData[t.id];
                if (!e.isDown && e.isOver) {
                    if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                    if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === j.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                    this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, 0 < this.dragTimeThreshold ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                }
            }
        }, dragTimeElapsed: function (t) {
            this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
        }, _releasedHandler: function (t) {
            if (null !== this.sprite) {
                var e = this._pointerData[t.id];
                if (e.isDown && t.isUp) {
                    e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                    var i = this.checkPointerOver(t);
                    this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.type === j.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))), !(e.isOver = i) && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                }
            }
        }, updateDrag: function (t, e) {
            if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
            var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                s = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y;
            if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = i), this.allowVerticalDrag && (this.sprite.cameraOffset.y = s), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y)); else {
                var n = this.game.camera.x - this._pointerData[t.id].camX,
                    r = this.game.camera.y - this._pointerData[t.id].camY;
                this.allowHorizontalDrag && (this.sprite.x = i + n), this.allowVerticalDrag && (this.sprite.y = s + r), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
            }
            return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, s, this.snapPoint, e), !0
        }, justOver: function (t, e) {
            return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
        }, justOut: function (t, e) {
            return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
        }, justPressed: function (t, e) {
            return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
        }, justReleased: function (t, e) {
            return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
        }, overDuration: function (t) {
            return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
        }, downDuration: function (t) {
            return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
        }, enableDrag: function (t, e, i, s, n, r) {
            void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = 255), void 0 === n && (n = null), void 0 === r && (r = null), this._dragPoint = new j.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new j.Point, this.dragFromCenter = t, this.pixelPerfectClick = i, this.pixelPerfectAlpha = s, n && (this.boundsRect = n), r && (this.boundsSprite = r)
        }, disableDrag: function () {
            if (this._pointerData) for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
            this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
        }, startDrag: function (t) {
            var e = this.sprite.x, i = this.sprite.y;
            if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                if (this.dragFromCenter) {
                    var s = this.sprite.getBounds();
                    this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - s.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - s.centerY)
                }
                this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
            } else {
                if (this.dragFromCenter) {
                    s = this.sprite.getBounds();
                    this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - s.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - s.centerY)
                }
                this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y))
            }
            this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
        }, globalToLocalX: function (t) {
            return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
        }, globalToLocalY: function (t) {
            return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
        }, stopDrag: function (t) {
            this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
        }, setDragLock: function (t, e) {
            void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
        }, enableSnap: function (t, e, i, s, n, r) {
            void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = r, this.snapOnDrag = i, this.snapOnRelease = s
        }, disableSnap: function () {
            this.snapOnDrag = !1, this.snapOnRelease = !1
        }, checkBoundsRect: function () {
            this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
        }, checkBoundsSprite: function () {
            this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
        }
    },j.InputHandler.prototype.constructor = j.InputHandler,j.Component = function () {
    },j.Component.Angle = function () {
    },j.Component.Angle.prototype = {
        angle: {
            get: function () {
                return j.Math.wrapAngle(j.Math.radToDeg(this.rotation))
            }, set: function (t) {
                this.rotation = j.Math.degToRad(j.Math.wrapAngle(t))
            }
        }
    },j.Component.Animation = function () {
    },j.Component.Animation.prototype = {
        play: function (t, e, i, s) {
            if (this.animations) return this.animations.play(t, e, i, s)
        }
    },j.Component.AutoCull = function () {
    },j.Component.AutoCull.prototype = {
        autoCull: !1, inCamera: {
            get: function () {
                return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
            }
        }
    },j.Component.Bounds = function () {
    },j.Component.Bounds.prototype = {
        offsetX: {
            get: function () {
                return this.anchor.x * this.width
            }
        }, offsetY: {
            get: function () {
                return this.anchor.y * this.height
            }
        }, centerX: {
            get: function () {
                return this.x - this.offsetX + .5 * this.width
            }, set: function (t) {
                this.x = t + this.offsetX - .5 * this.width
            }
        }, centerY: {
            get: function () {
                return this.y - this.offsetY + .5 * this.height
            }, set: function (t) {
                this.y = t + this.offsetY - .5 * this.height
            }
        }, left: {
            get: function () {
                return this.x - this.offsetX
            }, set: function (t) {
                this.x = t + this.offsetX
            }
        }, right: {
            get: function () {
                return this.x + this.width - this.offsetX
            }, set: function (t) {
                this.x = t - this.width + this.offsetX
            }
        }, top: {
            get: function () {
                return this.y - this.offsetY
            }, set: function (t) {
                this.y = t + this.offsetY
            }
        }, bottom: {
            get: function () {
                return this.y + this.height - this.offsetY
            }, set: function (t) {
                this.y = t - this.height + this.offsetY
            }
        }, alignIn: function (t, e, i, s) {
            switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                default:
                case j.TOP_LEFT:
                    this.left = t.left - i, this.top = t.top - s;
                    break;
                case j.TOP_CENTER:
                    this.centerX = t.centerX + i, this.top = t.top - s;
                    break;
                case j.TOP_RIGHT:
                    this.right = t.right + i, this.top = t.top - s;
                    break;
                case j.LEFT_CENTER:
                    this.left = t.left - i, this.centerY = t.centerY + s;
                    break;
                case j.CENTER:
                    this.centerX = t.centerX + i, this.centerY = t.centerY + s;
                    break;
                case j.RIGHT_CENTER:
                    this.right = t.right + i, this.centerY = t.centerY + s;
                    break;
                case j.BOTTOM_LEFT:
                    this.left = t.left - i, this.bottom = t.bottom + s;
                    break;
                case j.BOTTOM_CENTER:
                    this.centerX = t.centerX + i, this.bottom = t.bottom + s;
                    break;
                case j.BOTTOM_RIGHT:
                    this.right = t.right + i, this.bottom = t.bottom + s
            }
            return this
        }, alignTo: function (t, e, i, s) {
            switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                default:
                case j.TOP_LEFT:
                    this.left = t.left - i, this.bottom = t.top - s;
                    break;
                case j.TOP_CENTER:
                    this.centerX = t.centerX + i, this.bottom = t.top - s;
                    break;
                case j.TOP_RIGHT:
                    this.right = t.right + i, this.bottom = t.top - s;
                    break;
                case j.LEFT_TOP:
                    this.right = t.left - i, this.top = t.top - s;
                    break;
                case j.LEFT_CENTER:
                    this.right = t.left - i, this.centerY = t.centerY + s;
                    break;
                case j.LEFT_BOTTOM:
                    this.right = t.left - i, this.bottom = t.bottom + s;
                    break;
                case j.RIGHT_TOP:
                    this.left = t.right + i, this.top = t.top - s;
                    break;
                case j.RIGHT_CENTER:
                    this.left = t.right + i, this.centerY = t.centerY + s;
                    break;
                case j.RIGHT_BOTTOM:
                    this.left = t.right + i, this.bottom = t.bottom + s;
                    break;
                case j.BOTTOM_LEFT:
                    this.left = t.left - i, this.top = t.bottom + s;
                    break;
                case j.BOTTOM_CENTER:
                    this.centerX = t.centerX + i, this.top = t.bottom + s;
                    break;
                case j.BOTTOM_RIGHT:
                    this.right = t.right + i, this.top = t.bottom + s
            }
            return this
        }
    },j.Group.prototype.alignIn = j.Component.Bounds.prototype.alignIn,j.Group.prototype.alignTo = j.Component.Bounds.prototype.alignTo,j.Component.BringToTop = function () {
    },j.Component.BringToTop.prototype.bringToTop = function () {
        return this.parent && this.parent.bringToTop(this), this
    },j.Component.BringToTop.prototype.sendToBack = function () {
        return this.parent && this.parent.sendToBack(this), this
    },j.Component.BringToTop.prototype.moveUp = function () {
        return this.parent && this.parent.moveUp(this), this
    },j.Component.BringToTop.prototype.moveDown = function () {
        return this.parent && this.parent.moveDown(this), this
    },j.Component.Core = function () {
    },j.Component.Core.install = function (t) {
        j.Utils.mixinPrototype(this, j.Component.Core.prototype), this.components = {};
        for (var e = 0; e < t.length; e++) {
            var i = t[e], s = !1;
            "Destroy" === i && (s = !0), j.Utils.mixinPrototype(this, j.Component[i].prototype, s), this.components[i] = !0
        }
    },j.Component.Core.init = function (t, e, i, s, n) {
        this.game = t, this.key = s, this.data = {}, this.position.set(e, i), this.world = new j.Point(e, i), this.previousPosition = new j.Point(e, i), this.events = new j.Events(this), this._bounds = new j.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new j.AnimationManager(this)), this.components.LoadTexture && null !== s && this.loadTexture(s, n), this.components.FixedToCamera && (this.cameraOffset = new j.Point(e, i))
    },j.Component.Core.preUpdate = function () {
        if (!this.pendingDestroy) {
            if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return !(this.renderOrderID = -1);
            this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
            for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
            return !0
        }
        this.destroy()
    },j.Component.Core.prototype = {
        game: null,
        name: "",
        data: {},
        components: {},
        z: 0,
        events: void 0,
        animations: void 0,
        key: "",
        world: null,
        debug: !1,
        previousPosition: null,
        previousRotation: 0,
        renderOrderID: 0,
        fresh: !0,
        pendingDestroy: !1,
        _bounds: null,
        _exists: !0,
        exists: {
            get: function () {
                return this._exists
            }, set: function (t) {
                this.visible = t ? (this._exists = !0, this.body && this.body.type === j.Physics.P2JS && this.body.addToWorld(), !0) : (this._exists = !1, this.body && this.body.type === j.Physics.P2JS && this.body.removeFromWorld(), !1)
            }
        },
        update: function () {
        },
        postUpdate: function () {
            this.customRender && this.key.render(), this.components.PhysicsBody && j.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && j.Component.FixedToCamera.postUpdate.call(this);
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }
    },j.Component.Crop = function () {
    },j.Component.Crop.prototype = {
        cropRect: null, _crop: null, crop: function (t, e) {
            void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new j.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
        }, updateCrop: function () {
            if (this.cropRect) {
                var t = this.texture.crop.x, e = this.texture.crop.y, i = this.texture.crop.width,
                    s = this.texture.crop.height;
                this._crop = j.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                var n = Math.max(this._frame.x, this._crop.x), r = Math.max(this._frame.y, this._crop.y),
                    o = Math.min(this._frame.right, this._crop.right) - n,
                    a = Math.min(this._frame.bottom, this._crop.bottom) - r;
                this.texture.crop.x = n, this.texture.crop.y = r, this.texture.crop.width = o, this.texture.crop.height = a, this.texture.frame.width = Math.min(o, this.cropRect.width), this.texture.frame.height = Math.min(a, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === n && e === r && i === o && s === a || (this.texture.requiresReTint = !0)
            }
        }
    },j.Component.Delta = function () {
    },j.Component.Delta.prototype = {
        deltaX: {
            get: function () {
                return this.world.x - this.previousPosition.x
            }
        }, deltaY: {
            get: function () {
                return this.world.y - this.previousPosition.y
            }
        }, deltaZ: {
            get: function () {
                return this.rotation - this.previousRotation
            }
        }
    },j.Component.Destroy = function () {
    },j.Component.Destroy.prototype = {
        destroyPhase: !1, destroy: function (t, e) {
            if (null !== this.game && !this.destroyPhase) {
                void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof j.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                var i = this.children.length;
                if (t) for (; i--;) this.children[i].destroy(t); else for (; i--;) this.removeChild(this.children[i]);
                this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), j.Video && this.key instanceof j.Video && this.key.onChangeSource.remove(this.resizeFrame, this), j.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
            }
        }
    },j.Events = function (t) {
        this.parent = t
    },j.Events.prototype = {
        destroy: function () {
            this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
        },
        onAddedToGroup: null,
        onRemovedFromGroup: null,
        onRemovedFromWorld: null,
        onDestroy: null,
        onKilled: null,
        onRevived: null,
        onOutOfBounds: null,
        onEnterBounds: null,
        onInputOver: null,
        onInputOut: null,
        onInputDown: null,
        onInputUp: null,
        onDragStart: null,
        onDragUpdate: null,
        onDragStop: null,
        onAnimationStart: null,
        onAnimationComplete: null,
        onAnimationLoop: null
    },j.Events.prototype.constructor = j.Events,j.Events.prototype) j.Events.prototype.hasOwnProperty(i) && 0 === i.indexOf("on") && null === j.Events.prototype[i] && function (t, e) {
        "use strict";
        Object.defineProperty(j.Events.prototype, t, {
            get: function () {
                return this[e] || (this[e] = new j.Signal)
            }
        }), j.Events.prototype[t + "$dispatch"] = function () {
            return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
        }
    }(i, "_" + i);
    j.Component.FixedToCamera = function () {
    }, j.Component.FixedToCamera.postUpdate = function () {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
    }, j.Component.FixedToCamera.prototype = {
        _fixedToCamera: !1, fixedToCamera: {
            get: function () {
                return this._fixedToCamera
            }, set: function (t) {
                t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
            }
        }, cameraOffset: new j.Point
    }, j.Component.Health = function () {
    }, j.Component.Health.prototype = {
        health: 1, maxHealth: 100, damage: function (t) {
            return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
        }, setHealth: function (t) {
            return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
        }, heal: function (t) {
            return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
        }
    }, j.Component.InCamera = function () {
    }, j.Component.InCamera.prototype = {
        inCamera: {
            get: function () {
                return this.game.world.camera.view.intersects(this._bounds)
            }
        }
    }, j.Component.InputEnabled = function () {
    }, j.Component.InputEnabled.prototype = {
        input: null, inputEnabled: {
            get: function () {
                return this.input && this.input.enabled
            }, set: function (t) {
                t ? null === this.input ? (this.input = new j.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
            }
        }
    }, j.Component.InWorld = function () {
    }, j.Component.InWorld.preUpdate = function () {
        if (this.autoCull || this.checkWorldBounds) {
            if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull) if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++; else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
            if (this.checkWorldBounds) if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this); else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
        }
        return !0
    }, j.Component.InWorld.prototype = {
        checkWorldBounds: !1,
        outOfBoundsKill: !1,
        outOfCameraBoundsKill: !1,
        _outOfBoundsFired: !1,
        inWorld: {
            get: function () {
                return this.game.world.bounds.intersects(this.getBounds())
            }
        }
    }, j.Component.LifeSpan = function () {
    }, j.Component.LifeSpan.preUpdate = function () {
        return !(0 < this.lifespan && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1)
    }, j.Component.LifeSpan.prototype = {
        alive: !0, lifespan: 0, revive: function (t) {
            return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
        }, kill: function () {
            return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
        }
    }, j.Component.LoadTexture = function () {
    }, j.Component.LoadTexture.prototype = {
        customRender: !1, _frame: null, loadTexture: function (t, e, i) {
            e = t === j.PENDING_ATLAS ? (t = e, 0) : e || 0, (i || void 0 === i) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
            var s = this.game.cache, n = !0, r = !this.texture.baseTexture.scaleMode;
            if (j.RenderTexture && t instanceof j.RenderTexture) this.key = t.key, this.setTexture(t); else if (j.BitmapData && t instanceof j.BitmapData) this.customRender = !0, this.setTexture(t.texture), n = s.hasFrameData(t.key, j.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, j.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0); else if (j.Video && t instanceof j.Video) {
                this.customRender = !0;
                var o = t.texture.valid;
                this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = o
            } else if (j.Tilemap && t instanceof j.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas)); else if (t instanceof PIXI.Texture) this.setTexture(t); else {
                var a = s.getImage(t, !0);
                this.key = a.key, this.setTexture(new PIXI.Texture(a.base)), this.texture.baseTexture.skipRender = "__default" === t, n = !this.animations.loadFrameData(a.frameData, e)
            }
            n && (this._frame = j.Rectangle.clone(this.texture.frame)), r || (this.texture.baseTexture.scaleMode = 1)
        }, setFrame: function (t) {
            this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                x: t.spriteSourceSizeX,
                y: t.spriteSourceSizeY,
                width: t.sourceSizeW,
                height: t.sourceSizeH
            }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
        }, resizeFrame: function (t, e, i) {
            this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
        }, resetFrame: function () {
            this._frame && this.setFrame(this._frame)
        }, frame: {
            get: function () {
                return this.animations.frame
            }, set: function (t) {
                this.animations.frame = t
            }
        }, frameName: {
            get: function () {
                return this.animations.frameName
            }, set: function (t) {
                this.animations.frameName = t
            }
        }
    }, j.Component.Overlap = function () {
    }, j.Component.Overlap.prototype = {
        overlap: function (t) {
            return j.Rectangle.intersects(this.getBounds(), t.getBounds())
        }
    }, j.Component.PhysicsBody = function () {
    }, j.Component.PhysicsBody.preUpdate = function () {
        return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || !(this.renderOrderID = -1))
    }, j.Component.PhysicsBody.postUpdate = function () {
        this.exists && this.body && this.body.postUpdate()
    }, j.Component.PhysicsBody.prototype = {
        body: null, x: {
            get: function () {
                return this.position.x
            }, set: function (t) {
                this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
            }
        }, y: {
            get: function () {
                return this.position.y
            }, set: function (t) {
                this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
            }
        }
    }, j.Component.Reset = function () {
    }, j.Component.Reset.prototype.reset = function (t, e, i) {
        return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
    }, j.Component.ScaleMinMax = function () {
    }, j.Component.ScaleMinMax.prototype = {
        transformCallback: null,
        transformCallbackContext: this,
        scaleMin: null,
        scaleMax: null,
        checkTransform: function (t) {
            this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
        },
        setScaleMinMax: function (t, e, i, s) {
            void 0 === e ? e = i = s = t : void 0 === i && (i = s = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new j.Point(t, e), null === i ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(i, s) : this.scaleMax = new j.Point(i, s), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
        }
    }, j.Component.Smoothed = function () {
    }, j.Component.Smoothed.prototype = {
        smoothed: {
            get: function () {
                return !this.texture.baseTexture.scaleMode
            }, set: function (t) {
                t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
            }
        }
    }, j.GameObjectFactory = function (t) {
        this.game = t, this.world = this.game.world
    }, j.GameObjectFactory.prototype = {
        existing: function (t) {
            return this.world.add(t)
        }, weapon: function (t, e, i, s) {
            var n = this.game.plugins.add(j.Weapon);
            return n.createBullets(t, e, i, s), n
        }, image: function (t, e, i, s, n) {
            return void 0 === n && (n = this.world), n.add(new j.Image(this.game, t, e, i, s))
        }, sprite: function (t, e, i, s, n) {
            return void 0 === n && (n = this.world), n.create(t, e, i, s)
        }, creature: function (t, e, i, s, n) {
            void 0 === n && (n = this.world);
            var r = new j.Creature(this.game, t, e, i, s);
            return n.add(r), r
        }, tween: function (t) {
            return this.game.tweens.create(t)
        }, group: function (t, e, i, s, n) {
            return new j.Group(this.game, t, e, i, s, n)
        }, physicsGroup: function (t, e, i, s) {
            return new j.Group(this.game, e, i, s, !0, t)
        }, spriteBatch: function (t, e, i) {
            return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === i && (i = !1), new j.SpriteBatch(this.game, t, e, i)
        }, audio: function (t, e, i, s) {
            return this.game.sound.add(t, e, i, s)
        }, sound: function (t, e, i, s) {
            return this.game.sound.add(t, e, i, s)
        }, audioSprite: function (t) {
            return this.game.sound.addSprite(t)
        }, tileSprite: function (t, e, i, s, n, r, o) {
            return void 0 === o && (o = this.world), o.add(new j.TileSprite(this.game, t, e, i, s, n, r))
        }, rope: function (t, e, i, s, n, r) {
            return void 0 === r && (r = this.world), r.add(new j.Rope(this.game, t, e, i, s, n))
        }, text: function (t, e, i, s, n) {
            return void 0 === n && (n = this.world), n.add(new j.Text(this.game, t, e, i, s))
        }, button: function (t, e, i, s, n, r, o, a, h, l) {
            return void 0 === l && (l = this.world), l.add(new j.Button(this.game, t, e, i, s, n, r, o, a, h))
        }, graphics: function (t, e, i) {
            return void 0 === i && (i = this.world), i.add(new j.Graphics(this.game, t, e))
        }, emitter: function (t, e, i) {
            return this.game.particles.add(new j.Particles.Arcade.Emitter(this.game, t, e, i))
        }, retroFont: function (t, e, i, s, n, r, o, a, h) {
            return new j.RetroFont(this.game, t, e, i, s, n, r, o, a, h)
        }, bitmapText: function (t, e, i, s, n, r) {
            return void 0 === r && (r = this.world), r.add(new j.BitmapText(this.game, t, e, i, s, n))
        }, tilemap: function (t, e, i, s, n) {
            return new j.Tilemap(this.game, t, e, i, s, n)
        }, renderTexture: function (t, e, i, s) {
            void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === s && (s = !1);
            var n = new j.RenderTexture(this.game, t, e, i);
            return s && this.game.cache.addRenderTexture(i, n), n
        }, video: function (t, e) {
            return new j.Video(this.game, t, e)
        }, bitmapData: function (t, e, i, s) {
            void 0 === s && (s = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
            var n = new j.BitmapData(this.game, i, t, e);
            return s && this.game.cache.addBitmapData(i, n), n
        }, filter: function (t) {
            var e = Array.prototype.slice.call(arguments, 1);
            return (t = new j.Filter[t](this.game)).init.apply(t, e), t
        }, plugin: function (t) {
            return this.game.plugins.add(t)
        }
    }, j.GameObjectFactory.prototype.constructor = j.GameObjectFactory, j.GameObjectCreator = function (t) {
        this.game = t, this.world = this.game.world
    }, j.GameObjectCreator.prototype = {
        image: function (t, e, i, s) {
            return new j.Image(this.game, t, e, i, s)
        }, sprite: function (t, e, i, s) {
            return new j.Sprite(this.game, t, e, i, s)
        }, tween: function (t) {
            return new j.Tween(t, this.game, this.game.tweens)
        }, group: function (t, e, i, s, n) {
            return new j.Group(this.game, t, e, i, s, n)
        }, spriteBatch: function (t, e, i) {
            return void 0 === e && (e = "group"), void 0 === i && (i = !1), new j.SpriteBatch(this.game, t, e, i)
        }, audio: function (t, e, i, s) {
            return this.game.sound.add(t, e, i, s)
        }, audioSprite: function (t) {
            return this.game.sound.addSprite(t)
        }, sound: function (t, e, i, s) {
            return this.game.sound.add(t, e, i, s)
        }, tileSprite: function (t, e, i, s, n, r) {
            return new j.TileSprite(this.game, t, e, i, s, n, r)
        }, rope: function (t, e, i, s, n) {
            return new j.Rope(this.game, t, e, i, s, n)
        }, text: function (t, e, i, s) {
            return new j.Text(this.game, t, e, i, s)
        }, button: function (t, e, i, s, n, r, o, a, h) {
            return new j.Button(this.game, t, e, i, s, n, r, o, a, h)
        }, graphics: function (t, e) {
            return new j.Graphics(this.game, t, e)
        }, emitter: function (t, e, i) {
            return new j.Particles.Arcade.Emitter(this.game, t, e, i)
        }, retroFont: function (t, e, i, s, n, r, o, a, h) {
            return new j.RetroFont(this.game, t, e, i, s, n, r, o, a, h)
        }, bitmapText: function (t, e, i, s, n, r) {
            return new j.BitmapText(this.game, t, e, i, s, n, r)
        }, tilemap: function (t, e, i, s, n) {
            return new j.Tilemap(this.game, t, e, i, s, n)
        }, renderTexture: function (t, e, i, s) {
            void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === s && (s = !1);
            var n = new j.RenderTexture(this.game, t, e, i);
            return s && this.game.cache.addRenderTexture(i, n), n
        }, bitmapData: function (t, e, i, s) {
            void 0 === s && (s = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
            var n = new j.BitmapData(this.game, i, t, e);
            return s && this.game.cache.addBitmapData(i, n), n
        }, filter: function (t) {
            var e = Array.prototype.slice.call(arguments, 1);
            return (t = new j.Filter[t](this.game)).init.apply(t, e), t
        }
    }, j.GameObjectCreator.prototype.constructor = j.GameObjectCreator, j.Sprite = function (t, e, i, s, n) {
        e = e || 0, i = i || 0, s = s || null, n = n || null, this.type = j.SPRITE, this.physicsType = j.SPRITE, PIXI.Sprite.call(this, j.Cache.DEFAULT), j.Component.Core.init.call(this, t, e, i, s, n)
    }, j.Sprite.prototype = Object.create(PIXI.Sprite.prototype), j.Sprite.prototype.constructor = j.Sprite, j.Component.Core.install.call(j.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), j.Sprite.prototype.preUpdatePhysics = j.Component.PhysicsBody.preUpdate, j.Sprite.prototype.preUpdateLifeSpan = j.Component.LifeSpan.preUpdate, j.Sprite.prototype.preUpdateInWorld = j.Component.InWorld.preUpdate, j.Sprite.prototype.preUpdateCore = j.Component.Core.preUpdate, j.Sprite.prototype.preUpdate = function () {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    }, j.Image = function (t, e, i, s, n) {
        e = e || 0, i = i || 0, s = s || null, n = n || null, this.type = j.IMAGE, PIXI.Sprite.call(this, j.Cache.DEFAULT), j.Component.Core.init.call(this, t, e, i, s, n)
    }, j.Image.prototype = Object.create(PIXI.Sprite.prototype), j.Image.prototype.constructor = j.Image, j.Component.Core.install.call(j.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), j.Image.prototype.preUpdateInWorld = j.Component.InWorld.preUpdate, j.Image.prototype.preUpdateCore = j.Component.Core.preUpdate, j.Image.prototype.preUpdate = function () {
        return !!this.preUpdateInWorld() && this.preUpdateCore()
    }, j.Button = function (t, e, i, s, n, r, o, a, h, l) {
        e = e || 0, i = i || 0, s = s || null, n = n || null, r = r || this, j.Image.call(this, t, e, i, s, a), this.type = j.BUTTON, this.physicsType = j.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new j.Signal, this.onInputOut = new j.Signal, this.onInputDown = new j.Signal, this.onInputUp = new j.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = j.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(o, a, h, l), null !== n && this.onInputUp.add(n, r), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
    }, j.Button.prototype = Object.create(j.Image.prototype), j.Button.prototype.constructor = j.Button;
    var h = "Over", l = "Out", c = "Down", u = "Up";
    j.Button.prototype.clearFrames = function () {
        this.setFrames(null, null, null, null)
    }, j.Button.prototype.removedFromWorld = function () {
        this.inputEnabled = !1
    }, j.Button.prototype.setStateFrame = function (t, e, i) {
        var s = "_on" + t + "Frame";
        null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
    }, j.Button.prototype.changeStateFrame = function (t) {
        if (this.freezeFrames) return !1;
        var e = this["_on" + t + "Frame"];
        return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
    }, j.Button.prototype.setFrames = function (t, e, i, s) {
        this.setStateFrame(h, t, this.input.pointerOver()), this.setStateFrame(l, e, !this.input.pointerOver()), this.setStateFrame(c, i, this.input.pointerDown()), this.setStateFrame(u, s, this.input.pointerUp())
    }, j.Button.prototype.setStateSound = function (t, e, i) {
        var s = "on" + t + "Sound", n = "on" + t + "SoundMarker";
        e instanceof j.Sound || e instanceof j.AudioSprite ? (this[s] = e, this[n] = "string" == typeof i ? i : "") : (this[s] = null, this[n] = "")
    }, j.Button.prototype.playStateSound = function (t) {
        var e = this["on" + t + "Sound"];
        if (e) {
            var i = this["on" + t + "SoundMarker"];
            return e.play(i), !0
        }
        return !1
    }, j.Button.prototype.setSounds = function (t, e, i, s, n, r, o, a) {
        this.setStateSound(h, t, e), this.setStateSound(l, n, r), this.setStateSound(c, i, s), this.setStateSound(u, o, a)
    }, j.Button.prototype.setOverSound = function (t, e) {
        this.setStateSound(h, t, e)
    }, j.Button.prototype.setOutSound = function (t, e) {
        this.setStateSound(l, t, e)
    }, j.Button.prototype.setDownSound = function (t, e) {
        this.setStateSound(c, t, e)
    }, j.Button.prototype.setUpSound = function (t, e) {
        this.setStateSound(u, t, e)
    }, j.Button.prototype.onInputOverHandler = function (t, e) {
        e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame(h), this.onOverMouseOnly && !e.isMouse || (this.playStateSound(h), this.onInputOver && this.onInputOver.dispatch(this, e)))
    }, j.Button.prototype.onInputOutHandler = function (t, e) {
        this.changeStateFrame(l), this.playStateSound(l), this.onInputOut && this.onInputOut.dispatch(this, e)
    }, j.Button.prototype.onInputDownHandler = function (t, e) {
        this.changeStateFrame(c), this.playStateSound(c), this.onInputDown && this.onInputDown.dispatch(this, e)
    }, j.Button.prototype.onInputUpHandler = function (t, e, i) {
        (this.playStateSound(u), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames) || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame(l) : this.changeStateFrame(u) || (i ? this.changeStateFrame(h) : this.changeStateFrame(l)))
    }, j.SpriteBatch = function (t, e, i, s) {
        null == e && (e = t.world), PIXI.SpriteBatch.call(this), j.Group.call(this, t, e, i, s), this.type = j.SPRITEBATCH
    }, j.SpriteBatch.prototype = j.Utils.extend(!0, j.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, j.Group.prototype), j.SpriteBatch.prototype.constructor = j.SpriteBatch, PIXI.Graphics = function () {
        PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
    }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function (t, e, i) {
        return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
    }, PIXI.Graphics.prototype.moveTo = function (t, e) {
        return this.drawShape(new PIXI.Polygon([t, e])), this
    }, PIXI.Graphics.prototype.lineTo = function (t, e) {
        return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
    }, PIXI.Graphics.prototype.quadraticCurveTo = function (t, e, i, s) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
        var n, r, o = this.currentPath.shape.points;
        0 === o.length && this.moveTo(0, 0);
        for (var a = o[o.length - 2], h = o[o.length - 1], l = 0, c = 1; c <= 20; ++c) n = a + (t - a) * (l = c / 20), r = h + (e - h) * l, o.push(n + (t + (i - t) * l - n) * l, r + (e + (s - e) * l - r) * l);
        return this.dirty = !0, this._boundsDirty = !0, this
    }, PIXI.Graphics.prototype.bezierCurveTo = function (t, e, i, s, n, r) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
        for (var o, a, h, l, c, u = this.currentPath.shape.points, d = u[u.length - 2], p = u[u.length - 1], f = 0, g = 1; g <= 20; ++g) h = (a = (o = 1 - (f = g / 20)) * o) * o, c = (l = f * f) * f, u.push(h * d + 3 * a * f * t + 3 * o * l * i + c * n, h * p + 3 * a * f * e + 3 * o * l * s + c * r);
        return this.dirty = !0, this._boundsDirty = !0, this
    }, PIXI.Graphics.prototype.arcTo = function (t, e, i, s, n) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
        var r = this.currentPath.shape.points, o = r[r.length - 2], a = r[r.length - 1] - e, h = o - t, l = s - e,
            c = i - t, u = Math.abs(a * c - h * l);
        if (u < 1e-8 || 0 === n) r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e); else {
            var d = a * a + h * h, p = l * l + c * c, f = a * l + h * c, g = n * Math.sqrt(d) / u,
                m = n * Math.sqrt(p) / u, y = g * f / d, v = m * f / p, x = g * c + m * h, b = g * l + m * a,
                _ = h * (m + y), w = a * (m + y), T = c * (g + v), P = l * (g + v), S = Math.atan2(w - b, _ - x),
                C = Math.atan2(P - b, T - x);
            this.arc(x + t, b + e, n, S, C, c * a < h * l)
        }
        return this.dirty = !0, this._boundsDirty = !0, this
    }, PIXI.Graphics.prototype.arc = function (t, e, i, s, n, r, o) {
        if (s === n) return this;
        void 0 === r && (r = !1), void 0 === o && (o = 40), !r && n <= s ? n += 2 * Math.PI : r && s <= n && (s += 2 * Math.PI);
        var a = r ? -1 * (s - n) : n - s, h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * o;
        if (0 === a) return this;
        var l = t + Math.cos(s) * i, c = e + Math.sin(s) * i;
        r && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
        for (var u = this.currentPath.shape.points, d = a / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d), m = h - 1, y = m % 1 / m, v = 0; v <= m; v++) {
            var x = d + s + p * (v + y * v), b = Math.cos(x), _ = -Math.sin(x);
            u.push((f * b + g * _) * i + t, (f * -_ + g * b) * i + e)
        }
        return this.dirty = !0, this._boundsDirty = !0, this
    }, PIXI.Graphics.prototype.beginFill = function (t, e) {
        return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
    }, PIXI.Graphics.prototype.endFill = function () {
        return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
    }, PIXI.Graphics.prototype.drawRect = function (t, e, i, s) {
        return this.drawShape(new PIXI.Rectangle(t, e, i, s)), this
    }, PIXI.Graphics.prototype.drawRoundedRect = function (t, e, i, s, n) {
        return this.drawShape(new PIXI.RoundedRectangle(t, e, i, s, n)), this
    }, PIXI.Graphics.prototype.drawCircle = function (t, e, i) {
        return this.drawShape(new PIXI.Circle(t, e, i)), this
    }, PIXI.Graphics.prototype.drawEllipse = function (t, e, i, s) {
        return this.drawShape(new PIXI.Ellipse(t, e, i, s)), this
    }, PIXI.Graphics.prototype.drawPolygon = function (t) {
        (t instanceof j.Polygon || t instanceof PIXI.Polygon) && (t = t.points);
        var e = t;
        if (!Array.isArray(e)) {
            e = new Array(arguments.length);
            for (var i = 0; i < e.length; ++i) e[i] = arguments[i]
        }
        return this.drawShape(new j.Polygon(e)), this
    }, PIXI.Graphics.prototype.clear = function () {
        return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
    }, PIXI.Graphics.prototype.generateTexture = function (t, e, i) {
        void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
        var s = this.getBounds();
        s.width += i, s.height += i;
        var n = new PIXI.CanvasBuffer(s.width * t, s.height * t), r = PIXI.Texture.fromCanvas(n.canvas, e);
        return r.baseTexture.resolution = t, n.context.scale(t, t), n.context.translate(-s.x, -s.y), PIXI.CanvasGraphics.renderGraphics(this, n.context), r
    }, PIXI.Graphics.prototype._renderWebGL = function (t) {
        if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
            if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
            if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                t.spriteBatch.currentBlendMode = this.blendMode;
                var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                t.spriteBatch.gl.blendFunc(e[0], e[1])
            }
            if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                t.spriteBatch.start();
                for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                t.spriteBatch.stop()
            }
            this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
        }
    }, PIXI.Graphics.prototype._renderCanvas = function (t) {
        if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
            if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
            var e = t.context, i = this.worldTransform;
            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
            var s = t.resolution, n = i.tx * t.resolution + t.shakeX, r = i.ty * t.resolution + t.shakeY;
            e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), PIXI.CanvasGraphics.renderGraphics(this, e);
            for (var o = 0; o < this.children.length; o++) this.children[o]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    }, PIXI.Graphics.prototype.getBounds = function (t) {
        if (!this._currentBounds) {
            if (!this.renderable) return PIXI.EmptyRectangle;
            this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
            var e = this._localBounds, i = e.x, s = e.width + e.x, n = e.y, r = e.height + e.y,
                o = t || this.worldTransform, a = o.a, h = o.b, l = o.c, c = o.d, u = o.tx, d = o.ty,
                p = a * s + l * r + u, f = c * r + h * s + d, g = a * i + l * r + u, m = c * r + h * i + d,
                y = a * i + l * n + u, v = c * n + h * i + d, x = a * s + l * n + u, b = c * n + h * s + d, _ = p,
                w = f, T = p, P = f;
            T = x < (T = y < (T = g < T ? g : T) ? y : T) ? x : T, P = b < (P = v < (P = m < P ? m : P) ? v : P) ? b : P, _ = (_ = (_ = _ < g ? g : _) < y ? y : _) < x ? x : _, w = (w = (w = w < m ? m : w) < v ? v : w) < b ? b : w, this._bounds.x = T, this._bounds.width = _ - T, this._bounds.y = P, this._bounds.height = w - P, this._currentBounds = this._bounds
        }
        return this._currentBounds
    }, PIXI.Graphics.prototype.getLocalBounds = function () {
        var t = this.worldTransform;
        this.worldTransform = PIXI.identityMatrix;
        for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        var i = this.getBounds();
        for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        return i
    }, PIXI.Graphics.prototype.containsPoint = function (t) {
        this.worldTransform.applyInverse(t, tempPoint);
        for (var e = this.graphicsData, i = 0; i < e.length; i++) {
            var s = e[i];
            if (s.fill && (s.shape && s.shape.contains(tempPoint.x, tempPoint.y))) return !0
        }
        return !1
    }, PIXI.Graphics.prototype.updateLocalBounds = function () {
        var t = 1 / 0, e = -1 / 0, i = 1 / 0, s = -1 / 0;
        if (this.graphicsData.length) for (var n, r, o, a, h, l, c = 0; c < this.graphicsData.length; c++) {
            var u = this.graphicsData[c], d = u.type, p = u.lineWidth;
            if (n = u.shape, d === PIXI.Graphics.RECT || d === PIXI.Graphics.RREC) o = n.x - p / 2, a = n.y - p / 2, t = o < t ? o : t, e = e < o + (h = n.width + p) ? o + h : e, i = a < i ? a : i, s = s < a + (l = n.height + p) ? a + l : s; else if (d === PIXI.Graphics.CIRC) o = n.x, a = n.y, t = o - (h = n.radius + p / 2) < t ? o - h : t, e = e < o + h ? o + h : e, i = a - (l = n.radius + p / 2) < i ? a - l : i, s = s < a + l ? a + l : s; else if (d === PIXI.Graphics.ELIP) o = n.x, a = n.y, t = o - (h = n.width + p / 2) < t ? o - h : t, e = e < o + h ? o + h : e, i = a - (l = n.height + p / 2) < i ? a - l : i, s = s < a + l ? a + l : s; else {
                r = n.points;
                for (var f = 0; f < r.length; f++) r[f] instanceof j.Point ? (o = r[f].x, a = r[f].y) : (o = r[f], a = r[f + 1], f < r.length - 1 && f++), t = o - p < t ? o - p : t, e = e < o + p ? o + p : e, i = a - p < i ? a - p : i, s = s < a + p ? a + p : s
            }
        } else s = i = e = t = 0;
        var g = this.boundsPadding;
        this._localBounds.x = t - g, this._localBounds.width = e - t + 2 * g, this._localBounds.y = i - g, this._localBounds.height = s - i + 2 * g
    }, PIXI.Graphics.prototype._generateCachedSprite = function () {
        var t = this.getLocalBounds();
        if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height); else {
            var e = new PIXI.CanvasBuffer(t.width, t.height), i = PIXI.Texture.fromCanvas(e.canvas);
            this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
        }
        this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
    }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function () {
        var t = this._cachedSprite, e = t.texture, i = t.buffer.canvas;
        e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
    }, PIXI.Graphics.prototype.destroyCachedSprite = function () {
        this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
    }, PIXI.Graphics.prototype.drawShape = function (t) {
        this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof j.Polygon && (t = t.clone()).flatten();
        var e = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
        return this.graphicsData.push(e), e.type === PIXI.Graphics.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
    }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
        get: function () {
            return this._cacheAsBitmap
        }, set: function (t) {
            this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
        }
    }), PIXI.GraphicsData = function (t, e, i, s, n, r, o) {
        this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = s, this.fillAlpha = n, this._fillTint = s, this.fill = r, this.shape = o, this.type = o.type
    }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function () {
        return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
    }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function (t, e, i) {
        i = i || 2;
        var s, n, r, o, a, h, l, c = e && e.length, u = c ? e[0] * i : t.length,
            d = PIXI.EarCut.linkedList(t, 0, u, i, !0), p = [];
        if (!d) return p;
        if (c && (d = PIXI.EarCut.eliminateHoles(t, e, d, i)), t.length > 80 * i) {
            s = r = t[0], n = o = t[1];
            for (var f = i; f < u; f += i) (a = t[f]) < s && (s = a), (h = t[f + 1]) < n && (n = h), r < a && (r = a), o < h && (o = h);
            l = Math.max(r - s, o - n)
        }
        return PIXI.EarCut.earcutLinked(d, p, i, s, n, l), p
    }, PIXI.EarCut.linkedList = function (t, e, i, s, n) {
        var r, o, a, h = 0;
        for (r = e, o = i - s; r < i; r += s) h += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r;
        if (n === 0 < h) for (r = e; r < i; r += s) a = PIXI.EarCut.insertNode(r, t[r], t[r + 1], a); else for (r = i - s; e <= r; r -= s) a = PIXI.EarCut.insertNode(r, t[r], t[r + 1], a);
        return a
    }, PIXI.EarCut.filterPoints = function (t, e) {
        if (!t) return t;
        e || (e = t);
        var i, s = t;
        do {
            if (i = !1, s.steiner || !PIXI.EarCut.equals(s, s.next) && 0 !== PIXI.EarCut.area(s.prev, s, s.next)) s = s.next; else {
                if (PIXI.EarCut.removeNode(s), (s = e = s.prev) === s.next) return null;
                i = !0
            }
        } while (i || s !== e);
        return e
    }, PIXI.EarCut.earcutLinked = function (t, e, i, s, n, r, o) {
        if (t) {
            !o && r && PIXI.EarCut.indexCurve(t, s, n, r);
            for (var a, h, l = t; t.prev !== t.next;) if (a = t.prev, h = t.next, r ? PIXI.EarCut.isEarHashed(t, s, n, r) : PIXI.EarCut.isEar(t)) e.push(a.i / i), e.push(t.i / i), e.push(h.i / i), PIXI.EarCut.removeNode(t), t = h.next, l = h.next; else if ((t = h) === l) {
                o ? 1 === o ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, s, n, r, 2)) : 2 === o && PIXI.EarCut.splitEarcut(t, e, i, s, n, r) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, s, n, r, 1);
                break
            }
        }
    }, PIXI.EarCut.isEar = function (t) {
        var e = t.prev, i = t, s = t.next;
        if (0 <= PIXI.EarCut.area(e, i, s)) return !1;
        for (var n = t.next.next; n !== t.prev;) {
            if (PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, s.x, s.y, n.x, n.y) && 0 <= PIXI.EarCut.area(n.prev, n, n.next)) return !1;
            n = n.next
        }
        return !0
    }, PIXI.EarCut.isEarHashed = function (t, e, i, s) {
        var n = t.prev, r = t, o = t.next;
        if (0 <= PIXI.EarCut.area(n, r, o)) return !1;
        for (var a = n.x < r.x ? n.x < o.x ? n.x : o.x : r.x < o.x ? r.x : o.x, h = n.y < r.y ? n.y < o.y ? n.y : o.y : r.y < o.y ? r.y : o.y, l = n.x > r.x ? n.x > o.x ? n.x : o.x : r.x > o.x ? r.x : o.x, c = n.y > r.y ? n.y > o.y ? n.y : o.y : r.y > o.y ? r.y : o.y, u = PIXI.EarCut.zOrder(a, h, e, i, s), d = PIXI.EarCut.zOrder(l, c, e, i, s), p = t.nextZ; p && p.z <= d;) {
            if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(n.x, n.y, r.x, r.y, o.x, o.y, p.x, p.y) && 0 <= PIXI.EarCut.area(p.prev, p, p.next)) return !1;
            p = p.nextZ
        }
        for (p = t.prevZ; p && p.z >= u;) {
            if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(n.x, n.y, r.x, r.y, o.x, o.y, p.x, p.y) && 0 <= PIXI.EarCut.area(p.prev, p, p.next)) return !1;
            p = p.prevZ
        }
        return !0
    }, PIXI.EarCut.cureLocalIntersections = function (t, e, i) {
        var s = t;
        do {
            var n = s.prev, r = s.next.next;
            PIXI.EarCut.intersects(n, s, s.next, r) && PIXI.EarCut.locallyInside(n, r) && PIXI.EarCut.locallyInside(r, n) && (e.push(n.i / i), e.push(s.i / i), e.push(r.i / i), PIXI.EarCut.removeNode(s), PIXI.EarCut.removeNode(s.next), s = t = r), s = s.next
        } while (s !== t);
        return s
    }, PIXI.EarCut.splitEarcut = function (t, e, i, s, n, r) {
        var o = t;
        do {
            for (var a = o.next.next; a !== o.prev;) {
                if (o.i !== a.i && PIXI.EarCut.isValidDiagonal(o, a)) {
                    var h = PIXI.EarCut.splitPolygon(o, a);
                    return o = PIXI.EarCut.filterPoints(o, o.next), h = PIXI.EarCut.filterPoints(h, h.next), PIXI.EarCut.earcutLinked(o, e, i, s, n, r), void PIXI.EarCut.earcutLinked(h, e, i, s, n, r)
                }
                a = a.next
            }
            o = o.next
        } while (o !== t)
    }, PIXI.EarCut.eliminateHoles = function (t, e, i, s) {
        var n, r, o, a, h, l = [];
        for (n = 0, r = e.length; n < r; n++) o = e[n] * s, a = n < r - 1 ? e[n + 1] * s : t.length, (h = PIXI.EarCut.linkedList(t, o, a, s, !1)) === h.next && (h.steiner = !0), l.push(PIXI.EarCut.getLeftmost(h));
        for (l.sort(compareX), n = 0; n < l.length; n++) PIXI.EarCut.eliminateHole(l[n], i), i = PIXI.EarCut.filterPoints(i, i.next);
        return i
    }, PIXI.EarCut.compareX = function (t, e) {
        return t.x - e.x
    }, PIXI.EarCut.eliminateHole = function (t, e) {
        if (e = PIXI.EarCut.findHoleBridge(t, e)) {
            var i = PIXI.EarCut.splitPolygon(e, t);
            PIXI.EarCut.filterPoints(i, i.next)
        }
    }, PIXI.EarCut.findHoleBridge = function (t, e) {
        var i, s = e, n = t.x, r = t.y, o = -1 / 0;
        do {
            if (r <= s.y && r >= s.next.y) {
                var a = s.x + (r - s.y) * (s.next.x - s.x) / (s.next.y - s.y);
                a <= n && o < a && (o = a, i = s.x < s.next.x ? s : s.next)
            }
            s = s.next
        } while (s !== e);
        if (!i) return null;
        if (t.x === i.x) return i.prev;
        var h, l = i, c = 1 / 0;
        for (s = i.next; s !== l;) n >= s.x && s.x >= i.x && PIXI.EarCut.pointInTriangle(r < i.y ? n : o, r, i.x, i.y, r < i.y ? o : n, r, s.x, s.y) && ((h = Math.abs(r - s.y) / (n - s.x)) < c || h === c && s.x > i.x) && PIXI.EarCut.locallyInside(s, t) && (i = s, c = h), s = s.next;
        return i
    }, PIXI.EarCut.indexCurve = function (t, e, i, s) {
        for (var n = t; null === n.z && (n.z = PIXI.EarCut.zOrder(n.x, n.y, e, i, s)), n.prevZ = n.prev, n.nextZ = n.next, (n = n.next) !== t;) ;
        n.prevZ.nextZ = null, n.prevZ = null, PIXI.EarCut.sortLinked(n)
    }, PIXI.EarCut.sortLinked = function (t) {
        var e, i, s, n, r, o, a, h, l = 1;
        do {
            for (i = t, r = t = null, o = 0; i;) {
                for (o++, s = i, e = a = 0; e < l && (a++, s = s.nextZ); e++) ;
                for (h = l; 0 < a || 0 < h && s;) 0 === a ? (s = (n = s).nextZ, h--) : 0 !== h && s ? i.z <= s.z ? (i = (n = i).nextZ, a--) : (s = (n = s).nextZ, h--) : (i = (n = i).nextZ, a--), r ? r.nextZ = n : t = n, n.prevZ = r, r = n;
                i = s
            }
            r.nextZ = null, l *= 2
        } while (1 < o);
        return t
    }, PIXI.EarCut.zOrder = function (t, e, i, s, n) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - s) / n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }, PIXI.EarCut.getLeftmost = function (t) {
        for (var e = t, i = t; e.x < i.x && (i = e), (e = e.next) !== t;) ;
        return i
    }, PIXI.EarCut.pointInTriangle = function (t, e, i, s, n, r, o, a) {
        return 0 <= (n - o) * (e - a) - (t - o) * (r - a) && 0 <= (t - o) * (s - a) - (i - o) * (e - a) && 0 <= (i - o) * (r - a) - (n - o) * (s - a)
    }, PIXI.EarCut.isValidDiagonal = function (t, e) {
        return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e)
    }, PIXI.EarCut.area = function (t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
    }, PIXI.EarCut.equals = function (t, e) {
        return t.x === e.x && t.y === e.y
    }, PIXI.EarCut.intersects = function (t, e, i, s) {
        return 0 < PIXI.EarCut.area(t, e, i) != 0 < PIXI.EarCut.area(t, e, s) && 0 < PIXI.EarCut.area(i, s, t) != 0 < PIXI.EarCut.area(i, s, e)
    }, PIXI.EarCut.intersectsPolygon = function (t, e) {
        var i = t;
        do {
            if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e)) return !0;
            i = i.next
        } while (i !== t);
        return !1
    }, PIXI.EarCut.locallyInside = function (t, e) {
        return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? 0 <= PIXI.EarCut.area(t, e, t.next) && 0 <= PIXI.EarCut.area(t, t.prev, e) : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0
    }, PIXI.EarCut.middleInside = function (t, e) {
        for (var i = t, s = !1, n = (t.x + e.x) / 2, r = (t.y + e.y) / 2; i.y > r != i.next.y > r && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s), (i = i.next) !== t;) ;
        return s
    }, PIXI.EarCut.splitPolygon = function (t, e) {
        var i = new PIXI.EarCut.Node(t.i, t.x, t.y), s = new PIXI.EarCut.Node(e.i, e.x, e.y), n = t.next, r = e.prev;
        return (t.next = e).prev = t, (i.next = n).prev = i, (s.next = i).prev = s, (r.next = s).prev = r, s
    }, PIXI.EarCut.insertNode = function (t, e, i, s) {
        var n = new PIXI.EarCut.Node(t, e, i);
        return s ? (n.next = s.next, (n.prev = s).next.prev = n, s.next = n) : (n.prev = n).next = n, n
    }, PIXI.EarCut.removeNode = function (t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }, PIXI.EarCut.Node = function (t, e, i) {
        this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }, PIXI.WebGLGraphics = function () {
    }, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function (t, e) {
        var i, s = e.gl, n = e.projection, r = e.offset, o = e.shaderManager.primitiveShader;
        t.dirty && PIXI.WebGLGraphics.updateGraphics(t, s);
        for (var a = t._webGL[s.id], h = 0; h < a.data.length; h++) 1 === a.data[h].mode ? (i = a.data[h], e.stencilManager.pushStencil(t, i, e), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e)) : (i = a.data[h], e.shaderManager.setShader(o), o = e.shaderManager.primitiveShader, s.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform1f(o.flipY, 1), s.uniform2f(o.projectionVector, n.x, -n.y), s.uniform2f(o.offsetVector, -r.x, -r.y), s.uniform3fv(o.tintColor, PIXI.hex2rgb(t.tint)), s.uniform1f(o.alpha, t.worldAlpha), s.bindBuffer(s.ARRAY_BUFFER, i.buffer), s.vertexAttribPointer(o.aVertexPosition, 2, s.FLOAT, !1, 24, 0), s.vertexAttribPointer(o.colorAttribute, 4, s.FLOAT, !1, 24, 8), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, i.indexBuffer), s.drawElements(s.TRIANGLE_STRIP, i.indices.length, s.UNSIGNED_SHORT, 0))
    }, PIXI.WebGLGraphics.updateGraphics = function (t, e) {
        var i, s, n = t._webGL[e.id];
        if (n || (n = t._webGL[e.id] = {lastIndex: 0, data: [], gl: e}), t.dirty = !1, t.clearDirty) {
            for (t.clearDirty = !1, i = 0; i < n.data.length; i++) {
                var r = n.data[i];
                r.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(r)
            }
            n.data = [], n.lastIndex = 0
        }
        for (i = n.lastIndex; i < t.graphicsData.length; i++) {
            var o = t.graphicsData[i];
            if (o.type === PIXI.Graphics.POLY) {
                if (o.points = o.shape.points.slice(), o.shape.closed && (o.points[0] === o.points[o.points.length - 2] && o.points[1] === o.points[o.points.length - 1] || o.points.push(o.points[0], o.points[1])), o.fill) if (o.points.length >= PIXI.WebGLGraphics.stencilBufferLimit) if (o.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) s = PIXI.WebGLGraphics.switchMode(n, 0), PIXI.WebGLGraphics.buildPoly(o, s) || (s = PIXI.WebGLGraphics.switchMode(n, 1), PIXI.WebGLGraphics.buildComplexPoly(o, s)); else s = PIXI.WebGLGraphics.switchMode(n, 1), PIXI.WebGLGraphics.buildComplexPoly(o, s);
                0 < o.lineWidth && (s = PIXI.WebGLGraphics.switchMode(n, 0), PIXI.WebGLGraphics.buildLine(o, s))
            } else s = PIXI.WebGLGraphics.switchMode(n, 0), o.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(o, s) : o.type === PIXI.Graphics.CIRC || o.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(o, s) : o.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(o, s);
            n.lastIndex++
        }
        for (i = 0; i < n.data.length; i++) (s = n.data[i]).dirty && s.upload()
    }, PIXI.WebGLGraphics.switchMode = function (t, e) {
        var i;
        return t.data.length && (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i
    }, PIXI.WebGLGraphics.buildRectangle = function (t, e) {
        var i = t.shape, s = i.x, n = i.y, r = i.width, o = i.height;
        if (t.fill) {
            var a = PIXI.hex2rgb(t.fillColor), h = t.fillAlpha, l = a[0] * h, c = a[1] * h, u = a[2] * h, d = e.points,
                p = e.indices, f = d.length / 6;
            d.push(s, n), d.push(l, c, u, h), d.push(s + r, n), d.push(l, c, u, h), d.push(s, n + o), d.push(l, c, u, h), d.push(s + r, n + o), d.push(l, c, u, h), p.push(f, f, f + 1, f + 2, f + 3, f + 3)
        }
        if (t.lineWidth) {
            var g = t.points;
            t.points = [s, n, s + r, n, s + r, n + o, s, n + o, s, n], PIXI.WebGLGraphics.buildLine(t, e), t.points = g
        }
    }, PIXI.WebGLGraphics.buildRoundedRectangle = function (t, e) {
        var i = t.shape, s = i.x, n = i.y, r = i.width, o = i.height, a = i.radius, h = [];
        if (h.push(s, n + a), h = (h = (h = (h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s, n + o - a, s, n + o, s + a, n + o))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + r - a, n + o, s + r, n + o, s + r, n + o - a))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + r, n + a, s + r, n, s + r - a, n))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + a, n, s, n, s, n + a)), t.fill) {
            var l = PIXI.hex2rgb(t.fillColor), c = t.fillAlpha, u = l[0] * c, d = l[1] * c, p = l[2] * c, f = e.points,
                g = e.indices, m = f.length / 6, y = PIXI.EarCut.Triangulate(h, null, 2), v = 0;
            for (v = 0; v < y.length; v += 3) g.push(y[v] + m), g.push(y[v] + m), g.push(y[v + 1] + m), g.push(y[v + 2] + m), g.push(y[v + 2] + m);
            for (v = 0; v < h.length; v++) f.push(h[v], h[++v], u, d, p, c)
        }
        if (t.lineWidth) {
            var x = t.points;
            t.points = h, PIXI.WebGLGraphics.buildLine(t, e), t.points = x
        }
    }, PIXI.WebGLGraphics.quadraticBezierCurve = function (t, e, i, s, n, r) {
        var o, a, h, l, c, u, d = [];

        function p(t, e, i) {
            return t + (e - t) * i
        }

        for (var f = 0, g = 0; g <= 20; g++) o = p(t, i, f = g / 20), a = p(e, s, f), h = p(i, n, f), l = p(s, r, f), c = p(o, h, f), u = p(a, l, f), d.push(c, u);
        return d
    }, PIXI.WebGLGraphics.buildCircle = function (t, e) {
        var i, s, n = t.shape, r = n.x, o = n.y;
        s = t.type === PIXI.Graphics.CIRC ? (i = n.radius, n.radius) : (i = n.width, n.height);
        var a = 2 * Math.PI / 40, h = 0;
        if (t.fill) {
            var l = PIXI.hex2rgb(t.fillColor), c = t.fillAlpha, u = l[0] * c, d = l[1] * c, p = l[2] * c, f = e.points,
                g = e.indices, m = f.length / 6;
            for (g.push(m), h = 0; h < 41; h++) f.push(r, o, u, d, p, c), f.push(r + Math.sin(a * h) * i, o + Math.cos(a * h) * s, u, d, p, c), g.push(m++, m++);
            g.push(m - 1)
        }
        if (t.lineWidth) {
            var y = t.points;
            for (t.points = [], h = 0; h < 41; h++) t.points.push(r + Math.sin(a * h) * i, o + Math.cos(a * h) * s);
            PIXI.WebGLGraphics.buildLine(t, e), t.points = y
        }
    }, PIXI.WebGLGraphics.buildLine = function (t, e) {
        var i = 0, s = t.points;
        if (0 !== s.length) {
            if (t.lineWidth % 2) for (i = 0; i < s.length; i++) s[i] += .5;
            var n = new PIXI.Point(s[0], s[1]), r = new PIXI.Point(s[s.length - 2], s[s.length - 1]);
            if (n.x === r.x && n.y === r.y) {
                (s = s.slice()).pop(), s.pop();
                var o = (r = new PIXI.Point(s[s.length - 2], s[s.length - 1])).x + .5 * (n.x - r.x),
                    a = r.y + .5 * (n.y - r.y);
                s.unshift(o, a), s.push(o, a)
            }
            var h, l, c, u, d, p, f, g, m, y, v, x, b, _, w, T, P, S, C, I, M, E, A = e.points, R = e.indices,
                O = s.length / 2, L = s.length, k = A.length / 6, D = t.lineWidth / 2, B = PIXI.hex2rgb(t.lineColor),
                F = t.lineAlpha, U = B[0] * F, G = B[1] * F, X = B[2] * F;
            for (c = s[0], u = s[1], d = s[2], m = -(u - (p = s[3])), y = c - d, m /= E = Math.sqrt(m * m + y * y), y /= E, m *= D, y *= D, A.push(c - m, u - y, U, G, X, F), A.push(c + m, u + y, U, G, X, F), i = 1; i < O - 1; i++) c = s[2 * (i - 1)], u = s[2 * (i - 1) + 1], d = s[2 * i], p = s[2 * i + 1], f = s[2 * (i + 1)], g = s[2 * (i + 1) + 1], m = -(u - p), y = c - d, m /= E = Math.sqrt(m * m + y * y), y /= E, m *= D, y *= D, v = -(p - g), x = d - f, v /= E = Math.sqrt(v * v + x * x), x /= E, P = (-m + c) * (-y + p) - (-m + d) * (-y + u), I = (-(v *= D) + f) * (-(x *= D) + p) - (-v + d) * (-x + g), M = (w = -y + u - (-y + p)) * (C = -v + d - (-v + f)) - (S = -x + g - (-x + p)) * (T = -m + d - (-m + c)), Math.abs(M) < .1 ? (M += 10.1, A.push(d - m, p - y, U, G, X, F), A.push(d + m, p + y, U, G, X, F)) : 19600 < ((h = (T * I - C * P) / M) - d) * (h - d) + ((l = (S * P - w * I) / M) - p) + (l - p) ? (b = m - v, _ = y - x, b /= E = Math.sqrt(b * b + _ * _), _ /= E, b *= D, _ *= D, A.push(d - b, p - _), A.push(U, G, X, F), A.push(d + b, p + _), A.push(U, G, X, F), A.push(d - b, p - _), A.push(U, G, X, F), L++) : (A.push(h, l), A.push(U, G, X, F), A.push(d - (h - d), p - (l - p)), A.push(U, G, X, F));
            for (c = s[2 * (O - 2)], u = s[2 * (O - 2) + 1], d = s[2 * (O - 1)], m = -(u - (p = s[2 * (O - 1) + 1])), y = c - d, m /= E = Math.sqrt(m * m + y * y), y /= E, m *= D, y *= D, A.push(d - m, p - y), A.push(U, G, X, F), A.push(d + m, p + y), A.push(U, G, X, F), R.push(k), i = 0; i < L; i++) R.push(k++);
            R.push(k - 1)
        }
    }, PIXI.WebGLGraphics.buildComplexPoly = function (t, e) {
        var i = t.points.slice();
        if (!(i.length < 6)) {
            var s = e.indices;
            e.points = i, e.alpha = t.fillAlpha, e.color = PIXI.hex2rgb(t.fillColor);
            for (var n, r, o = 1 / 0, a = -1 / 0, h = 1 / 0, l = -1 / 0, c = 0; c < i.length; c += 2) o = (n = i[c]) < o ? n : o, a = a < n ? n : a, h = (r = i[c + 1]) < h ? r : h, l = l < r ? r : l;
            i.push(o, h, a, h, a, l, o, l);
            var u = i.length / 2;
            for (c = 0; c < u; c++) s.push(c)
        }
    }, PIXI.WebGLGraphics.buildPoly = function (t, e) {
        var i = t.points;
        if (!(i.length < 6)) {
            var s = e.points, n = e.indices, r = i.length / 2, o = PIXI.hex2rgb(t.fillColor), a = t.fillAlpha,
                h = o[0] * a, l = o[1] * a, c = o[2] * a, u = PIXI.EarCut.Triangulate(i, null, 2);
            if (!u) return !1;
            var d = s.length / 6, p = 0;
            for (p = 0; p < u.length; p += 3) n.push(u[p] + d), n.push(u[p] + d), n.push(u[p + 1] + d), n.push(u[p + 2] + d), n.push(u[p + 2] + d);
            for (p = 0; p < r; p++) s.push(i[2 * p], i[2 * p + 1], h, l, c, a);
            return !0
        }
    }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function (t) {
        this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
    }, PIXI.WebGLGraphicsData.prototype.reset = function () {
        this.points = [], this.indices = []
    }, PIXI.WebGLGraphicsData.prototype.upload = function () {
        var t = this.gl;
        this.glPoints = new PIXI.Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
    }, PIXI.CanvasGraphics = function () {
    }, PIXI.CanvasGraphics.renderGraphics = function (t, e) {
        var i = t.worldAlpha;
        t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
        for (var s = 0; s < t.graphicsData.length; s++) {
            var n = t.graphicsData[s], r = n.shape, o = n._fillTint, a = n._lineTint;
            if (e.lineWidth = n.lineWidth, n.type === PIXI.Graphics.POLY) {
                e.beginPath();
                var h = r.points;
                e.moveTo(h[0], h[1]);
                for (var l = 1; l < h.length / 2; l++) e.lineTo(h[2 * l], h[2 * l + 1]);
                r.closed && e.lineTo(h[0], h[1]), h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
            } else if (n.type === PIXI.Graphics.RECT) (n.fillColor || 0 === n.fillColor) && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fillRect(r.x, r.y, r.width, r.height)), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.strokeRect(r.x, r.y, r.width, r.height)); else if (n.type === PIXI.Graphics.CIRC) e.beginPath(), e.arc(r.x, r.y, r.radius, 0, 2 * Math.PI), e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke()); else if (n.type === PIXI.Graphics.ELIP) {
                var c = 2 * r.width, u = 2 * r.height, d = r.x - c / 2, p = r.y - u / 2;
                e.beginPath();
                var f = c / 2 * .5522848, g = u / 2 * .5522848, m = d + c, y = p + u, v = d + c / 2, x = p + u / 2;
                e.moveTo(d, x), e.bezierCurveTo(d, x - g, v - f, p, v, p), e.bezierCurveTo(v + f, p, m, x - g, m, x), e.bezierCurveTo(m, x + g, v + f, y, v, y), e.bezierCurveTo(v - f, y, d, x + g, d, x), e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
            } else if (n.type === PIXI.Graphics.RREC) {
                var b = r.x, _ = r.y, w = r.width, T = r.height, P = r.radius, S = Math.min(w, T) / 2 | 0;
                P = S < P ? S : P, e.beginPath(), e.moveTo(b, _ + P), e.lineTo(b, _ + T - P), e.quadraticCurveTo(b, _ + T, b + P, _ + T), e.lineTo(b + w - P, _ + T), e.quadraticCurveTo(b + w, _ + T, b + w, _ + T - P), e.lineTo(b + w, _ + P), e.quadraticCurveTo(b + w, _, b + w - P, _), e.lineTo(b + P, _), e.quadraticCurveTo(b, _, b, _ + P), e.closePath(), (n.fillColor || 0 === n.fillColor) && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
            }
        }
    }, PIXI.CanvasGraphics.renderGraphicsMask = function (t, e) {
        var i = t.graphicsData.length;
        if (0 !== i) {
            e.beginPath();
            for (var s = 0; s < i; s++) {
                var n = t.graphicsData[s], r = n.shape;
                if (n.type === PIXI.Graphics.POLY) {
                    var o = r.points;
                    e.moveTo(o[0], o[1]);
                    for (var a = 1; a < o.length / 2; a++) e.lineTo(o[2 * a], o[2 * a + 1]);
                    o[0] === o[o.length - 2] && o[1] === o[o.length - 1] && e.closePath()
                } else if (n.type === PIXI.Graphics.RECT) e.rect(r.x, r.y, r.width, r.height), e.closePath(); else if (n.type === PIXI.Graphics.CIRC) e.arc(r.x, r.y, r.radius, 0, 2 * Math.PI), e.closePath(); else if (n.type === PIXI.Graphics.ELIP) {
                    var h = 2 * r.width, l = 2 * r.height, c = r.x - h / 2, u = r.y - l / 2, d = h / 2 * .5522848,
                        p = l / 2 * .5522848, f = c + h, g = u + l, m = c + h / 2, y = u + l / 2;
                    e.moveTo(c, y), e.bezierCurveTo(c, y - p, m - d, u, m, u), e.bezierCurveTo(m + d, u, f, y - p, f, y), e.bezierCurveTo(f, y + p, m + d, g, m, g), e.bezierCurveTo(m - d, g, c, y + p, c, y), e.closePath()
                } else if (n.type === PIXI.Graphics.RREC) {
                    var v = r.x, x = r.y, b = r.width, _ = r.height, w = r.radius, T = Math.min(b, _) / 2 | 0;
                    w = T < w ? T : w, e.moveTo(v, x + w), e.lineTo(v, x + _ - w), e.quadraticCurveTo(v, x + _, v + w, x + _), e.lineTo(v + b - w, x + _), e.quadraticCurveTo(v + b, x + _, v + b, x + _ - w), e.lineTo(v + b, x + w), e.quadraticCurveTo(v + b, x, v + b - w, x), e.lineTo(v + w, x), e.quadraticCurveTo(v, x, v, x + w), e.closePath()
                }
            }
        }
    }, PIXI.CanvasGraphics.updateGraphicsTint = function (t) {
        if (16777215 !== t.tint) for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
            var r = t.graphicsData[n], o = 0 | r.fillColor, a = 0 | r.lineColor;
            r._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255, r._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * s * 255
        }
    },j.Graphics = function (t, e, i) {
        void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = j.GRAPHICS, this.physicsType = j.SPRITE, this.anchor = new j.Point, PIXI.Graphics.call(this), j.Component.Core.init.call(this, t, e, i, "", null)
    },j.Graphics.prototype = Object.create(PIXI.Graphics.prototype),j.Graphics.prototype.constructor = j.Graphics,j.Component.Core.install.call(j.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),j.Graphics.prototype.preUpdatePhysics = j.Component.PhysicsBody.preUpdate,j.Graphics.prototype.preUpdateLifeSpan = j.Component.LifeSpan.preUpdate,j.Graphics.prototype.preUpdateInWorld = j.Component.InWorld.preUpdate,j.Graphics.prototype.preUpdateCore = j.Component.Core.preUpdate,j.Graphics.prototype.preUpdate = function () {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    },j.Graphics.prototype.postUpdate = function () {
        j.Component.PhysicsBody.postUpdate.call(this), j.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
    },j.Graphics.prototype.destroy = function (t) {
        this.clear(), j.Component.Destroy.prototype.destroy.call(this, t)
    },j.Graphics.prototype.drawTriangle = function (t, e) {
        void 0 === e && (e = !1);
        var i = new j.Polygon(t);
        if (e) {
            var s = new j.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                n = new j.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                r = new j.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(n);
            0 < s.dot(r) && this.drawPolygon(i)
        } else this.drawPolygon(i)
    },j.Graphics.prototype.drawTriangles = function (t, e, i) {
        void 0 === i && (i = !1);
        var s, n = new j.Point, r = new j.Point, o = new j.Point, a = [];
        if (e) if (t[0] instanceof j.Point) for (s = 0; s < e.length / 3; s++) a.push(t[e[3 * s]]), a.push(t[e[3 * s + 1]]), a.push(t[e[3 * s + 2]]), 3 === a.length && (this.drawTriangle(a, i), a = []); else for (s = 0; s < e.length; s++) n.x = t[2 * e[s]], n.y = t[2 * e[s] + 1], a.push(n.copyTo({})), 3 === a.length && (this.drawTriangle(a, i), a = []); else if (t[0] instanceof j.Point) for (s = 0; s < t.length / 3; s++) this.drawTriangle([t[3 * s], t[3 * s + 1], t[3 * s + 2]], i); else for (s = 0; s < t.length / 6; s++) n.x = t[6 * s + 0], n.y = t[6 * s + 1], r.x = t[6 * s + 2], r.y = t[6 * s + 3], o.x = t[6 * s + 4], o.y = t[6 * s + 5], this.drawTriangle([n, r, o], i)
    },j.RenderTexture = function (t, e, i, s, n, r) {
        void 0 === s && (s = ""), void 0 === n && (n = j.scaleModes.DEFAULT), void 0 === r && (r = 1), this.game = t, this.key = s, this.type = j.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, i, this.game.renderer, n, r), this.render = j.RenderTexture.prototype.render
    },j.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype),j.RenderTexture.prototype.constructor = j.RenderTexture,j.RenderTexture.prototype.renderXY = function (t, e, i, s) {
        t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, s) : this.renderCanvas(t, this._tempMatrix, s)
    },j.RenderTexture.prototype.renderRawXY = function (t, e, i, s) {
        this._tempMatrix.identity().translate(e, i), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, s) : this.renderCanvas(t, this._tempMatrix, s)
    },j.RenderTexture.prototype.render = function (t, e, i) {
        null == e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, i) : this.renderCanvas(t, this._tempMatrix, i)
    },j.Text = function (t, e, i, s, n) {
        e = e || 0, i = i || 0, s = null == s ? "" : s.toString(), n = j.Utils.extend({}, n), this.type = j.TEXT, this.physicsType = j.SPRITE, this.padding = new j.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = s, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, j.Sprite.call(this, t, e, i, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(n), "" !== s && this.updateText()
    },j.Text.prototype = Object.create(j.Sprite.prototype),j.Text.prototype.constructor = j.Text,j.Text.prototype.preUpdate = function () {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    },j.Text.prototype.update = function () {
    },j.Text.prototype.destroy = function (t) {
        this.texture.destroy(!0), j.Component.Destroy.prototype.destroy.call(this, t)
    },j.Text.prototype.setShadow = function (t, e, i, s, n, r) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === s && (s = 0), void 0 === n && (n = !0), void 0 === r && (r = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = s, this.style.shadowStroke = n, this.style.shadowFill = r, this.dirty = !0, this
    },j.Text.prototype.setStyle = function (t, e) {
        void 0 === e && (e = !1), (t = t || {}).font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0;
        var i = this.fontToComponents(t.font);
        return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this
    },j.Text.prototype.updateText = function () {
        this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
        var t = this.text;
        this.style.wordWrap && (t = this.runWordWrap(this.text));
        var e = t.split(/(?:\r\n|\r|\n)/), i = this.style.tabs, s = [], n = 0,
            r = this.determineFontProperties(this.style.font), o = e.length;
        0 < this.style.maxLines && this.style.maxLines < e.length && (o = this.style.maxLines);
        for (var a = this._charCount = 0; a < o; a++) {
            if (0 === i) {
                var h = this.style.strokeThickness + this.padding.x;
                0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? h += this.measureLine(e[a]) : h += this.context.measureText(e[a]).width, this.style.wordWrap && (h -= this.context.measureText(" ").width)
            } else {
                var l = e[a].split(/(?:\t)/);
                h = this.padding.x + this.style.strokeThickness;
                if (Array.isArray(i)) for (var c = 0, u = 0; u < l.length; u++) {
                    var d = 0;
                    d = 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.measureLine(l[u]) : Math.ceil(this.context.measureText(l[u]).width), 0 < u && (c += i[u - 1]), h = c + d
                } else for (u = 0; u < l.length; u++) {
                    0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? h += this.measureLine(l[u]) : h += Math.ceil(this.context.measureText(l[u]).width), h += this.game.math.snapToCeil(h, i) - h
                }
            }
            s[a] = Math.ceil(h), n = Math.max(n, s[a])
        }
        this.canvas.width = n * this._res;
        var p, f, g = r.fontSize + this.style.strokeThickness + this.padding.y, m = g * o, y = this._lineSpacing;
        for (y < 0 && Math.abs(y) > g && (y = -g), 0 !== y && (m += 0 < y ? y * e.length : y * (e.length - 1)), this.canvas.height = m * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round", a = this._charCount = 0; a < o; a++) p = this.style.strokeThickness / 2, f = this.style.strokeThickness / 2 + a * g + r.ascent, 0 < a && (f += y * a), "right" === this.style.align ? p += n - s[a] : "center" === this.style.align && (p += (n - s[a]) / 2), this.autoRound && (p = Math.round(p), f = Math.round(f)), 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.updateLine(e[a], p, f) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], p, f) : this.renderTabLine(e[a], p, f, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], p, f) : this.renderTabLine(e[a], p, f, !0)));
        this.updateTexture(), this.dirty = !1
    },j.Text.prototype.renderTabLine = function (t, e, i, s) {
        var n = t.split(/(?:\t)/), r = this.style.tabs, o = 0;
        if (Array.isArray(r)) for (var a = 0, h = 0; h < n.length; h++) 0 < h && (a += r[h - 1]), o = e + a, s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i); else for (h = 0; h < n.length; h++) {
            var l = Math.ceil(this.context.measureText(n[h]).width);
            o = this.game.math.snapToCeil(e, r), s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i), e = o + l
        }
    },j.Text.prototype.updateShadow = function (t) {
        this.context.shadowBlur = t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0)
    },j.Text.prototype.measureLine = function (t) {
        for (var e = 0, i = 0; i < t.length; i++) {
            var s = t[i];
            if (0 < this.fontWeights.length || 0 < this.fontStyles.length) {
                var n = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(s).width, this._charCount++
        }
        return Math.ceil(e)
    },j.Text.prototype.updateLine = function (t, e, i) {
        for (var s = 0; s < t.length; s++) {
            var n = t[s];
            if (0 < this.fontWeights.length || 0 < this.fontStyles.length) {
                var r = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(r)
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(n, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(n, e, i)), e += this.context.measureText(n).width, this._charCount++
        }
    },j.Text.prototype.clearColors = function () {
        return this.colors = [], this.strokeColors = [], this.dirty = !0, this
    },j.Text.prototype.clearFontValues = function () {
        return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
    },j.Text.prototype.addColor = function (t, e) {
        return this.colors[e] = t, this.dirty = !0, this
    },j.Text.prototype.addStrokeColor = function (t, e) {
        return this.strokeColors[e] = t, this.dirty = !0, this
    },j.Text.prototype.addFontStyle = function (t, e) {
        return this.fontStyles[e] = t, this.dirty = !0, this
    },j.Text.prototype.addFontWeight = function (t, e) {
        return this.fontWeights[e] = t, this.dirty = !0, this
    },j.Text.prototype.precalculateWordWrap = function (t) {
        return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
    },j.Text.prototype.runWordWrap = function (t) {
        return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
    },j.Text.prototype.advancedWordWrap = function (t) {
        for (var e = this.context, i = this.style.wordWrapWidth, s = "", n = t.replace(/ +/gi, " ").split(/\r?\n/gi), r = n.length, o = 0; o < r; o++) {
            var a = n[o], h = "";
            if (a = a.replace(/^ *|\s*$/gi, ""), e.measureText(a).width < i) s += a + "\n"; else {
                for (var l = i, c = a.split(" "), u = 0; u < c.length; u++) {
                    var d = c[u], p = d + " ", f = e.measureText(p).width;
                    if (l < f) {
                        if (0 === u) {
                            for (var g = p; g.length && (g = g.slice(0, -1), !((f = e.measureText(g).width) <= l));) ;
                            if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                            var m = d.substr(g.length);
                            c[u] = m, h += g
                        }
                        var y = c[u].length ? u : u + 1, v = c.slice(y).join(" ").replace(/[ \n]*$/gi, "");
                        n[o + 1] = v + " " + (n[o + 1] || ""), r = n.length;
                        break
                    }
                    h += p, l -= f
                }
                s += h.replace(/[ \n]*$/gi, "") + "\n"
            }
        }
        return s = s.replace(/[\s|\n]*$/gi, "")
    },j.Text.prototype.basicWordWrap = function (t) {
        for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
            for (var n = this.style.wordWrapWidth, r = i[s].split(" "), o = 0; o < r.length; o++) {
                var a = this.context.measureText(r[o]).width, h = a + this.context.measureText(" ").width;
                n < h ? (0 < o && (e += "\n"), e += r[o] + " ", n = this.style.wordWrapWidth - a) : (n -= h, e += r[o] + " ")
            }
            s < i.length - 1 && (e += "\n")
        }
        return e
    },j.Text.prototype.updateFont = function (t) {
        var e = this.componentsToFont(t);
        this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
    },j.Text.prototype.fontToComponents = function (t) {
        var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
        if (e) {
            var i = e[5].trim();
            return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                font: t,
                fontStyle: e[1] || "normal",
                fontVariant: e[2] || "normal",
                fontWeight: e[3] || "normal",
                fontSize: e[4] || "medium",
                fontFamily: i
            }
        }
        return console.warn("Phaser.Text - unparsable CSS font: " + t), {font: t}
    },j.Text.prototype.componentsToFont = function (t) {
        var e, i = [];
        return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ")
    },j.Text.prototype.setText = function (t, e) {
        return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
    },j.Text.prototype.parseList = function (t) {
        if (!Array.isArray(t)) return this;
        for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
        return this.text = e, this.dirty = !0, this
    },j.Text.prototype.setTextBounds = function (t, e, i, s) {
        return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, i, s) : this.textBounds = new j.Rectangle(t, e, i, s), this.style.wordWrapWidth > i && (this.style.wordWrapWidth = i)), this.updateTexture(), this
    },j.Text.prototype.updateTexture = function () {
        var t = this.texture.baseTexture, e = this.texture.crop, i = this.texture.frame, s = this.canvas.width,
            n = this.canvas.height;
        if (t.width = s, t.height = n, e.width = s, e.height = n, i.width = s, i.height = n, this.texture.width = s, this.texture.height = n, this._width = s, this._height = n, this.textBounds) {
            var r = this.textBounds.x, o = this.textBounds.y;
            "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -r, this.pivot.y = -o
        }
        this.renderable = 0 !== s && 0 !== n, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
    },j.Text.prototype._renderWebGL = function (t) {
        this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
    },j.Text.prototype._renderCanvas = function (t) {
        this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
    },j.Text.prototype.determineFontProperties = function (t) {
        var e = j.Text.fontPropertiesCache[t];
        if (!e) {
            e = {};
            var i = j.Text.fontPropertiesCanvas, s = j.Text.fontPropertiesContext;
            s.font = t;
            var n = Math.ceil(s.measureText("|Mq").width), r = Math.ceil(s.measureText("|Mq").width), o = 2 * r;
            if (r = 1.4 * r | 0, i.width = n, i.height = o, s.fillStyle = "#f00", s.fillRect(0, 0, n, o), s.font = t, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText("|Mq", 0, r), !s.getImageData(0, 0, n, o)) return e.ascent = r, e.descent = r + 6, e.fontSize = e.ascent + e.descent, j.Text.fontPropertiesCache[t] = e;
            var a, h, l = s.getImageData(0, 0, n, o).data, c = l.length, u = 4 * n, d = 0, p = !1;
            for (a = 0; a < r; a++) {
                for (h = 0; h < u; h += 4) if (255 !== l[d + h]) {
                    p = !0;
                    break
                }
                if (p) break;
                d += u
            }
            for (e.ascent = r - a, d = c - u, p = !1, a = o; r < a; a--) {
                for (h = 0; h < u; h += 4) if (255 !== l[d + h]) {
                    p = !0;
                    break
                }
                if (p) break;
                d -= u
            }
            e.descent = a - r, e.descent += 6, e.fontSize = e.ascent + e.descent, j.Text.fontPropertiesCache[t] = e
        }
        return e
    },j.Text.prototype.getBounds = function (t) {
        return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
    },Object.defineProperty(j.Text.prototype, "text", {
        get: function () {
            return this._text
        }, set: function (t) {
            t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
        }
    }),Object.defineProperty(j.Text.prototype, "cssFont", {
        get: function () {
            return this.componentsToFont(this._fontComponents)
        }, set: function (t) {
            t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
        }
    }),Object.defineProperty(j.Text.prototype, "font", {
        get: function () {
            return this._fontComponents.fontFamily
        }, set: function (t) {
            t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
        }
    }),Object.defineProperty(j.Text.prototype, "fontSize", {
        get: function () {
            var t = this._fontComponents.fontSize;
            return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
        }, set: function (t) {
            "number" == typeof (t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
        }
    }),Object.defineProperty(j.Text.prototype, "fontWeight", {
        get: function () {
            return this._fontComponents.fontWeight || "normal"
        }, set: function (t) {
            t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
        }
    }),Object.defineProperty(j.Text.prototype, "fontStyle", {
        get: function () {
            return this._fontComponents.fontStyle || "normal"
        }, set: function (t) {
            t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
        }
    }),Object.defineProperty(j.Text.prototype, "fontVariant", {
        get: function () {
            return this._fontComponents.fontVariant || "normal"
        }, set: function (t) {
            t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
        }
    }),Object.defineProperty(j.Text.prototype, "fill", {
        get: function () {
            return this.style.fill
        }, set: function (t) {
            t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "align", {
        get: function () {
            return this.style.align
        }, set: function (t) {
            t !== this.style.align && (this.style.align = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "resolution", {
        get: function () {
            return this._res
        }, set: function (t) {
            t !== this._res && (this._res = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "tabs", {
        get: function () {
            return this.style.tabs
        }, set: function (t) {
            t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "boundsAlignH", {
        get: function () {
            return this.style.boundsAlignH
        }, set: function (t) {
            t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "boundsAlignV", {
        get: function () {
            return this.style.boundsAlignV
        }, set: function (t) {
            t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "stroke", {
        get: function () {
            return this.style.stroke
        }, set: function (t) {
            t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "strokeThickness", {
        get: function () {
            return this.style.strokeThickness
        }, set: function (t) {
            t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "wordWrap", {
        get: function () {
            return this.style.wordWrap
        }, set: function (t) {
            t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "wordWrapWidth", {
        get: function () {
            return this.style.wordWrapWidth
        }, set: function (t) {
            t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "lineSpacing", {
        get: function () {
            return this._lineSpacing
        }, set: function (t) {
            t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
        }
    }),Object.defineProperty(j.Text.prototype, "shadowOffsetX", {
        get: function () {
            return this.style.shadowOffsetX
        }, set: function (t) {
            t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "shadowOffsetY", {
        get: function () {
            return this.style.shadowOffsetY
        }, set: function (t) {
            t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "shadowColor", {
        get: function () {
            return this.style.shadowColor
        }, set: function (t) {
            t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "shadowBlur", {
        get: function () {
            return this.style.shadowBlur
        }, set: function (t) {
            t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "shadowStroke", {
        get: function () {
            return this.style.shadowStroke
        }, set: function (t) {
            t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "shadowFill", {
        get: function () {
            return this.style.shadowFill
        }, set: function (t) {
            t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
        }
    }),Object.defineProperty(j.Text.prototype, "width", {
        get: function () {
            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
        }, set: function (t) {
            this.scale.x = t / this.texture.frame.width, this._width = t
        }
    }),Object.defineProperty(j.Text.prototype, "height", {
        get: function () {
            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
        }, set: function (t) {
            this.scale.y = t / this.texture.frame.height, this._height = t
        }
    }),j.Text.fontPropertiesCache = {},j.Text.fontPropertiesCanvas = document.createElement("canvas"),j.Text.fontPropertiesContext = j.Text.fontPropertiesCanvas.getContext("2d"),j.TileSprite = function () {
    },j.Device = function () {
        this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
    },j.Device = new j.Device,j.Device.onInitialized = new j.Signal,j.Device.whenReady = function (t, e, i) {
        var s = this._readyCheck;
        if (this.deviceReadyAt || !s) t.call(e, this); else if (s._monitor || i) s._queue = s._queue || [], s._queue.push([t, e]); else {
            s._monitor = s.bind(this), s._queue = s._queue || [], s._queue.push([t, e]);
            var n = void 0 !== window.cordova, r = navigator.isCocoonJS;
            "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : n && !r ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1))
        }
    },j.Device._readyCheck = function () {
        var t = this._readyCheck;
        if (document.body) {
            if (!this.deviceReadyAt) {
                var e;
                for (this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this); e = t._queue.shift();) {
                    var i = e[0], s = e[1];
                    i.call(s, this)
                }
                this._readyCheck = null, this._initialize = null, this.onInitialized = null
            }
        } else window.setTimeout(t._monitor, 20)
    },j.Device._initialize = function () {
        var t, e, i, n = this;
        !function () {
            var t = navigator.userAgent;
            /Playstation Vita/.test(t) ? n.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? n.kindle = !0 : /Android/.test(t) ? n.android = !0 : /CrOS/.test(t) ? n.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (n.iOS = !0, navigator.appVersion.match(/OS (\d+)/), n.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? n.linux = !0 : /Mac OS/.test(t) ? n.macOS = !0 : /Windows/.test(t) && (n.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (n.android = !1, n.iOS = !1, n.macOS = !1, n.windows = !0, n.windowsPhone = !0);
            var e = /Silk/.test(t);
            (n.windows || n.macOS || n.linux && !e || n.chromeOS) && (n.desktop = !0), (n.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (n.desktop = !1)
        }(), function () {
            var t = navigator.userAgent;
            if (/Arora/.test(t) ? n.arora = !0 : /Edge\/\d+/.test(t) ? n.edge = !0 : /Chrome\/(\d+)/.test(t) && !n.windowsPhone ? (n.chrome = !0, n.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? n.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (n.firefox = !0, n.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && n.iOS ? n.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (n.ie = !0, n.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? n.midori = !0 : /Opera/.test(t) ? n.opera = !0 : /Safari\/(\d+)/.test(t) && !n.windowsPhone ? (n.safari = !0, /Version\/(\d+)\./.test(t) && (n.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (n.ie = !0, n.trident = !0, n.tridentVersion = parseInt(RegExp.$1, 10), n.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (n.silk = !0), navigator.standalone && (n.webApp = !0), void 0 !== window.cordova && (n.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (n.node = !0), n.node && "object" == typeof process.versions && (n.nodeWebkit = !!process.versions["node-webkit"], n.electron = !!process.versions.electron), navigator.isCocoonJS && (n.cocoonJS = !0), n.cocoonJS) try {
                n.cocoonJSApp = "undefined" != typeof CocoonJS
            } catch (t) {
                n.cocoonJSApp = !1
            }
            void 0 !== window.ejecta && (n.ejecta = !0), /Crosswalk/.test(t) && (n.crosswalk = !0)
        }(), function () {
            n.audioData = !!window.Audio, n.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
            var t = document.createElement("audio");
            try {
                if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (n.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (n.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (n.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (n.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (n.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (n.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"'))) if (n.edge) n.dolby = !0; else if (n.safari && 9 <= n.safariVersion && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                    var e = parseInt(RegExp.$1, 10), i = parseInt(RegExp.$2, 10);
                    (10 === e && 11 <= i || 10 < e) && (n.dolby = !0)
                }
            } catch (t) {
            }
        }(), function () {
            var t = document.createElement("video");
            try {
                t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (n.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.h264Video = !0, n.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (n.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (n.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.hlsVideo = !0))
            } catch (t) {
            }
        }(), function () {
            var t, e = document.createElement("p"), i = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            for (var s in document.body.insertBefore(e, null), i) void 0 !== e.style[s] && (e.style[s] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(i[s]));
            document.body.removeChild(e), n.css3D = void 0 !== t && 0 < t.length && "none" !== t
        }(), n.pixelRatio = window.devicePixelRatio || 1, n.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), n.iPhone4 = 2 === n.pixelRatio && n.iPhone, n.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? n.typedArray = !0 : n.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (n.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null), n.LITTLE_ENDIAN = n.littleEndian), n.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== n.littleEndian && function () {
            if (void 0 === Uint8ClampedArray) return !1;
            var t = PIXI.CanvasPool.create(this, 1, 1).getContext("2d");
            if (!t) return !1;
            var e = t.createImageData(1, 1);
            return PIXI.CanvasPool.remove(this), e.data instanceof Uint8ClampedArray
        }(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (n.vibration = !0), function () {
            n.canvas = !!window.CanvasRenderingContext2D || n.cocoonJS;
            try {
                n.localStorage = !!localStorage.getItem
            } catch (t) {
                n.localStorage = !1
            }
            n.file = !!(window.File && window.FileReader && window.FileList && window.Blob), n.fileSystem = !!window.requestFileSystem, n.webGL = function () {
                try {
                    var t = document.createElement("canvas");
                    return t.screencanvas = !1, !!window.WebGLRenderingContext && (t.getContext("webgl") || t.getContext("experimental-webgl"))
                } catch (t) {
                    return !1
                }
            }(), n.webGL = !!n.webGL, n.worker = !!window.Worker, n.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, n.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, n.getUserMedia = n.getUserMedia && !!navigator.getUserMedia && !!window.URL, n.firefox && n.firefoxVersion < 21 && (n.getUserMedia = !1), !n.iOS && (n.ie || n.firefox || n.chrome) && (n.canvasBitBltShift = !0), (n.safari || n.mobileSafari) && (n.canvasBitBltShift = !1)
        }(), function () {
            for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++) if (e[t[i]]) {
                n.fullscreen = !0, n.requestFullscreen = t[i];
                break
            }
            var s = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
            if (n.fullscreen) for (i = 0; i < s.length; i++) if (document[s[i]]) {
                n.cancelFullscreen = s[i];
                break
            }
            window.Element && Element.ALLOW_KEYBOARD_INPUT && (n.fullscreenKeyboard = !0)
        }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && 1 <= window.navigator.maxTouchPoints) && (n.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (n.mspointer = !0), n.cocoonJS || ("onwheel" in window || n.ie && "WheelEvent" in window ? n.wheelEvent = "wheel" : "onmousewheel" in window ? n.wheelEvent = "mousewheel" : n.firefox && "MouseScrollEvent" in window && (n.wheelEvent = "DOMMouseScroll"))
    },j.Device.canPlayAudio = function (t) {
        return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
    },j.Device.canPlayVideo = function (t) {
        return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
    },j.Device.isConsoleOpen = function () {
        return !(!window.console || !window.console.firebug) || !(!window.console || (console.profile(), console.profileEnd(), console.clear && console.clear(), !console.profiles)) && 0 < console.profiles.length
    },j.Device.isAndroidStockBrowser = function () {
        var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return t && t[1] < 537
    },j.Canvas = {
        create: function (t, e, i, s, n) {
            e = e || 256, i = i || 256;
            var r = n ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i);
            return "string" == typeof s && "" !== s && (r.id = s), r.width = e, r.height = i, r.style.display = "block", r
        }, setBackgroundColor: function (t, e) {
            return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
        }, setTouchAction: function (t, e) {
            return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
        }, setUserSelect: function (t, e) {
            return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
        }, addToDOM: function (t, e, i) {
            var s;
            return void 0 === i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s || (s = document.body), i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
        }, removeFromDOM: function (t) {
            t.parentNode && t.parentNode.removeChild(t)
        }, setTransform: function (t, e, i, s, n, r, o) {
            return t.setTransform(s, r, o, n, e, i), t
        }, setSmoothingEnabled: function (t, e) {
            var i = j.Canvas.getSmoothingPrefix(t);
            return i && (t[i] = e), t
        }, getSmoothingPrefix: function (t) {
            var e = ["i", "webkitI", "msI", "mozI", "oI"];
            for (var i in e) {
                var s = e[i] + "mageSmoothingEnabled";
                if (s in t) return s
            }
            return null
        }, getSmoothingEnabled: function (t) {
            var e = j.Canvas.getSmoothingPrefix(t);
            if (e) return t[e]
        }, setImageRenderingCrisp: function (t) {
            for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
            return t.style.msInterpolationMode = "nearest-neighbor", t
        }, setImageRenderingBicubic: function (t) {
            return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
        }
    },j.RequestAnimationFrame = function (t, e) {
        void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
        for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"];
        this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
    },j.RequestAnimationFrame.prototype = {
        start: function () {
            this.isRunning = !0;
            var e = this;
            !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function () {
                return e.updateSetTimeout()
            }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function (t) {
                return e.updateRAF(t)
            }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
        }, updateRAF: function (t) {
            this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
        }, updateSetTimeout: function () {
            this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
        }, stop: function () {
            this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
        }, isSetTimeOut: function () {
            return this._isSetTimeOut
        }, isRAF: function () {
            return !1 === this._isSetTimeOut
        }
    },j.RequestAnimationFrame.prototype.constructor = j.RequestAnimationFrame,j.Math = {
        PI2: 2 * Math.PI, between: function (t, e) {
            return Math.floor(Math.random() * (e - t + 1) + t)
        }, fuzzyEqual: function (t, e, i) {
            return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
        }, fuzzyLessThan: function (t, e, i) {
            return void 0 === i && (i = 1e-4), t < e + i
        }, fuzzyGreaterThan: function (t, e, i) {
            return void 0 === i && (i = 1e-4), e - i < t
        }, fuzzyCeil: function (t, e) {
            return void 0 === e && (e = 1e-4), Math.ceil(t - e)
        }, fuzzyFloor: function (t, e) {
            return void 0 === e && (e = 1e-4), Math.floor(t + e)
        }, average: function () {
            for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
            return t / e
        }, shear: function (t) {
            return t % 1
        }, snapTo: function (t, e, i) {
            return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.round(t / e)))
        }, snapToFloor: function (t, e, i) {
            return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.floor(t / e)))
        }, snapToCeil: function (t, e, i) {
            return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.ceil(t / e)))
        }, roundTo: function (t, e, i) {
            void 0 === e && (e = 0), void 0 === i && (i = 10);
            var s = Math.pow(i, -e);
            return Math.round(t * s) / s
        }, floorTo: function (t, e, i) {
            void 0 === e && (e = 0), void 0 === i && (i = 10);
            var s = Math.pow(i, -e);
            return Math.floor(t * s) / s
        }, ceilTo: function (t, e, i) {
            void 0 === e && (e = 0), void 0 === i && (i = 10);
            var s = Math.pow(i, -e);
            return Math.ceil(t * s) / s
        }, rotateToAngle: function (t, e, i) {
            return void 0 === i && (i = .05), t === e || (Math.abs(e - t) <= i || Math.abs(e - t) >= j.Math.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += j.Math.PI2 : e -= j.Math.PI2), t < e ? t += i : e < t && (t -= i))), t
        }, getShortestAngle: function (t, e) {
            var i = e - t;
            return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
        }, angleBetween: function (t, e, i, s) {
            return Math.atan2(s - e, i - t)
        }, angleBetweenY: function (t, e, i, s) {
            return Math.atan2(i - t, s - e)
        }, angleBetweenPoints: function (t, e) {
            return Math.atan2(e.y - t.y, e.x - t.x)
        }, angleBetweenPointsY: function (t, e) {
            return Math.atan2(e.x - t.x, e.y - t.y)
        }, reverseAngle: function (t) {
            return this.normalizeAngle(t + Math.PI, !0)
        }, normalizeAngle: function (t) {
            return 0 <= (t %= 2 * Math.PI) ? t : t + 2 * Math.PI
        }, maxAdd: function (t, e, i) {
            return Math.min(t + e, i)
        }, minSub: function (t, e, i) {
            return Math.max(t - e, i)
        }, wrap: function (t, e, i) {
            var s = i - e;
            if (s <= 0) return 0;
            var n = (t - e) % s;
            return n < 0 && (n += s), n + e
        }, wrapValue: function (t, e, i) {
            return ((t = Math.abs(t)) + (e = Math.abs(e))) % (i = Math.abs(i))
        }, isOdd: function (t) {
            return !!(1 & t)
        }, isEven: function (t) {
            return !(1 & t)
        }, min: function () {
            if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0]; else t = arguments;
            for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] < t[i] && (i = e);
            return t[i]
        }, max: function () {
            if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0]; else t = arguments;
            for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] > t[i] && (i = e);
            return t[i]
        }, minProperty: function (t) {
            if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1]; else e = arguments.slice(1);
            for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] < e[s][t] && (s = i);
            return e[s][t]
        }, maxProperty: function (t) {
            if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1]; else e = arguments.slice(1);
            for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] > e[s][t] && (s = i);
            return e[s][t]
        }, wrapAngle: function (t, e) {
            return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
        }, linearInterpolation: function (t, e) {
            var i = t.length - 1, s = i * e, n = Math.floor(s);
            return e < 0 ? this.linear(t[0], t[1], s) : 1 < e ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[i < n + 1 ? i : n + 1], s - n)
        }, bezierInterpolation: function (t, e) {
            for (var i = 0, s = t.length - 1, n = 0; n <= s; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
            return i
        }, catmullRomInterpolation: function (t, e) {
            var i = t.length - 1, s = i * e, n = Math.floor(s);
            return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : 1 < e ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], s - n)
        }, linear: function (t, e, i) {
            return (e - t) * i + t
        }, bernstein: function (t, e) {
            return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
        }, factorial: function (t) {
            if (0 === t) return 1;
            for (var e = t; --t;) e *= t;
            return e
        }, catmullRom: function (t, e, i, s, n) {
            var r = .5 * (i - t), o = .5 * (s - e), a = n * n;
            return (2 * e - 2 * i + r + o) * (n * a) + (-3 * e + 3 * i - 2 * r - o) * a + r * n + e
        }, difference: function (t, e) {
            return Math.abs(t - e)
        }, roundAwayFromZero: function (t) {
            return 0 < t ? Math.ceil(t) : Math.floor(t)
        }, sinCosGenerator: function (t, e, i, s) {
            void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1);
            for (var n = e, r = i, o = s * Math.PI / t, a = [], h = [], l = 0; l < t; l++) n += (r -= n * o) * o, a[l] = r, h[l] = n;
            return {sin: h, cos: a, length: t}
        }, distance: function (t, e, i, s) {
            var n = t - i, r = e - s;
            return Math.sqrt(n * n + r * r)
        }, distanceSq: function (t, e, i, s) {
            var n = t - i, r = e - s;
            return n * n + r * r
        }, distancePow: function (t, e, i, s, n) {
            return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
        }, clamp: function (t, e, i) {
            return t < e ? e : i < t ? i : t
        }, clampBottom: function (t, e) {
            return t < e ? e : t
        }, within: function (t, e, i) {
            return Math.abs(t - e) <= i
        }, mapLinear: function (t, e, i, s, n) {
            return s + (t - e) * (n - s) / (i - e)
        }, smoothstep: function (t, e, i) {
            return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
        }, smootherstep: function (t, e, i) {
            return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
        }, sign: function (t) {
            return t < 0 ? -1 : 0 < t ? 1 : 0
        }, percent: function (t, e, i) {
            return void 0 === i && (i = 0), e < t || e < i ? 1 : t < i || t < i ? 0 : (t - i) / e
        }
    };
    var n = Math.PI / 180, o = 180 / Math.PI;
    return j.Math.degToRad = function (t) {
        return t * n
    }, j.Math.radToDeg = function (t) {
        return t * o
    }, j.RandomDataGenerator = function (t) {
        void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
    }, j.RandomDataGenerator.prototype = {
        rnd: function () {
            var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
            return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
        }, sow: function (t) {
            if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t) for (var e = 0; e < t.length && null != t[e]; e++) {
                var i = t[e];
                this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
            }
        }, hash: function (t) {
            var e, i, s;
            for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (s += t.charCodeAt(i)), e -= s = e >>> 0, s = (e *= s) >>> 0, s += 4294967296 * (e -= s);
            return 2.3283064365386963e-10 * (s >>> 0)
        }, integer: function () {
            return 4294967296 * this.rnd.apply(this)
        }, frac: function () {
            return this.rnd.apply(this) + 11102230246251565e-32 * (2097152 * this.rnd.apply(this) | 0)
        }, real: function () {
            return this.integer() + this.frac()
        }, integerInRange: function (t, e) {
            return Math.floor(this.realInRange(0, e - t + 1) + t)
        }, between: function (t, e) {
            return this.integerInRange(t, e)
        }, realInRange: function (t, e) {
            return this.frac() * (e - t) + t
        }, normal: function () {
            return 1 - 2 * this.frac()
        }, uuid: function () {
            var t = "", e = "";
            for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-") ;
            return e
        }, pick: function (t) {
            return t[this.integerInRange(0, t.length - 1)]
        }, sign: function () {
            return this.pick([-1, 1])
        }, weightedPick: function (t) {
            return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
        }, timestamp: function (t, e) {
            return this.realInRange(t || 9466848e5, e || 1577862e6)
        }, angle: function () {
            return this.integerInRange(-180, 180)
        }, state: function (t) {
            return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
        }
    }, j.RandomDataGenerator.prototype.constructor = j.RandomDataGenerator, j.QuadTree = function (t, e, i, s, n, r, o) {
        this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, n, r, o)
    }, j.QuadTree.prototype = {
        reset: function (t, e, i, s, n, r, o) {
            this.maxObjects = n || 10, this.maxLevels = r || 4, this.level = o || 0, this.bounds = {
                x: Math.round(t),
                y: Math.round(e),
                width: i,
                height: s,
                subWidth: Math.floor(i / 2),
                subHeight: Math.floor(s / 2),
                right: Math.round(t) + Math.floor(i / 2),
                bottom: Math.round(e) + Math.floor(s / 2)
            }, this.objects.length = 0, this.nodes.length = 0
        }, populate: function (t) {
            t.forEach(this.populateHandler, this, !0)
        }, populateHandler: function (t) {
            t.body && t.exists && this.insert(t.body)
        }, split: function () {
            this.nodes[0] = new j.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new j.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new j.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new j.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
        }, insert: function (t) {
            var e, i = 0;
            if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels) for (null == this.nodes[0] && this.split(); i < this.objects.length;) -1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
            } else this.nodes[e].insert(t)
        }, getIndex: function (t) {
            var e = -1;
            return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
        }, retrieve: function (t) {
            if (t instanceof j.Rectangle) var e = this.objects, i = this.getIndex(t); else {
                if (!t.body) return this._empty;
                e = this.objects, i = this.getIndex(t.body)
            }
            return this.nodes[0] && (e = -1 !== i ? e.concat(this.nodes[i].retrieve(t)) : (e = (e = (e = e.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))), e
        }, clear: function () {
            this.objects.length = 0;
            for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
            this.nodes.length = 0
        }
    }, j.QuadTree.prototype.constructor = j.QuadTree, j.Net = function (t) {
        this.game = t
    }, j.Net.prototype = {
        getHostName: function () {
            return window.location && window.location.hostname ? window.location.hostname : null
        }, checkDomainName: function (t) {
            return -1 !== window.location.hostname.indexOf(t)
        }, updateQueryString: function (t, e, i, s) {
            void 0 === i && (i = !1), void 0 !== s && "" !== s || (s = window.location.href);
            var n = "", r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
            if (r.test(s)) n = null != e ? s.replace(r, "$1" + t + "=" + e + "$2$3") : s.replace(r, "$1$3").replace(/(&|\?)$/, ""); else if (null != e) {
                var o = -1 !== s.indexOf("?") ? "&" : "?", a = s.split("#");
                s = a[0] + o + t + "=" + e, a[1] && (s += "#" + a[1]), n = s
            } else n = s;
            if (!i) return n;
            window.location.href = n
        }, getQueryString: function (t) {
            void 0 === t && (t = "");
            var e = {}, i = location.search.substring(1).split("&");
            for (var s in i) {
                var n = i[s].split("=");
                if (1 < n.length) {
                    if (t && t === this.decodeURI(n[0])) return this.decodeURI(n[1]);
                    e[this.decodeURI(n[0])] = this.decodeURI(n[1])
                }
            }
            return e
        }, decodeURI: function (t) {
            return decodeURIComponent(t.replace(/\+/g, " "))
        }
    }, j.Net.prototype.constructor = j.Net, j.TweenManager = function (t) {
        this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
            Power0: j.Easing.Power0,
            Power1: j.Easing.Power1,
            Power2: j.Easing.Power2,
            Power3: j.Easing.Power3,
            Power4: j.Easing.Power4,
            Linear: j.Easing.Linear.None,
            Quad: j.Easing.Quadratic.Out,
            Cubic: j.Easing.Cubic.Out,
            Quart: j.Easing.Quartic.Out,
            Quint: j.Easing.Quintic.Out,
            Sine: j.Easing.Sinusoidal.Out,
            Expo: j.Easing.Exponential.Out,
            Circ: j.Easing.Circular.Out,
            Elastic: j.Easing.Elastic.Out,
            Back: j.Easing.Back.Out,
            Bounce: j.Easing.Bounce.Out,
            "Quad.easeIn": j.Easing.Quadratic.In,
            "Cubic.easeIn": j.Easing.Cubic.In,
            "Quart.easeIn": j.Easing.Quartic.In,
            "Quint.easeIn": j.Easing.Quintic.In,
            "Sine.easeIn": j.Easing.Sinusoidal.In,
            "Expo.easeIn": j.Easing.Exponential.In,
            "Circ.easeIn": j.Easing.Circular.In,
            "Elastic.easeIn": j.Easing.Elastic.In,
            "Back.easeIn": j.Easing.Back.In,
            "Bounce.easeIn": j.Easing.Bounce.In,
            "Quad.easeOut": j.Easing.Quadratic.Out,
            "Cubic.easeOut": j.Easing.Cubic.Out,
            "Quart.easeOut": j.Easing.Quartic.Out,
            "Quint.easeOut": j.Easing.Quintic.Out,
            "Sine.easeOut": j.Easing.Sinusoidal.Out,
            "Expo.easeOut": j.Easing.Exponential.Out,
            "Circ.easeOut": j.Easing.Circular.Out,
            "Elastic.easeOut": j.Easing.Elastic.Out,
            "Back.easeOut": j.Easing.Back.Out,
            "Bounce.easeOut": j.Easing.Bounce.Out,
            "Quad.easeInOut": j.Easing.Quadratic.InOut,
            "Cubic.easeInOut": j.Easing.Cubic.InOut,
            "Quart.easeInOut": j.Easing.Quartic.InOut,
            "Quint.easeInOut": j.Easing.Quintic.InOut,
            "Sine.easeInOut": j.Easing.Sinusoidal.InOut,
            "Expo.easeInOut": j.Easing.Exponential.InOut,
            "Circ.easeInOut": j.Easing.Circular.InOut,
            "Elastic.easeInOut": j.Easing.Elastic.InOut,
            "Back.easeInOut": j.Easing.Back.InOut,
            "Bounce.easeInOut": j.Easing.Bounce.InOut
        }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
    }, j.TweenManager.prototype = {
        getAll: function () {
            return this._tweens
        }, removeAll: function () {
            for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
            this._add = []
        }, removeFrom: function (t, e) {
            if (void 0 === e && (e = !0), Array.isArray(t)) for (i = 0, s = t.length; i < s; i++) this.removeFrom(t[i]); else if (t.type === j.GROUP && e) for (var i = 0, s = t.children.length; i < s; i++) this.removeFrom(t.children[i]); else {
                for (i = 0, s = this._tweens.length; i < s; i++) t === this._tweens[i].target && this.remove(this._tweens[i]);
                for (i = 0, s = this._add.length; i < s; i++) t === this._add[i].target && this.remove(this._add[i])
            }
        }, add: function (t) {
            (t._manager = this)._add.push(t)
        }, create: function (t) {
            return new j.Tween(t, this.game, this)
        }, remove: function (t) {
            var e = this._tweens.indexOf(t);
            -1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
        }, update: function () {
            var t = this._add.length, e = this._tweens.length;
            if (0 === e && 0 === t) return !1;
            for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
            return 0 < t && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
        }, isTweening: function (e) {
            return this._tweens.some(function (t) {
                return t.target === e
            })
        }, _pauseAll: function () {
            for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t]._pause()
        }, _resumeAll: function () {
            for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t]._resume()
        }, pauseAll: function () {
            for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t].pause()
        }, resumeAll: function () {
            for (var t = this._tweens.length - 1; 0 <= t; t--) this._tweens[t].resume(!0)
        }
    }, j.TweenManager.prototype.constructor = j.TweenManager, j.Tween = function (t, e, i) {
        this.game = e, this.target = t, this.manager = i, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new j.Signal, this.onLoop = new j.Signal, this.onRepeat = new j.Signal, this.onChildComplete = new j.Signal, this.onComplete = new j.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = i.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
    }, j.Tween.prototype = {
        to: function (t, e, i, s, n, r, o) {
            return (void 0 === e || e <= 0) && (e = 1e3), null == i && (i = j.Easing.Default), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === o && (o = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning ? console.warn("Phaser.Tween.to cannot be called after Tween.start") : (this.timeline.push(new j.TweenData(this).to(t, e, i, n, r, o)), s && this.start(), this.game.time.desiredFps < this.game.time.suggestedFps && (this.timeScale = this.game.time.suggestedFps / this.game.time.desiredFps)), this
        }, from: function (t, e, i, s, n, r, o) {
            return void 0 === e && (e = 1e3), null == i && (i = j.Easing.Default), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === o && (o = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning ? console.warn("Phaser.Tween.from cannot be called after Tween.start") : (this.timeline.push(new j.TweenData(this).from(t, e, i, n, r, o)), s && this.start()), this
        }, start: function (t) {
            if (void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
            for (var e = 0; e < this.timeline.length; e++) for (var i in this.timeline[e].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
            for (e = 0; e < this.timeline.length; e++) this.timeline[e].loadValues();
            return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
        }, stop: function (t) {
            return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
        }, updateTweenData: function (t, e, i) {
            if (0 === this.timeline.length) return this;
            if (void 0 === i && (i = 0), -1 === i) for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e; else this.timeline[i][t] = e;
            return this
        }, delay: function (t, e) {
            return this.updateTweenData("delay", t, e)
        }, repeat: function (t, e, i) {
            return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i)
        }, repeatDelay: function (t, e) {
            return this.updateTweenData("repeatDelay", t, e)
        }, yoyo: function (t, e, i) {
            return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
        }, yoyoDelay: function (t, e) {
            return this.updateTweenData("yoyoDelay", t, e)
        }, easing: function (t, e) {
            return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
        }, interpolation: function (t, e, i) {
            return void 0 === e && (e = j.Math), this.updateTweenData("interpolationFunction", t, i), this.updateTweenData("interpolationContext", e, i)
        }, repeatAll: function (t) {
            return void 0 === t && (t = 0), this.repeatCounter = t, this
        }, chain: function () {
            for (var t = arguments.length; t--;) 0 < t ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
            return this
        }, loop: function (t) {
            return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
        }, onUpdateCallback: function (t, e) {
            return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
        }, pause: function () {
            this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
        }, _pause: function () {
            this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
        }, resume: function () {
            if (this.isPaused) {
                this.isPaused = !1, this._codePaused = !1;
                for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
            }
        }, _resume: function () {
            this._codePaused || this.resume()
        }, update: function (t) {
            if (this.pendingDelete || !this.target) return !1;
            if (this.isPaused) return !0;
            var e = this.timeline[this.current].update(t);
            if (e === j.TweenData.PENDING) return !0;
            if (e === j.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
            if (e === j.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
            if (e === j.TweenData.COMPLETE) {
                var i = !1;
                return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, i = !0)) : (this.current++, this.current === this.timeline.length && (i = !(this.current = 0))), i ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : 0 < this.repeatCounter ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
            }
        }, generateData: function (t, e) {
            if (null === this.game || null === this.target) return null;
            void 0 === t && (t = 60), void 0 === e && (e = []);
            for (var i = 0; i < this.timeline.length; i++) for (var s in this.timeline[i].vEnd) this.properties[s] = this.target[s] || 0, Array.isArray(this.properties[s]) || (this.properties[s] *= 1);
            for (i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
            for (i = 0; i < this.timeline.length; i++) e = e.concat(this.timeline[i].generateData(t));
            return e
        }
    }, Object.defineProperty(j.Tween.prototype, "totalDuration", {
        get: function () {
            for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
            return t
        }
    }), j.Tween.prototype.constructor = j.Tween, j.TweenData = function (t) {
        this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = j.Easing.Default, this.interpolationFunction = j.Math.linearInterpolation, this.interpolationContext = j.Math, this.isRunning = !1, this.isFrom = !1
    }, j.TweenData.PENDING = 0, j.TweenData.RUNNING = 1, j.TweenData.LOOPED = 2, j.TweenData.COMPLETE = 3, j.TweenData.prototype = {
        to: function (t, e, i, s, n, r) {
            return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !1, this
        }, from: function (t, e, i, s, n, r) {
            return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !0, this
        }, start: function () {
            if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, 0 < this.delay ? this.isRunning = !1 : this.isRunning = !0, this.isFrom) for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
            return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
        }, loadValues: function () {
            for (var t in this.parent.properties) {
                if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                    if (0 === this.vEnd[t].length) continue;
                    0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                }
                void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
            }
            return this
        }, update: function (t) {
            if (this.isRunning) {
                if (t < this.startTime) return j.TweenData.RUNNING
            } else {
                if (!(t >= this.startTime)) return j.TweenData.PENDING;
                this.isRunning = !0
            }
            var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
            for (var i in this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent), this.vEnd) {
                var s = this.vStart[i], n = this.vEnd[i];
                Array.isArray(n) ? this.parent.target[i] = this.interpolationFunction.call(this.interpolationContext, n, this.value) : this.parent.target[i] = s + (n - s) * this.value
            }
            return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : j.TweenData.RUNNING
        }, generateData: function (t) {
            this.parent.reverse ? this.dt = this.duration : this.dt = 0;
            var e = [], i = !1, s = 1 / t * 1e3;
            do {
                this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                var n = {};
                for (var r in this.vEnd) {
                    var o = this.vStart[r], a = this.vEnd[r];
                    Array.isArray(a) ? n[r] = this.interpolationFunction(a, this.value) : n[r] = o + (a - o) * this.value
                }
                e.push(n), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
            } while (!i);
            if (this.yoyo) {
                var h = e.slice();
                h.reverse(), e = e.concat(h)
            }
            return e
        }, repeat: function () {
            if (this.yoyo) {
                if (this.inReverse && 0 === this.repeatCounter) {
                    for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                    return this.inReverse = !1, j.TweenData.COMPLETE
                }
                this.inReverse = !this.inReverse
            } else if (0 === this.repeatCounter) return j.TweenData.COMPLETE;
            if (this.inReverse) for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t]; else {
                for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                0 < this.repeatCounter && this.repeatCounter--
            }
            return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, j.TweenData.LOOPED
        }
    }, j.TweenData.prototype.constructor = j.TweenData, j.Easing = {
        Linear: {
            None: function (t) {
                return t
            }
        }, Quadratic: {
            In: function (t) {
                return t * t
            }, Out: function (t) {
                return t * (2 - t)
            }, InOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
            }
        }, Cubic: {
            In: function (t) {
                return t * t * t
            }, Out: function (t) {
                return --t * t * t + 1
            }, InOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
            }
        }, Quartic: {
            In: function (t) {
                return t * t * t * t
            }, Out: function (t) {
                return 1 - --t * t * t * t
            }, InOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
            }
        }, Quintic: {
            In: function (t) {
                return t * t * t * t * t
            }, Out: function (t) {
                return --t * t * t * t * t + 1
            }, InOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
            }
        }, Sinusoidal: {
            In: function (t) {
                return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
            }, Out: function (t) {
                return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
            }, InOut: function (t) {
                return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
            }
        }, Exponential: {
            In: function (t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1)
            }, Out: function (t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
            }, InOut: function (t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
            }
        }, Circular: {
            In: function (t) {
                return 1 - Math.sqrt(1 - t * t)
            }, Out: function (t) {
                return Math.sqrt(1 - --t * t)
            }, InOut: function (t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            }
        }, Elastic: {
            In: function (t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
            }, Out: function (t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
            }, InOut: function (t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
            }
        }, Back: {
            In: function (t) {
                return t * t * (2.70158 * t - 1.70158)
            }, Out: function (t) {
                return --t * t * (2.70158 * t + 1.70158) + 1
            }, InOut: function (t) {
                var e = 2.5949095;
                return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
            }
        }, Bounce: {
            In: function (t) {
                return 1 - j.Easing.Bounce.Out(1 - t)
            }, Out: function (t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            }, InOut: function (t) {
                return t < .5 ? .5 * j.Easing.Bounce.In(2 * t) : .5 * j.Easing.Bounce.Out(2 * t - 1) + .5
            }
        }
    }, j.Easing.Default = j.Easing.Linear.None, j.Easing.Power0 = j.Easing.Linear.None, j.Easing.Power1 = j.Easing.Quadratic.Out, j.Easing.Power2 = j.Easing.Cubic.Out, j.Easing.Power3 = j.Easing.Quartic.Out, j.Easing.Power4 = j.Easing.Quintic.Out, j.Time = function (t) {
        this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new j.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
    }, j.Time.prototype = {
        boot: function () {
            this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
        }, add: function (t) {
            return this._timers.push(t), t
        }, create: function (t) {
            void 0 === t && (t = !0);
            var e = new j.Timer(this.game, t);
            return this._timers.push(e), e
        }, removeAll: function () {
            for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
            this._timers = [], this.events.removeAll()
        }, refresh: function () {
            var t = this.time;
            this.time = Date.now(), this.elapsedMS = this.time - t
        }, update: function (t) {
            var e = this.time;
            this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
        }, updateTimers: function () {
            for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
        }, updateAdvancedTiming: function () {
            this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
        }, gamePaused: function () {
            this._pauseStarted = Date.now(), this.events.pause();
            for (var t = this._timers.length; t--;) this._timers[t]._pause()
        }, gameResumed: function () {
            this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
            for (var t = this._timers.length; t--;) this._timers[t]._resume()
        }, totalElapsedSeconds: function () {
            return .001 * (this.time - this._started)
        }, elapsedSince: function (t) {
            return this.time - t
        }, elapsedSecondsSince: function (t) {
            return .001 * (this.time - t)
        }, reset: function () {
            this._started = this.time, this.removeAll()
        }
    }, Object.defineProperty(j.Time.prototype, "desiredFps", {
        get: function () {
            return this._desiredFps
        }, set: function (t) {
            this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
        }
    }), j.Time.prototype.constructor = j.Time, j.Timer = function (t, e) {
        void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new j.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
    }, j.Timer.MINUTE = 6e4, j.Timer.SECOND = 1e3, j.Timer.HALF = 500, j.Timer.QUARTER = 250, j.Timer.prototype = {
        create: function (t, e, i, s, n, r) {
            var o = t = Math.round(t);
            0 === this._now ? o += this.game.time.time : o += this._now;
            var a = new j.TimerEvent(this, t, o, i, e, s, n, r);
            return this.events.push(a), this.order(), this.expired = !1, a
        }, add: function (t, e, i) {
            return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
        }, repeat: function (t, e, i, s) {
            return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
        }, loop: function (t, e, i) {
            return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
        }, start: function (t) {
            if (!this.running) {
                this._started = this.game.time.time + (t || 0), this.running = !0;
                for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
            }
        }, stop: function (t) {
            this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
        }, remove: function (t) {
            for (var e = 0; e < this.events.length; e++) if (this.events[e] === t) return this.events[e].pendingDelete = !0;
            return !1
        }, order: function () {
            0 < this.events.length && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
        }, sortHandler: function (t, e) {
            return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
        }, clearPendingEvents: function () {
            for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
            this._len = this.events.length, this._i = 0
        }, update: function (t) {
            if (this.paused) return !0;
            if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && 0 < this._len) {
                for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? this.events[this._i].tick = this._newTick : 0 < this.events[this._i].repeatCount ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick) : (this._marked++, this.events[this._i].pendingDelete = !0), this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args), this._i++;
                this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
            }
            return !this.expired || !this.autoDestroy
        }, pause: function () {
            this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
        }, _pause: function () {
            !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
        }, adjustEvents: function (t) {
            for (var e = 0; e < this.events.length; e++) if (!this.events[e].pendingDelete) {
                var i = this.events[e].tick - t;
                i < 0 && (i = 0), this.events[e].tick = this._now + i
            }
            var s = this.nextTick - t;
            this.nextTick = s < 0 ? this._now : this._now + s
        }, resume: function () {
            if (this.paused) {
                var t = this.game.time.time;
                this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
            }
        }, _resume: function () {
            this._codePaused || this.resume()
        }, removeAll: function () {
            this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
        }, destroy: function () {
            this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
        }
    }, Object.defineProperty(j.Timer.prototype, "next", {
        get: function () {
            return this.nextTick
        }
    }), Object.defineProperty(j.Timer.prototype, "duration", {
        get: function () {
            return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
        }
    }), Object.defineProperty(j.Timer.prototype, "length", {
        get: function () {
            return this.events.length
        }
    }), Object.defineProperty(j.Timer.prototype, "ms", {
        get: function () {
            return this.running ? this._now - this._started - this._pauseTotal : 0
        }
    }), Object.defineProperty(j.Timer.prototype, "seconds", {
        get: function () {
            return this.running ? .001 * this.ms : 0
        }
    }), j.Timer.prototype.constructor = j.Timer, j.TimerEvent = function (t, e, i, s, n, r, o, a) {
        this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = n, this.callback = r, this.callbackContext = o, this.args = a, this.pendingDelete = !1
    }, j.TimerEvent.prototype.constructor = j.TimerEvent, j.AnimationManager = function (t) {
        this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
    }, j.AnimationManager.prototype = {
        loadFrameData: function (t, e) {
            if (void 0 === t) return !1;
            if (this.isLoaded) for (var i in this._anims) this._anims[i].updateFrameData(t);
            return this._frameData = t, null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0
        }, copyFrameData: function (t, e) {
            if (this._frameData = t.clone(), this.isLoaded) for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
            return null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0
        }, add: function (t, e, i, s, n) {
            return e = e || [], i = i || 60, void 0 === s && (s = !1), void 0 === n && (n = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, n, this._outputFrames), this._anims[t] = new j.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, i, s), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
        }, validateFrames: function (t, e) {
            void 0 === e && (e = !0);
            for (var i = 0; i < t.length; i++) if (!0 === e) {
                if (t[i] > this._frameData.total) return !1
            } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
            return !0
        }, play: function (t, e, i, s) {
            if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
        }, stop: function (t, e) {
            void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
        }, update: function () {
            return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
        }, next: function (t) {
            this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
        }, previous: function (t) {
            this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
        }, getAnimation: function (t) {
            return "string" == typeof t && this._anims[t] ? this._anims[t] : null
        }, refreshFrame: function () {
        }, destroy: function () {
            var t = null;
            for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
            this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
        }
    }, j.AnimationManager.prototype.constructor = j.AnimationManager, Object.defineProperty(j.AnimationManager.prototype, "frameData", {
        get: function () {
            return this._frameData
        }
    }), Object.defineProperty(j.AnimationManager.prototype, "frameTotal", {
        get: function () {
            return this._frameData.total
        }
    }), Object.defineProperty(j.AnimationManager.prototype, "paused", {
        get: function () {
            return this.currentAnim.isPaused
        }, set: function (t) {
            this.currentAnim.paused = t
        }
    }), Object.defineProperty(j.AnimationManager.prototype, "name", {
        get: function () {
            if (this.currentAnim) return this.currentAnim.name
        }
    }), Object.defineProperty(j.AnimationManager.prototype, "frame", {
        get: function () {
            if (this.currentFrame) return this.currentFrame.index
        }, set: function (t) {
            "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame))
        }
    }), Object.defineProperty(j.AnimationManager.prototype, "frameName", {
        get: function () {
            if (this.currentFrame) return this.currentFrame.name
        }, set: function (t) {
            "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) ? (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame))) : console.warn("Cannot set frameName: " + t)
        }
    }), j.Animation = function (t, e, i, s, n, r, o) {
        void 0 === o && (o = !1), this.game = t, this._parent = e, this._frameData = s, this.name = i, this._frames = [], this._frames = this._frames.concat(n), this.delay = 1e3 / r, this.loop = o, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new j.Signal, this.onUpdate = null, this.onComplete = new j.Signal, this.onLoop = new j.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
    }, j.Animation.prototype = {
        play: function (t, e, i) {
            return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), (this._parent.animations.currentAnim = this)._parent.animations.currentFrame = this.currentFrame, this
        }, restart: function () {
            this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), (this._parent.animations.currentAnim = this)._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
        }, reverse: function () {
            return this.reversed = !this.reversed, this
        }, reverseOnce: function () {
            return this.onComplete.addOnce(this.reverse, this), this.reverse()
        }, setFrame: function (t, e) {
            var i;
            if (void 0 === e && (e = !1), "string" == typeof t) for (var s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s); else if ("number" == typeof t) if (e) i = t; else for (s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
            i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update())
        }, stop: function (t, e) {
            void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
        }, onPause: function () {
            this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
        }, onResume: function () {
            this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
        }, update: function () {
            return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0)))
        }, updateCurrentFrame: function (t, e) {
            if (void 0 === e && (e = !1), !this._frameData) return !1;
            var i = this.currentFrame.index;
            return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
        }, next: function (t) {
            void 0 === t && (t = 1);
            var e = this._frameIndex + t;
            e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
        }, previous: function (t) {
            void 0 === t && (t = 1);
            var e = this._frameIndex - t;
            e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
        }, updateFrameData: function (t) {
            this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
        }, destroy: function () {
            this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
        }, complete: function () {
            this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
        }
    }, j.Animation.prototype.constructor = j.Animation, Object.defineProperty(j.Animation.prototype, "paused", {
        get: function () {
            return this.isPaused
        }, set: function (t) {
            (this.isPaused = t) ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
        }
    }), Object.defineProperty(j.Animation.prototype, "reversed", {
        get: function () {
            return this.isReversed
        }, set: function (t) {
            this.isReversed = t
        }
    }), Object.defineProperty(j.Animation.prototype, "frameTotal", {
        get: function () {
            return this._frames.length
        }
    }), Object.defineProperty(j.Animation.prototype, "frame", {
        get: function () {
            return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
        }, set: function (t) {
            this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
        }
    }), Object.defineProperty(j.Animation.prototype, "speed", {
        get: function () {
            return 1e3 / this.delay
        }, set: function (t) {
            0 < t && (this.delay = 1e3 / t)
        }
    }), Object.defineProperty(j.Animation.prototype, "enableUpdate", {
        get: function () {
            return null !== this.onUpdate
        }, set: function (t) {
            t && null === this.onUpdate ? this.onUpdate = new j.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
        }
    }), j.Animation.generateFrameNames = function (t, e, i, s, n) {
        void 0 === s && (s = "");
        var r = [], o = "";
        if (e < i) for (var a = e; a <= i; a++) o = t + (o = "number" == typeof n ? j.Utils.pad(a.toString(), n, "0", 1) : a.toString()) + s, r.push(o); else for (a = e; i <= a; a--) o = t + (o = "number" == typeof n ? j.Utils.pad(a.toString(), n, "0", 1) : a.toString()) + s, r.push(o);
        return r
    }, j.Frame = function (t, e, i, s, n, r) {
        this.index = t, this.x = e, this.y = i, this.width = s, this.height = n, this.name = r, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(n / 2), this.distance = j.Math.distance(0, 0, s, n), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = s, this.sourceSizeH = n, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
    }, j.Frame.prototype = {
        resize: function (t, e) {
            this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = j.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
        }, setTrim: function (t, e, i, s, n, r, o) {
            (this.trimmed = t) && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = r, this.spriteSourceSizeH = o)
        }, clone: function () {
            var t = new j.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
            for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
            return t
        }, getRect: function (t) {
            return void 0 === t ? t = new j.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
        }
    }, j.Frame.prototype.constructor = j.Frame, j.FrameData = function () {
        this._frames = [], this._frameNames = []
    }, j.FrameData.prototype = {
        addFrame: function (t) {
            return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
        }, getFrame: function (t) {
            return t >= this._frames.length && (t = 0), this._frames[t]
        }, getFrameByName: function (t) {
            return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
        }, checkFrameName: function (t) {
            return null != this._frameNames[t]
        }, clone: function () {
            for (var t = new j.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone());
            for (var i in this._frameNames) this._frameNames.hasOwnProperty(i) && t._frameNames.push(this._frameNames[i]);
            return t
        }, getFrameRange: function (t, e, i) {
            void 0 === i && (i = []);
            for (var s = t; s <= e; s++) i.push(this._frames[s]);
            return i
        }, getFrames: function (t, e, i) {
            if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length) for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s]); else for (s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
            return i
        }, getFrameIndexes: function (t, e, i) {
            if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length) for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s].index); else for (s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
            return i
        }, destroy: function () {
            this._frames = null, this._frameNames = null
        }
    }, j.FrameData.prototype.constructor = j.FrameData, Object.defineProperty(j.FrameData.prototype, "total", {
        get: function () {
            return this._frames.length
        }
    }), j.AnimationParser = {
        spriteSheet: function (t, e, i, s, n, r, o) {
            var a = e;
            if ("string" == typeof e && (a = t.cache.getImage(e)), null === a) return null;
            var h = a.width, l = a.height;
            i <= 0 && (i = Math.floor(-h / Math.min(-1, i))), s <= 0 && (s = Math.floor(-l / Math.min(-1, s)));
            var c = Math.floor((h - r) / (i + o)) * Math.floor((l - r) / (s + o));
            if (-1 !== n && (c = n), 0 === h || 0 === l || h < i || l < s || 0 === c) return console.warn("Phaser.AnimationParser.spriteSheet: '" + e + "'s width/height zero or width/height < given frameWidth/frameHeight"), null;
            for (var u = new j.FrameData, d = r, p = r, f = 0; f < c; f++) u.addFrame(new j.Frame(f, d, p, i, s, "")), h < (d += i + o) + i && (d = r, p += s + o);
            return u
        }, JSONData: function (t, e) {
            if (!e.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(e);
            for (var i, s = new j.FrameData, n = e.frames, r = 0; r < n.length; r++) i = s.addFrame(new j.Frame(r, n[r].frame.x, n[r].frame.y, n[r].frame.w, n[r].frame.h, n[r].filename)), n[r].trimmed && i.setTrim(n[r].trimmed, n[r].sourceSize.w, n[r].sourceSize.h, n[r].spriteSourceSize.x, n[r].spriteSourceSize.y, n[r].spriteSourceSize.w, n[r].spriteSourceSize.h);
            return s
        }, JSONDataPyxel: function (t, e) {
            if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function (t) {
                if (!e[t]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'), void console.log(e)
            }), 1 !== e.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void console.log(e);
            for (var i = new j.FrameData, s = e.tileheight, n = e.tilewidth, r = e.layers[0].tiles, o = 0; o < r.length; o++) i.addFrame(new j.Frame(o, r[o].x, r[o].y, n, s, "frame_" + o)).setTrim(!1);
            return i
        }, JSONDataHash: function (t, e) {
            if (!e.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(e);
            var i, s = new j.FrameData, n = e.frames, r = 0;
            for (var o in n) i = s.addFrame(new j.Frame(r, n[o].frame.x, n[o].frame.y, n[o].frame.w, n[o].frame.h, o)), n[o].trimmed && i.setTrim(n[o].trimmed, n[o].sourceSize.w, n[o].sourceSize.h, n[o].spriteSourceSize.x, n[o].spriteSourceSize.y, n[o].spriteSourceSize.w, n[o].spriteSourceSize.h), r++;
            return s
        }, XMLData: function (t, e) {
            if (e.getElementsByTagName("TextureAtlas")) {
                for (var i, s, n, r, o, a, h, l, c, u, d, p = new j.FrameData, f = e.getElementsByTagName("SubTexture"), g = 0; g < f.length; g++) s = (n = f[g].attributes).name.value, r = parseInt(n.x.value, 10), o = parseInt(n.y.value, 10), a = parseInt(n.width.value, 10), h = parseInt(n.height.value, 10), c = l = null, n.frameX && (l = Math.abs(parseInt(n.frameX.value, 10)), c = Math.abs(parseInt(n.frameY.value, 10)), u = parseInt(n.frameWidth.value, 10), d = parseInt(n.frameHeight.value, 10)), i = p.addFrame(new j.Frame(g, r, o, a, h, s)), null === l && null === c || i.setTrim(!0, a, h, l, c, u, d);
                return p
            }
            console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
        }
    }, j.Cache = function (t) {
        this.game = t, this.autoResolveURL = !1, this._cache = {
            canvas: {},
            image: {},
            texture: {},
            sound: {},
            video: {},
            text: {},
            json: {},
            xml: {},
            physics: {},
            tilemap: {},
            binary: {},
            bitmapData: {},
            bitmapFont: {},
            shader: {},
            renderTexture: {}
        }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new j.Signal, this._cacheMap = [], this._cacheMap[j.Cache.CANVAS] = this._cache.canvas, this._cacheMap[j.Cache.IMAGE] = this._cache.image, this._cacheMap[j.Cache.TEXTURE] = this._cache.texture, this._cacheMap[j.Cache.SOUND] = this._cache.sound, this._cacheMap[j.Cache.TEXT] = this._cache.text, this._cacheMap[j.Cache.PHYSICS] = this._cache.physics, this._cacheMap[j.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[j.Cache.BINARY] = this._cache.binary, this._cacheMap[j.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[j.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[j.Cache.JSON] = this._cache.json, this._cacheMap[j.Cache.XML] = this._cache.xml, this._cacheMap[j.Cache.VIDEO] = this._cache.video, this._cacheMap[j.Cache.SHADER] = this._cache.shader, this._cacheMap[j.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
    }, j.Cache.CANVAS = 1, j.Cache.IMAGE = 2, j.Cache.TEXTURE = 3, j.Cache.SOUND = 4, j.Cache.TEXT = 5, j.Cache.PHYSICS = 6, j.Cache.TILEMAP = 7, j.Cache.BINARY = 8, j.Cache.BITMAPDATA = 9, j.Cache.BITMAPFONT = 10, j.Cache.JSON = 11, j.Cache.XML = 12, j.Cache.VIDEO = 13, j.Cache.SHADER = 14, j.Cache.RENDER_TEXTURE = 15, j.Cache.DEFAULT = null, j.Cache.MISSING = null, j.Cache.prototype = {
        addCanvas: function (t, e, i) {
            void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {canvas: e, context: i}
        }, addImage: function (t, e, i) {
            this.checkImageKey(t) && this.removeImage(t);
            var s = {
                key: t,
                url: e,
                data: i,
                base: new PIXI.BaseTexture(i),
                frame: new j.Frame(0, 0, 0, i.width, i.height, t),
                frameData: new j.FrameData
            };
            return s.frameData.addFrame(new j.Frame(0, 0, 0, i.width, i.height, e)), this._cache.image[t] = s, this._resolveURL(e, s), "__default" === t ? j.Cache.DEFAULT = new PIXI.Texture(s.base) : "__missing" === t && (j.Cache.MISSING = new PIXI.Texture(s.base)), s
        }, addDefaultImage: function () {
            var t = new Image;
            t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
            var e = this.addImage("__default", null, t);
            e.base.skipRender = !0, j.Cache.DEFAULT = new PIXI.Texture(e.base)
        }, addMissingImage: function () {
            var t = new Image;
            t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            var e = this.addImage("__missing", null, t);
            j.Cache.MISSING = new PIXI.Texture(e.base)
        }, addSound: function (t, e, i, s, n) {
            void 0 === s && (n = !(s = !0)), void 0 === n && (n = !(s = !1));
            var r = !1;
            n && (r = !0), this._cache.sound[t] = {
                url: e,
                data: i,
                isDecoding: !1,
                decoded: r,
                webAudio: s,
                audioTag: n,
                locked: this.game.sound.touchLocked
            }, this._resolveURL(e, this._cache.sound[t])
        }, addText: function (t, e, i) {
            this._cache.text[t] = {url: e, data: i}, this._resolveURL(e, this._cache.text[t])
        }, addPhysicsData: function (t, e, i, s) {
            this._cache.physics[t] = {url: e, data: i, format: s}, this._resolveURL(e, this._cache.physics[t])
        }, addTilemap: function (t, e, i, s) {
            this._cache.tilemap[t] = {url: e, data: i, format: s}, this._resolveURL(e, this._cache.tilemap[t])
        }, addBinary: function (t, e) {
            this._cache.binary[t] = e
        }, addBitmapData: function (t, e, i) {
            return e.key = t, void 0 === i && (i = new j.FrameData).addFrame(e.textureFrame), this._cache.bitmapData[t] = {
                data: e,
                frameData: i
            }, e
        }, addBitmapFont: function (t, e, i, s, n, r, o) {
            var a = {url: e, data: i, font: null, base: new PIXI.BaseTexture(i)};
            void 0 === r && (r = 0), void 0 === o && (o = 0), a.font = "json" === n ? j.LoaderParser.jsonBitmapFont(s, a.base, r, o) : j.LoaderParser.xmlBitmapFont(s, a.base, r, o), this._cache.bitmapFont[t] = a, this._resolveURL(e, a)
        }, addJSON: function (t, e, i) {
            this._cache.json[t] = {url: e, data: i}, this._resolveURL(e, this._cache.json[t])
        }, addXML: function (t, e, i) {
            this._cache.xml[t] = {url: e, data: i}, this._resolveURL(e, this._cache.xml[t])
        }, addVideo: function (t, e, i, s) {
            this._cache.video[t] = {url: e, data: i, isBlob: s, locked: !0}, this._resolveURL(e, this._cache.video[t])
        }, addShader: function (t, e, i) {
            this._cache.shader[t] = {url: e, data: i}, this._resolveURL(e, this._cache.shader[t])
        }, addRenderTexture: function (t, e) {
            this._cache.renderTexture[t] = {texture: e, frame: new j.Frame(0, 0, 0, e.width, e.height, "", "")}
        }, addSpriteSheet: function (t, e, i, s, n, r, o, a) {
            void 0 === r && (r = -1), void 0 === o && (o = 0), void 0 === a && (a = 0);
            var h = {
                key: t,
                url: e,
                data: i,
                frameWidth: s,
                frameHeight: n,
                margin: o,
                spacing: a,
                base: new PIXI.BaseTexture(i),
                frameData: j.AnimationParser.spriteSheet(this.game, i, s, n, r, o, a)
            };
            this._cache.image[t] = h, this._resolveURL(e, h)
        }, addTextureAtlas: function (t, e, i, s, n) {
            var r = {key: t, url: e, data: i, base: new PIXI.BaseTexture(i)};
            n === j.Loader.TEXTURE_ATLAS_XML_STARLING ? r.frameData = j.AnimationParser.XMLData(this.game, s, t) : n === j.Loader.TEXTURE_ATLAS_JSON_PYXEL ? r.frameData = j.AnimationParser.JSONDataPyxel(this.game, s, t) : Array.isArray(s.frames) ? r.frameData = j.AnimationParser.JSONData(this.game, s, t) : r.frameData = j.AnimationParser.JSONDataHash(this.game, s, t), this._cache.image[t] = r, this._resolveURL(e, r)
        }, reloadSound: function (t) {
            var e = this, i = this.getSound(t);
            i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function () {
                return e.reloadSoundComplete(t)
            }, !1), i.data.load())
        }, reloadSoundComplete: function (t) {
            var e = this.getSound(t);
            e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
        }, updateSound: function (t, e, i) {
            var s = this.getSound(t);
            s && (s[e] = i)
        }, decodedSound: function (t, e) {
            var i = this.getSound(t);
            i.data = e, i.decoded = !0, i.isDecoding = !1
        }, isSoundDecoded: function (t) {
            var e = this.getItem(t, j.Cache.SOUND, "isSoundDecoded");
            if (e) return e.decoded
        }, isSoundReady: function (t) {
            var e = this.getItem(t, j.Cache.SOUND, "isSoundDecoded");
            if (e) return e.decoded && !this.game.sound.touchLocked
        }, checkKey: function (t, e) {
            return !!this._cacheMap[t][e]
        }, checkURL: function (t) {
            return !!this._urlMap[this._resolveURL(t)]
        }, checkCanvasKey: function (t) {
            return this.checkKey(j.Cache.CANVAS, t)
        }, checkImageKey: function (t) {
            return this.checkKey(j.Cache.IMAGE, t)
        }, checkTextureKey: function (t) {
            return this.checkKey(j.Cache.TEXTURE, t)
        }, checkSoundKey: function (t) {
            return this.checkKey(j.Cache.SOUND, t)
        }, checkTextKey: function (t) {
            return this.checkKey(j.Cache.TEXT, t)
        }, checkPhysicsKey: function (t) {
            return this.checkKey(j.Cache.PHYSICS, t)
        }, checkTilemapKey: function (t) {
            return this.checkKey(j.Cache.TILEMAP, t)
        }, checkBinaryKey: function (t) {
            return this.checkKey(j.Cache.BINARY, t)
        }, checkBitmapDataKey: function (t) {
            return this.checkKey(j.Cache.BITMAPDATA, t)
        }, checkBitmapFontKey: function (t) {
            return this.checkKey(j.Cache.BITMAPFONT, t)
        }, checkJSONKey: function (t) {
            return this.checkKey(j.Cache.JSON, t)
        }, checkXMLKey: function (t) {
            return this.checkKey(j.Cache.XML, t)
        }, checkVideoKey: function (t) {
            return this.checkKey(j.Cache.VIDEO, t)
        }, checkShaderKey: function (t) {
            return this.checkKey(j.Cache.SHADER, t)
        }, checkRenderTextureKey: function (t) {
            return this.checkKey(j.Cache.RENDER_TEXTURE, t)
        }, getItem: function (t, e, i, s) {
            return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
        }, getCanvas: function (t) {
            return this.getItem(t, j.Cache.CANVAS, "getCanvas", "canvas")
        }, getImage: function (t, e) {
            null == t && (t = "__default"), void 0 === e && (e = !1);
            var i = this.getItem(t, j.Cache.IMAGE, "getImage");
            return null === i && (i = this.getItem("__missing", j.Cache.IMAGE, "getImage")), e ? i : i.data
        }, getTextureFrame: function (t) {
            return this.getItem(t, j.Cache.TEXTURE, "getTextureFrame", "frame")
        }, getSound: function (t) {
            return this.getItem(t, j.Cache.SOUND, "getSound")
        }, getSoundData: function (t) {
            return this.getItem(t, j.Cache.SOUND, "getSoundData", "data")
        }, getText: function (t) {
            return this.getItem(t, j.Cache.TEXT, "getText", "data")
        }, getPhysicsData: function (t, e, i) {
            var s = this.getItem(t, j.Cache.PHYSICS, "getPhysicsData", "data");
            if (null === s || null == e) return s;
            if (s[e]) {
                var n = s[e];
                if (!n || !i) return n;
                for (var r in n) if ((r = n[r]).fixtureKey === i) return r;
                console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + i + " in " + t + '"')
            } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + e + '"');
            return null
        }, getTilemapData: function (t) {
            return this.getItem(t, j.Cache.TILEMAP, "getTilemapData")
        }, getBinary: function (t) {
            return this.getItem(t, j.Cache.BINARY, "getBinary")
        }, getBitmapData: function (t) {
            return this.getItem(t, j.Cache.BITMAPDATA, "getBitmapData", "data")
        }, getBitmapFont: function (t) {
            return this.getItem(t, j.Cache.BITMAPFONT, "getBitmapFont")
        }, getJSON: function (t, e) {
            var i = this.getItem(t, j.Cache.JSON, "getJSON", "data");
            return i ? e ? j.Utils.extend(!0, Array.isArray(i) ? [] : {}, i) : i : null
        }, getXML: function (t) {
            return this.getItem(t, j.Cache.XML, "getXML", "data")
        }, getVideo: function (t) {
            return this.getItem(t, j.Cache.VIDEO, "getVideo")
        }, getShader: function (t) {
            return this.getItem(t, j.Cache.SHADER, "getShader", "data")
        }, getRenderTexture: function (t) {
            return this.getItem(t, j.Cache.RENDER_TEXTURE, "getRenderTexture")
        }, getBaseTexture: function (t, e) {
            return void 0 === e && (e = j.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
        }, getFrame: function (t, e) {
            return void 0 === e && (e = j.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
        }, getFrameCount: function (t, e) {
            var i = this.getFrameData(t, e);
            return i ? i.total : 0
        }, getFrameData: function (t, e) {
            return void 0 === e && (e = j.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
        }, hasFrameData: function (t, e) {
            return void 0 === e && (e = j.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
        }, updateFrameData: function (t, e, i) {
            void 0 === i && (i = j.Cache.IMAGE), this._cacheMap[i][t] && (this._cacheMap[i][t].frameData = e)
        }, getFrameByIndex: function (t, e, i) {
            var s = this.getFrameData(t, i);
            return s ? s.getFrame(e) : null
        }, getFrameByName: function (t, e, i) {
            var s = this.getFrameData(t, i);
            return s ? s.getFrameByName(e) : null
        }, getURL: function (t) {
            return (t = this._resolveURL(t)) ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
        }, getKeys: function (t) {
            void 0 === t && (t = j.Cache.IMAGE);
            var e = [];
            if (this._cacheMap[t]) for (var i in this._cacheMap[t]) "__default" !== i && "__missing" !== i && e.push(i);
            return e
        }, removeCanvas: function (t) {
            delete this._cache.canvas[t]
        }, removeImage: function (t, e) {
            void 0 === e && (e = !0);
            var i = this.getImage(t, !0);
            e && i.base && i.base.destroy(), delete this._cache.image[t]
        }, removeSound: function (t) {
            delete this._cache.sound[t]
        }, removeText: function (t) {
            delete this._cache.text[t]
        }, removePhysics: function (t) {
            delete this._cache.physics[t]
        }, removeTilemap: function (t) {
            delete this._cache.tilemap[t]
        }, removeBinary: function (t) {
            delete this._cache.binary[t]
        }, removeBitmapData: function (t) {
            delete this._cache.bitmapData[t]
        }, removeBitmapFont: function (t) {
            delete this._cache.bitmapFont[t]
        }, removeJSON: function (t) {
            delete this._cache.json[t]
        }, removeXML: function (t) {
            delete this._cache.xml[t]
        }, removeVideo: function (t) {
            delete this._cache.video[t]
        }, removeShader: function (t) {
            delete this._cache.shader[t]
        }, removeRenderTexture: function (t) {
            delete this._cache.renderTexture[t]
        }, removeSpriteSheet: function (t) {
            delete this._cache.spriteSheet[t]
        }, removeTextureAtlas: function (t) {
            delete this._cache.atlas[t]
        }, clearGLTextures: function () {
            for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
        }, _resolveURL: function (t, e) {
            return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
        }, destroy: function () {
            for (var t = 0; t < this._cacheMap.length; t++) {
                var e = this._cacheMap[t];
                for (var i in e) "__default" !== i && "__missing" !== i && (e[i].destroy && e[i].destroy(), delete e[i])
            }
            this._urlMap = null, this._urlResolver = null, this._urlTemp = null
        }
    }, j.Cache.prototype.constructor = j.Cache, j.Loader = function (t) {
        this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
            requestedWith: !1,
            json: "application/json",
            xml: "application/xml"
        }, this.onLoadStart = new j.Signal, this.onLoadComplete = new j.Signal, this.onPackComplete = new j.Signal, this.onFileStart = new j.Signal, this.onFileComplete = new j.Signal, this.onFileError = new j.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
    }, j.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, j.Loader.TEXTURE_ATLAS_JSON_HASH = 1, j.Loader.TEXTURE_ATLAS_XML_STARLING = 2,j.Loader.PHYSICS_LIME_CORONA_JSON = 3,j.Loader.PHYSICS_PHASER_JSON = 4,j.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5,j.Loader.prototype = {
        setPreloadSprite: function (t, e) {
            e = e || 0, this.preloadSprite = {
                sprite: t,
                direction: e,
                width: t.width,
                height: t.height,
                rect: null
            }, this.preloadSprite.rect = 0 === e ? new j.Rectangle(0, 0, 1, t.height) : new j.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
        }, resize: function () {
            this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
        }, checkKeyExists: function (t, e) {
            return -1 < this.getAssetIndex(t, e)
        }, getAssetIndex: function (t, e) {
            for (var i = -1, s = 0; s < this._fileList.length; s++) {
                var n = this._fileList[s];
                if (n.type === t && n.key === e && (i = s, !n.loaded && !n.loading)) break
            }
            return i
        }, getAsset: function (t, e) {
            var i = this.getAssetIndex(t, e);
            return -1 < i && {index: i, file: this._fileList[i]}
        }, reset: function (t, e) {
            void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
        }, addToFileList: function (t, e, i, s, n, r) {
            if (void 0 === n && (n = !1), void 0 === e || "" === e) return console.warn("Phaser.Loader: Invalid or no key given of type " + t), this;
            if (null == i) {
                if (!r) return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e), this;
                i = e + r
            }
            var o = {
                type: t,
                key: e,
                path: this.path,
                url: i,
                syncPoint: 0 < this._withSyncPointDepth,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1
            };
            if (s) for (var a in s) o[a] = s[a];
            var h = this.getAssetIndex(t, e);
            if (n && -1 < h) {
                var l = this._fileList[h];
                l.loading || l.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[h] = o
            } else -1 === h && (this._fileList.push(o), this._totalFileCount++);
            return this
        }, replaceInFileList: function (t, e, i, s) {
            return this.addToFileList(t, e, i, s, !0)
        }, pack: function (t, e, i, s) {
            if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
            var n = {
                type: "packfile",
                key: t,
                url: e,
                path: this.path,
                syncPoint: !0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1,
                callbackContext: s
            };
            i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {}, n.loaded = !0);
            for (var r = 0; r < this._fileList.length + 1; r++) {
                var o = this._fileList[r];
                if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                    this._fileList.splice(r, 0, n), this._totalPackCount++;
                    break
                }
            }
            return this
        }, image: function (t, e, i) {
            return this.addToFileList("image", t, e, void 0, i, ".png")
        }, images: function (t, e) {
            if (Array.isArray(e)) for (var i = 0; i < t.length; i++) this.image(t[i], e[i]); else for (i = 0; i < t.length; i++) this.image(t[i]);
            return this
        }, text: function (t, e, i) {
            return this.addToFileList("text", t, e, void 0, i, ".txt")
        }, json: function (t, e, i) {
            return this.addToFileList("json", t, e, void 0, i, ".json")
        }, shader: function (t, e, i) {
            return this.addToFileList("shader", t, e, void 0, i, ".frag")
        }, xml: function (t, e, i) {
            return this.addToFileList("xml", t, e, void 0, i, ".xml")
        }, script: function (t, e, i, s) {
            return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = this), this.addToFileList("script", t, e, {
                syncPoint: !0,
                callback: i,
                callbackContext: s
            }, !1, ".js")
        }, binary: function (t, e, i, s) {
            return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = i), this.addToFileList("binary", t, e, {
                callback: i,
                callbackContext: s
            }, !1, ".bin")
        }, spritesheet: function (t, e, i, s, n, r, o) {
            return void 0 === n && (n = -1), void 0 === r && (r = 0), void 0 === o && (o = 0), this.addToFileList("spritesheet", t, e, {
                frameWidth: i,
                frameHeight: s,
                frameMax: n,
                margin: r,
                spacing: o
            }, !1, ".png")
        }, audio: function (t, e, i) {
            return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                buffer: null,
                autoDecode: i
            }))
        }, audioSprite: function (t, e, i, s, n) {
            return this.game.sound.noAudio || (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object")), this
        }, audiosprite: function (t, e, i, s, n) {
            return this.audioSprite(t, e, i, s, n)
        }, video: function (t, e, i, s) {
            return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === s && (s = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                buffer: null,
                asBlob: s,
                loadEvent: i
            })
        }, tilemap: function (t, e, i, s) {
            if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = j.Tilemap.CSV), e || i || (e = s === j.Tilemap.CSV ? t + ".csv" : t + ".json"), i) {
                switch (s) {
                    case j.Tilemap.CSV:
                        break;
                    case j.Tilemap.TILED_JSON:
                        "string" == typeof i && (i = JSON.parse(i))
                }
                this.cache.addTilemap(t, null, i, s)
            } else this.addToFileList("tilemap", t, e, {format: s});
            return this
        }, physics: function (t, e, i, s) {
            return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = j.Physics.LIME_CORONA_JSON), e || i || (e = t + ".json"), i ? ("string" == typeof i && (i = JSON.parse(i)), this.cache.addPhysicsData(t, null, i, s)) : this.addToFileList("physics", t, e, {format: s}), this
        }, bitmapFont: function (t, e, i, s, n, r) {
            if (null == e && (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                atlasURL: i,
                xSpacing: n,
                ySpacing: r
            }); else if ("string" == typeof s) {
                var o, a;
                try {
                    o = JSON.parse(s)
                } catch (t) {
                    a = this.parseXml(s)
                }
                if (!a && !o) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                this.addToFileList("bitmapfont", t, e, {
                    atlasURL: null,
                    atlasData: o || a,
                    atlasType: o ? "json" : "xml",
                    xSpacing: n,
                    ySpacing: r
                })
            }
            return this
        }, atlasJSONArray: function (t, e, i, s) {
            return this.atlas(t, e, i, s, j.Loader.TEXTURE_ATLAS_JSON_ARRAY)
        }, atlasJSONHash: function (t, e, i, s) {
            return this.atlas(t, e, i, s, j.Loader.TEXTURE_ATLAS_JSON_HASH)
        }, atlasXML: function (t, e, i, s) {
            return void 0 === i && (i = null), void 0 === s && (s = null), i || s || (i = t + ".xml"), this.atlas(t, e, i, s, j.Loader.TEXTURE_ATLAS_XML_STARLING)
        }, atlas: function (t, e, i, s, n) {
            if (null == e && (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = j.Loader.TEXTURE_ATLAS_JSON_ARRAY), i || s || (i = n === j.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), i) this.addToFileList("textureatlas", t, e, {
                atlasURL: i,
                format: n
            }); else {
                switch (n) {
                    case j.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                        "string" == typeof s && (s = JSON.parse(s));
                        break;
                    case j.Loader.TEXTURE_ATLAS_XML_STARLING:
                        if ("string" == typeof s) {
                            var r = this.parseXml(s);
                            if (!r) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                            s = r
                        }
                }
                this.addToFileList("textureatlas", t, e, {atlasURL: null, atlasData: s, format: n})
            }
            return this
        }, withSyncPoint: function (t, e) {
            this._withSyncPointDepth++;
            try {
                t.call(e || this, this)
            } finally {
                this._withSyncPointDepth--
            }
            return this
        }, addSyncPoint: function (t, e) {
            var i = this.getAsset(t, e);
            return i && (i.file.syncPoint = !0), this
        }, removeFile: function (t, e) {
            var i = this.getAsset(t, e);
            i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
        }, removeAll: function () {
            this._fileList.length = 0, this._flightQueue.length = 0
        }, start: function () {
            this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
        }, processLoadQueue: function () {
            if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
            for (var t = 0; t < this._flightQueue.length; t++) {
                ((s = this._flightQueue[t]).loaded || s.error) && (this._flightQueue.splice(t, 1), t--, s.loading = !1, s.requestUrl = null, s.requestObject = null, s.error && this.onFileError.dispatch(s.key, s), "packfile" !== s.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, s.key, !s.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === s.type && s.error && (this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)))
            }
            var e = !1, i = this.enableParallel ? j.Math.clamp(this.maxParallelDownloads, 1, 12) : 1;
            for (t = this._processingHead; t < this._fileList.length; t++) {
                var s;
                if ("packfile" === (s = this._fileList[t]).type && !s.error && s.loaded && t === this._processingHead && (this.processPack(s), this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)), s.loaded || s.error ? t === this._processingHead && (this._processingHead = t + 1) : !s.loading && this._flightQueue.length < i && ("packfile" !== s.type || s.data ? e || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(s), s.loading = !0, this.onFileStart.dispatch(this.progress, s.key, s.url), this.loadFile(s)) : (this._flightQueue.push(s), s.loading = !0, this.loadFile(s))), !s.loaded && s.syncPoint && (e = !0), this._flightQueue.length >= i || e && this._loadedPackCount === this._totalPackCount) break
            }
            if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading(); else if (!this._flightQueue.length) {
                console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                var n = this;
                setTimeout(function () {
                    n.finishedLoading(!0)
                }, 2e3)
            }
        }, finishedLoading: function (t) {
            this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
        }, asyncComplete: function (t, e) {
            void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)), this.processLoadQueue()
        }, processPack: function (t) {
            var e = t.data[t.key];
            if (e) for (var i = 0; i < e.length; i++) {
                var s = e[i];
                switch (s.type) {
                    case"image":
                        this.image(s.key, s.url, s.overwrite);
                        break;
                    case"text":
                        this.text(s.key, s.url, s.overwrite);
                        break;
                    case"json":
                        this.json(s.key, s.url, s.overwrite);
                        break;
                    case"xml":
                        this.xml(s.key, s.url, s.overwrite);
                        break;
                    case"script":
                        this.script(s.key, s.url, s.callback, t.callbackContext || this);
                        break;
                    case"binary":
                        this.binary(s.key, s.url, s.callback, t.callbackContext || this);
                        break;
                    case"spritesheet":
                        this.spritesheet(s.key, s.url, s.frameWidth, s.frameHeight, s.frameMax, s.margin, s.spacing);
                        break;
                    case"video":
                        this.video(s.key, s.urls);
                        break;
                    case"audio":
                        this.audio(s.key, s.urls, s.autoDecode);
                        break;
                    case"audiosprite":
                        this.audiosprite(s.key, s.urls, s.jsonURL, s.jsonData, s.autoDecode);
                        break;
                    case"tilemap":
                        this.tilemap(s.key, s.url, s.data, j.Tilemap[s.format]);
                        break;
                    case"physics":
                        this.physics(s.key, s.url, s.data, j.Loader[s.format]);
                        break;
                    case"bitmapFont":
                        this.bitmapFont(s.key, s.textureURL, s.atlasURL, s.atlasData, s.xSpacing, s.ySpacing);
                        break;
                    case"atlasJSONArray":
                        this.atlasJSONArray(s.key, s.textureURL, s.atlasURL, s.atlasData);
                        break;
                    case"atlasJSONHash":
                        this.atlasJSONHash(s.key, s.textureURL, s.atlasURL, s.atlasData);
                        break;
                    case"atlasXML":
                        this.atlasXML(s.key, s.textureURL, s.atlasURL, s.atlasData);
                        break;
                    case"atlas":
                        this.atlas(s.key, s.textureURL, s.atlasURL, s.atlasData, j.Loader[s.format]);
                        break;
                    case"shader":
                        this.shader(s.key, s.url, s.overwrite)
                }
            } else console.warn("Phaser.Loader - " + t.key + ": pack has data, but not for pack key")
        }, transformUrl: function (t, e) {
            return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
        }, loadFile: function (t) {
            switch (t.type) {
                case"packfile":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                    break;
                case"image":
                case"spritesheet":
                case"textureatlas":
                case"bitmapfont":
                    this.loadImageTag(t);
                    break;
                case"audio":
                    t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                    break;
                case"video":
                    t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                    break;
                case"json":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                    break;
                case"xml":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                    break;
                case"tilemap":
                    t.format === j.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === j.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                    break;
                case"text":
                case"script":
                case"shader":
                case"physics":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                    break;
                case"binary":
                    this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
            }
        }, loadImageTag: function (t) {
            var e = this;
            t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function () {
                t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
            }, t.data.onerror = function () {
                t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
            }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
        }, loadVideoTag: function (t) {
            var e = this;
            t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1;
            var i = function () {
                t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !0, j.GAMES[e.game.id].load.fileComplete(t)
            };
            t.data.onerror = function () {
                t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
            }, t.data.addEventListener(t.loadEvent, i, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
        }, loadAudioTag: function (t) {
            var e = this;
            if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t); else {
                t.data = new Audio, t.data.name = t.key;
                var i = function () {
                    t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                };
                t.data.onerror = function () {
                    t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
            }
        }, xhrLoad: function (e, t, i, s, n) {
            if (this.useXDomainRequest && window.XDomainRequest) this.xhrLoadWithXDR(e, t, i, s, n); else {
                var r = new XMLHttpRequest;
                r.open("GET", t, !0), r.responseType = i, !1 !== this.headers.requestedWith && r.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[e.type] && r.setRequestHeader("Accept", this.headers[e.type]), n = n || this.fileError;
                var o = this;
                r.onload = function () {
                    try {
                        return 4 === r.readyState && 400 <= r.status && r.status <= 599 ? n.call(o, e, r) : s.call(o, e, r)
                    } catch (t) {
                        o.hasLoaded ? window.console && console.error(t) : o.asyncComplete(e, t.message || "Exception")
                    }
                }, r.onerror = function () {
                    try {
                        return n.call(o, e, r)
                    } catch (t) {
                        o.hasLoaded ? window.console && console.error(t) : o.asyncComplete(e, t.message || "Exception")
                    }
                }, e.requestObject = r, e.requestUrl = t, r.send()
            }
        }, xhrLoadWithXDR: function (e, t, i, s, n) {
            this._warnedAboutXDomainRequest || this.game.device.ie && !(10 <= this.game.device.ieVersion) || (this._warnedAboutXDomainRequest = !0, console.warn("Phaser.Loader - using XDomainRequest outside of IE 9"));
            var r = new window.XDomainRequest;
            r.open("GET", t, !0), r.responseType = i, r.timeout = 3e3, n = n || this.fileError;
            var o = this;
            r.onerror = function () {
                try {
                    return n.call(o, e, r)
                } catch (t) {
                    o.asyncComplete(e, t.message || "Exception")
                }
            }, r.ontimeout = function () {
                try {
                    return n.call(o, e, r)
                } catch (t) {
                    o.asyncComplete(e, t.message || "Exception")
                }
            }, r.onprogress = function () {
            }, r.onload = function () {
                try {
                    return 4 === r.readyState && 400 <= r.status && r.status <= 599 ? n.call(o, e, r) : s.call(o, e, r)
                } catch (t) {
                    o.asyncComplete(e, t.message || "Exception")
                }
            }, e.requestObject = r, e.requestUrl = t, setTimeout(function () {
                r.send()
            }, 0)
        }, getVideoURL: function (t) {
            for (var e = 0; e < t.length; e++) {
                var i, s = t[e];
                if (s.uri) {
                    if (i = s.type, s = s.uri, this.game.device.canPlayVideo(i)) return s
                } else {
                    if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                    if (0 <= s.indexOf("?") && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                }
            }
            return null
        }, getAudioURL: function (t) {
            if (this.game.sound.noAudio) return null;
            for (var e = 0; e < t.length; e++) {
                var i, s = t[e];
                if (s.uri) {
                    if (i = s.type, s = s.uri, this.game.device.canPlayAudio(i)) return s
                } else {
                    if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                    if (0 <= s.indexOf("?") && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                }
            }
            return null
        }, fileError: function (t, e, i) {
            var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
            !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
        }, fileComplete: function (e, t) {
            var i = !0;
            switch (e.type) {
                case"packfile":
                    var s = JSON.parse(t.responseText);
                    e.data = s || {};
                    break;
                case"image":
                    this.cache.addImage(e.key, e.url, e.data);
                    break;
                case"spritesheet":
                    this.cache.addSpriteSheet(e.key, e.url, e.data, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
                    break;
                case"textureatlas":
                    if (null == e.atlasURL) this.cache.addTextureAtlas(e.key, e.url, e.data, e.atlasData, e.format); else if (i = !1, e.format === j.Loader.TEXTURE_ATLAS_JSON_ARRAY || e.format === j.Loader.TEXTURE_ATLAS_JSON_HASH || e.format === j.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.jsonLoadComplete); else {
                        if (e.format !== j.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + e.format);
                        this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.xmlLoadComplete)
                    }
                    break;
                case"bitmapfont":
                    e.atlasURL ? (i = !1, this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", function (t, e) {
                        var i;
                        try {
                            i = JSON.parse(e.responseText)
                        } catch (t) {
                        }
                        i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                    })) : this.cache.addBitmapFont(e.key, e.url, e.data, e.atlasData, e.atlasType, e.xSpacing, e.ySpacing);
                    break;
                case"video":
                    if (e.asBlob) try {
                        e.data = t.response
                    } catch (t) {
                        throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + e.key)
                    }
                    this.cache.addVideo(e.key, e.url, e.data, e.asBlob);
                    break;
                case"audio":
                    this.game.sound.usingWebAudio ? (e.data = t.response, this.cache.addSound(e.key, e.url, e.data, !0, !1), e.autoDecode && this.game.sound.decode(e.key)) : this.cache.addSound(e.key, e.url, e.data, !1, !0);
                    break;
                case"text":
                    e.data = t.responseText, this.cache.addText(e.key, e.url, e.data);
                    break;
                case"shader":
                    e.data = t.responseText, this.cache.addShader(e.key, e.url, e.data);
                    break;
                case"physics":
                    s = JSON.parse(t.responseText);
                    this.cache.addPhysicsData(e.key, e.url, s, e.format);
                    break;
                case"script":
                    e.data = document.createElement("script"), e.data.language = "javascript", e.data.type = "text/javascript", e.data.defer = !1, e.data.text = t.responseText, document.head.appendChild(e.data), e.callback && (e.data = e.callback.call(e.callbackContext, e.key, t.responseText));
                    break;
                case"binary":
                    e.callback ? e.data = e.callback.call(e.callbackContext, e.key, t.response) : e.data = t.response, this.cache.addBinary(e.key, e.data)
            }
            i && this.asyncComplete(e)
        }, jsonLoadComplete: function (t, e) {
            var i = JSON.parse(e.responseText);
            "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
        }, csvLoadComplete: function (t, e) {
            var i = e.responseText;
            this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
        }, xmlLoadComplete: function (t, e) {
            var i = e.responseText, s = this.parseXml(i);
            if (!s) {
                var n = e.responseType || e.contentType;
                return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + n + ")"), void this.asyncComplete(t, "invalid XML")
            }
            "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s), this.asyncComplete(t)
        }, parseXml: function (t) {
            var e;
            try {
                if (window.DOMParser) e = (new DOMParser).parseFromString(t, "text/xml"); else (e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t)
            } catch (t) {
                e = null
            }
            return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
        }, updateProgress: function () {
            this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
        }, totalLoadedFiles: function () {
            return this._loadedFileCount
        }, totalQueuedFiles: function () {
            return this._totalFileCount - this._loadedFileCount
        }, totalLoadedPacks: function () {
            return this._totalPackCount
        }, totalQueuedPacks: function () {
            return this._totalPackCount - this._loadedPackCount
        }
    },Object.defineProperty(j.Loader.prototype, "progressFloat", {
        get: function () {
            var t = this._loadedFileCount / this._totalFileCount * 100;
            return j.Math.clamp(t || 0, 0, 100)
        }
    }),Object.defineProperty(j.Loader.prototype, "progress", {
        get: function () {
            return Math.round(this.progressFloat)
        }
    }),j.Loader.prototype.constructor = j.Loader,j.LoaderParser = {
        bitmapFont: function (t, e, i, s) {
            return this.xmlBitmapFont(t, e, i, s)
        }, xmlBitmapFont: function (t, e, i, s) {
            var n = {}, r = t.getElementsByTagName("info")[0], o = t.getElementsByTagName("common")[0];
            n.font = r.getAttribute("face"), n.size = parseInt(r.getAttribute("size"), 10), n.lineHeight = parseInt(o.getAttribute("lineHeight"), 10) + s, n.chars = {};
            for (var a = t.getElementsByTagName("char"), h = 0; h < a.length; h++) {
                var l = parseInt(a[h].getAttribute("id"), 10);
                n.chars[l] = {
                    x: parseInt(a[h].getAttribute("x"), 10),
                    y: parseInt(a[h].getAttribute("y"), 10),
                    width: parseInt(a[h].getAttribute("width"), 10),
                    height: parseInt(a[h].getAttribute("height"), 10),
                    xOffset: parseInt(a[h].getAttribute("xoffset"), 10),
                    yOffset: parseInt(a[h].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(a[h].getAttribute("xadvance"), 10) + i,
                    kerning: {}
                }
            }
            var c = t.getElementsByTagName("kerning");
            for (h = 0; h < c.length; h++) {
                var u = parseInt(c[h].getAttribute("first"), 10), d = parseInt(c[h].getAttribute("second"), 10),
                    p = parseInt(c[h].getAttribute("amount"), 10);
                n.chars[d].kerning[u] = p
            }
            return this.finalizeBitmapFont(e, n)
        }, jsonBitmapFont: function (t, e, i, s) {
            var n = {
                font: t.font.info._face,
                size: parseInt(t.font.info._size, 10),
                lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                chars: {}
            };
            return t.font.chars.char.forEach(function (t) {
                var e = parseInt(t._id, 10);
                n.chars[e] = {
                    x: parseInt(t._x, 10),
                    y: parseInt(t._y, 10),
                    width: parseInt(t._width, 10),
                    height: parseInt(t._height, 10),
                    xOffset: parseInt(t._xoffset, 10),
                    yOffset: parseInt(t._yoffset, 10),
                    xAdvance: parseInt(t._xadvance, 10) + i,
                    kerning: {}
                }
            }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function (t) {
                n.chars[t._second].kerning[t._first] = parseInt(t._amount, 10)
            }), this.finalizeBitmapFont(e, n)
        }, finalizeBitmapFont: function (i, s) {
            return Object.keys(s.chars).forEach(function (t) {
                var e = s.chars[t];
                e.texture = new PIXI.Texture(i, new j.Rectangle(e.x, e.y, e.width, e.height))
            }), s
        }
    },j.AudioSprite = function (t, e) {
        for (var i in this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {}, this.config.spritemap) {
            var s = this.config.spritemap[i], n = this.game.add.sound(this.key);
            n.addMarker(i, s.start, s.end - s.start, null, s.loop), this.sounds[i] = n
        }
        this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
    },j.AudioSprite.prototype = {
        play: function (t, e) {
            return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
        }, stop: function (t) {
            if (t) this.sounds[t].stop(); else for (var e in this.sounds) this.sounds[e].stop()
        }, get: function (t) {
            return this.sounds[t]
        }
    },j.AudioSprite.prototype.constructor = j.AudioSprite,j.Sound = function (t, e, i, s, n) {
        void 0 === i && (i = 1), void 0 === s && (s = !1), void 0 === n && (n = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = s, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = i * this.game.sound.volume, n && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new j.Signal, this.onPlay = new j.Signal, this.onPause = new j.Signal, this.onResume = new j.Signal, this.onLoop = new j.Signal, this.onStop = new j.Signal, this.onMute = new j.Signal, this.onMarkerComplete = new j.Signal, this.onFadeComplete = new j.Signal, this._volume = i, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
    },j.Sound.prototype = {
        soundHasUnlocked: function (t) {
            t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
        }, addMarker: function (t, e, i, s, n) {
            null == i && (i = 1), null == s && (s = 1), void 0 === n && (n = !1), this.markers[t] = {
                name: t,
                start: e,
                stop: e + i,
                volume: s,
                duration: i,
                durationMS: 1e3 * i,
                loop: n
            }
        }, removeMarker: function (t) {
            delete this.markers[t]
        }, onEndedHandler: function () {
            this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop()
        }, update: function () {
            this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))) : this.destroy()
        }, loopFull: function (t) {
            return this.play(null, 0, t, !0)
        }, play: function (t, e, i, s, n) {
            if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this;
            if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n)) {
                if (this.usingWebAudio) {
                    if (void 0 === this._sound.stop) this._sound.noteOff(0); else try {
                        this._sound.stop(0)
                    } catch (t) {
                    }
                    this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                this.isPlaying = !1
            }
            if ("" === t && 0 < Object.keys(this.markers).length) return this;
            if ("" !== t) {
                if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"), this;
                this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
            } else e = e || 0, void 0 === i && (i = this._volume), void 0 === s && (s = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
            return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
        }, restart: function (t, e, i, s) {
            t = t || "", e = e || 0, i = i || 1, void 0 === s && (s = !1), this.play(t, e, i, s, !0)
        }, pause: function () {
            this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
        }, resume: function () {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                    this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                    var e = this.duration - this.pausedPosition / 1e3;
                    void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)
                } else this._sound.currentTime = this._tempPause, this._sound.play();
                this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
            }
        }, stop: function () {
            if (this.isPlaying && this._sound) if (this.usingWebAudio) {
                if (void 0 === this._sound.stop) this._sound.noteOff(0); else try {
                    this._sound.stop(0)
                } catch (t) {
                }
                this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
            } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
            if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                var t = this.currentMarker;
                "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
            }
        }, fadeIn: function (t, e, i) {
            void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
        }, fadeOut: function (t) {
            this.fadeTo(t, 0)
        }, fadeTo: function (t, e) {
            this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3), void 0 !== e ? (this.fadeTween = this.game.add.tween(this).to({volume: e}, t, j.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)) : console.warn("Phaser.Sound.fadeTo: No Volume Specified."))
        }, fadeComplete: function () {
            this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
        }, updateGlobalVolume: function (t) {
            this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume)
        }, destroy: function (t) {
            void 0 === t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
        }
    },j.Sound.prototype.constructor = j.Sound,Object.defineProperty(j.Sound.prototype, "isDecoding", {
        get: function () {
            return this.game.cache.getSound(this.key).isDecoding
        }
    }),Object.defineProperty(j.Sound.prototype, "isDecoded", {
        get: function () {
            return this.game.cache.isSoundDecoded(this.key)
        }
    }),Object.defineProperty(j.Sound.prototype, "mute", {
        get: function () {
            return this._muted || this.game.sound.mute
        }, set: function (t) {
            (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
        }
    }),Object.defineProperty(j.Sound.prototype, "volume", {
        get: function () {
            return this._volume
        }, set: function (t) {
            this.game.device.firefox && this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t))
        }
    }),j.SoundManager = function (t) {
        this.game = t, this.onSoundDecode = new j.Signal, this.onVolumeChange = new j.Signal, this.onMute = new j.Signal, this.onUnMute = new j.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new j.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
    },j.SoundManager.prototype = {
        boot: function () {
            if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) {
                if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void (this.touchLocked = !1);
                if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void (this.touchLocked = !1)
            }
            if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext; else if (window.AudioContext) try {
                this.context = new window.AudioContext
            } catch (t) {
                this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
            } else if (window.webkitAudioContext) try {
                this.context = new window.webkitAudioContext
            } catch (t) {
                this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
            }
            if (null === this.context) {
                if (void 0 === window.Audio) return void (this.noAudio = !0);
                this.usingAudioTag = !0
            } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
            this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
        }, setTouchLock: function () {
            this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (8 < this.game.device.iOSVersion ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0)
        }, unlock: function () {
            if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
            if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null; else if (this.usingWebAudio) {
                var t = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0)
            }
            return !0
        }, stopAll: function () {
            if (!this.noAudio) for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
        }, pauseAll: function () {
            if (!this.noAudio) for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
        }, resumeAll: function () {
            if (!this.noAudio) for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
        }, decode: function (e, i) {
            i = i || null;
            var t = this.game.cache.getSoundData(e);
            if (t && !1 === this.game.cache.isSoundDecoded(e)) {
                this.game.cache.updateSound(e, "isDecoding", !0);
                var s = this;
                try {
                    this.context.decodeAudioData(t, function (t) {
                        t && (s.game.cache.decodedSound(e, t), s.onSoundDecode.dispatch(e, i))
                    })
                } catch (t) {
                }
            }
        }, setDecodedCallback: function (t, e, i) {
            "string" == typeof t && (t = [t]), this._watchList.reset();
            for (var s = 0; s < t.length; s++) t[s] instanceof j.Sound ? this.game.cache.isSoundDecoded(t[s].key) || this._watchList.add(t[s].key) : this.game.cache.isSoundDecoded(t[s]) || this._watchList.add(t[s]);
            0 === this._watchList.total ? (this._watching = !1, e.call(i)) : (this._watching = !0, this._watchCallback = e, this._watchContext = i)
        }, update: function () {
            if (!this.noAudio) {
                !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                if (this._watching) {
                    for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                    0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                }
            }
        }, add: function (t, e, i, s) {
            void 0 === e && (e = 1), void 0 === i && (i = !1), void 0 === s && (s = this.connectToMaster);
            var n = new j.Sound(this.game, t, e, i, s);
            return this._sounds.push(n), n
        }, addSprite: function (t) {
            return new j.AudioSprite(this.game, t)
        }, remove: function (t) {
            for (var e = this._sounds.length; e--;) if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
            return !1
        }, removeByKey: function (t) {
            for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
            return i
        }, play: function (t, e, i) {
            if (!this.noAudio) {
                var s = this.add(t, e, i);
                return s.play(), s
            }
        }, setMute: function () {
            if (!this._muted) {
                this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                this.onMute.dispatch()
            }
        }, unsetMute: function () {
            if (this._muted && !this._codeMuted) {
                this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                this.onUnMute.dispatch()
            }
        }, destroy: function () {
            this.stopAll();
            for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
            this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
        }
    },j.SoundManager.prototype.constructor = j.SoundManager,Object.defineProperty(j.SoundManager.prototype, "mute", {
        get: function () {
            return this._muted
        }, set: function (t) {
            if (t = t || !1) {
                if (this._muted) return;
                this._codeMuted = !0, this.setMute()
            } else {
                if (!this._muted) return;
                this._codeMuted = !1, this.unsetMute()
            }
        }
    }),Object.defineProperty(j.SoundManager.prototype, "volume", {
        get: function () {
            return this._volume
        }, set: function (t) {
            if (t < 0 ? t = 0 : 1 < t && (t = 1), this._volume !== t) {
                if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t; else for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                this.onVolumeChange.dispatch(t)
            }
        }
    }),j.ScaleManager = function (t, e, i) {
        this.game = t, this.dom = j.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new j.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new j.Signal, this.enterIncorrectOrientation = new j.Signal, this.leaveIncorrectOrientation = new j.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new j.Signal, this.onFullScreenChange = new j.Signal, this.onFullScreenError = new j.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new j.Point(1, 1), this.scaleFactorInversed = new j.Point(1, 1), this.margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            x: 0,
            y: 0
        }, this.bounds = new j.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
            right: "layout",
            bottom: ""
        }, this.compatibility = {
            supportsFullScreen: !1,
            orientationFallback: null,
            noMargins: !1,
            scrollTo: null,
            forceMinimumDocumentHeight: !1,
            canExpandParent: !0,
            clickTrampoline: ""
        }, this._scaleMode = j.ScaleManager.NO_SCALE, this._fullScreenScaleMode = j.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new j.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new j.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new j.Rectangle, this._userScaleFactor = new j.Point(1, 1), this._userScaleTrim = new j.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new j.Rectangle, this._tempBounds = new j.Rectangle, this._lastReportedCanvasSize = new j.Rectangle, this._lastReportedGameSize = new j.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, i)
    },j.ScaleManager.EXACT_FIT = 0,j.ScaleManager.NO_SCALE = 1,j.ScaleManager.SHOW_ALL = 2,j.ScaleManager.RESIZE = 3,j.ScaleManager.USER_SCALE = 4,j.ScaleManager.prototype = {
        boot: function () {
            var t = this.compatibility;
            t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new j.Point(0, 1) : t.scrollTo = new j.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
            var e = this;
            this._orientationChange = function (t) {
                return e.orientationChange(t)
            }, this._windowResize = function (t) {
                return e.windowResize(t)
            }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function (t) {
                return e.fullScreenChange(t)
            }, this._fullScreenError = function (t) {
                return e.fullScreenError(t)
            }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), j.FlexGrid && (this.grid = new j.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
        }, parseConfig: function (t) {
            void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
        }, setupScale: function (t, e) {
            var i, s = new j.Rectangle;
            "" !== this.game.parent && ("string" == typeof this.game.parent ? i = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (i = this.game.parent)), i ? (this.parentNode = i, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), s.width = this._parentBounds.width, s.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, s.width = this.dom.visualBounds.width, s.height = this.dom.visualBounds.height, this.offset.set(0, 0));
            var n = 0, r = 0;
            n = "number" == typeof t ? t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, s.width * this.parentScaleFactor.x), r = "number" == typeof e ? e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, s.height * this.parentScaleFactor.y), n = Math.floor(n), r = Math.floor(r), this._gameSize.setTo(0, 0, n, r), this.updateDimensions(n, r, !1)
        }, _gameResumed: function () {
            this.queueUpdate(!0)
        }, setGameSize: function (t, e) {
            this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== j.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
        }, setUserScale: function (t, e, i, s) {
            this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | s), this.queueUpdate(!0)
        }, setResizeCallback: function (t, e) {
            this.onResize = t, this.onResizeContext = e
        }, signalSizeChange: function () {
            if (!j.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !j.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                var t = this.width, e = this.height;
                this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === j.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
            }
        }, setMinMax: function (t, e, i, s) {
            this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== s && (this.maxHeight = s)
        }, preUpdate: function () {
            if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                var t = this._updateThrottle;
                this._updateThrottleReset = 400 <= t ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                var e = this._parentBounds.width, i = this._parentBounds.height,
                    s = this.getParentBounds(this._parentBounds), n = s.width !== e || s.height !== i,
                    r = this.updateOrientationState();
                (n || r) && (this.onResize && this.onResize.call(this.onResizeContext, this, s), this.updateLayout(), this.signalSizeChange());
                var o = 2 * this._updateThrottle;
                this._updateThrottle < t && (o = Math.min(t, this._updateThrottleReset)), this._updateThrottle = j.Math.clamp(o, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
            }
        }, pauseUpdate: function () {
            this.preUpdate(), this._updateThrottle = this.trackParentInterval
        }, updateDimensions: function (t, e, i) {
            this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
        }, updateScalingAndBounds: function () {
            this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
        }, forceOrientation: function (t, e) {
            void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)
        }, classifyOrientation: function (t) {
            return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
        }, updateOrientationState: function () {
            var t = this.screenOrientation, e = this.incorrectOrientation;
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
            var i = t !== this.screenOrientation, s = e !== this.incorrectOrientation;
            return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || s) && this.onOrientationChange.dispatch(this, t, e), i || s
        }, orientationChange: function (t) {
            this.event = t, this.queueUpdate(!0)
        }, windowResize: function (t) {
            this.event = t, this.queueUpdate(!0)
        }, scrollTop: function () {
            var t = this.compatibility.scrollTo;
            t && window.scrollTo(t.x, t.y)
        }, refresh: function () {
            this.scrollTop(), this.queueUpdate(!0)
        }, updateLayout: function () {
            var t = this.currentScaleMode;
            if (t !== j.ScaleManager.RESIZE) {
                if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === j.ScaleManager.EXACT_FIT ? this.setExactFit() : t === j.ScaleManager.SHOW_ALL ? (!this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent && (this.setShowAll(!0), this.resetCanvas()), this.setShowAll()) : t === j.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === j.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === j.ScaleManager.SHOW_ALL || t === j.ScaleManager.USER_SCALE)) {
                    var e = this.getParentBounds(this._tempBounds);
                    this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                }
                this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
            } else this.reflowGame()
        }, getParentBounds: function (t) {
            var e = t || new j.Rectangle, i = this.boundingParent, s = this.dom.visualBounds, n = this.dom.layoutBounds;
            if (i) {
                var r = i.getBoundingClientRect(),
                    o = i.offsetParent ? i.offsetParent.getBoundingClientRect() : i.getBoundingClientRect();
                e.setTo(r.left - o.left, r.top - o.top, r.width, r.height);
                var a = this.windowConstraints;
                if (a.right) {
                    var h = "layout" === a.right ? n : s;
                    e.right = Math.min(e.right, h.width)
                }
                if (a.bottom) {
                    h = "layout" === a.bottom ? n : s;
                    e.bottom = Math.min(e.bottom, h.height)
                }
            } else e.setTo(0, 0, s.width, s.height);
            return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e
        }, alignCanvas: function (t, e) {
            var i = this.getParentBounds(this._tempBounds), s = this.game.canvas, n = this.margin;
            if (t) {
                n.left = n.right = 0;
                var r = s.getBoundingClientRect();
                if (this.width < i.width && !this.incorrectOrientation) {
                    var o = r.left - i.x, a = i.width / 2 - this.width / 2, h = (a = Math.max(a, 0)) - o;
                    n.left = Math.round(h)
                }
                s.style.marginLeft = n.left + "px", 0 !== n.left && (n.right = -(i.width - r.width - n.left), s.style.marginRight = n.right + "px")
            }
            if (e) {
                n.top = n.bottom = 0;
                r = s.getBoundingClientRect();
                if (this.height < i.height && !this.incorrectOrientation) {
                    o = r.top - i.y, a = i.height / 2 - this.height / 2, h = (a = Math.max(a, 0)) - o;
                    n.top = Math.round(h)
                }
                s.style.marginTop = n.top + "px", 0 !== n.top && (n.bottom = -(i.height - r.height - n.top), s.style.marginBottom = n.bottom + "px")
            }
            n.x = n.left, n.y = n.top
        }, reflowGame: function () {
            this.resetCanvas("", "");
            var t = this.getParentBounds(this._tempBounds);
            this.updateDimensions(t.width, t.height, !0)
        }, reflowCanvas: function () {
            this.incorrectOrientation || (this.width = j.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = j.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
        }, resetCanvas: function (t, e) {
            void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
            var i = this.game.canvas;
            this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
        }, queueUpdate: function (t) {
            t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
        }, reset: function (t) {
            t && this.grid && this.grid.reset()
        }, setMaximum: function () {
            this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
        }, setShowAll: function (t) {
            var e, i = this.getParentBounds(this._tempBounds), s = i.width, n = i.height;
            e = t ? Math.max(n / this.game.height, s / this.game.width) : Math.min(n / this.game.height, s / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
        }, setExactFit: function () {
            var t = this.getParentBounds(this._tempBounds);
            this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
        }, createFullScreenTarget: function () {
            var t = document.createElement("div");
            return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
        }, startFullScreen: function (t, e) {
            if (this.isFullScreen) return !1;
            if (this.compatibility.supportsFullScreen) {
                if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                    var i = this.game.input;
                    if (i.activePointer && i.activePointer !== i.mousePointer && (e || !1 !== e)) return void i.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                }
                void 0 !== t && this.game.renderType === j.CANVAS && (this.game.stage.smoothed = t);
                var s = this.fullScreenTarget;
                s || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), s = this._createdFullScreenTarget);
                var n = {targetElement: s};
                if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, n), this._createdFullScreenTarget) {
                    var r = this.game.canvas;
                    r.parentNode.insertBefore(s, r), s.appendChild(r)
                }
                return this.game.device.fullscreenKeyboard ? s[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : s[this.game.device.requestFullscreen](), !0
            }
            var o = this;
            setTimeout(function () {
                o.fullScreenError()
            }, 10)
        }, stopFullScreen: function () {
            return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
        }, cleanupCreatedTarget: function () {
            var t = this._createdFullScreenTarget;
            if (t && t.parentNode) {
                var e = t.parentNode;
                e.insertBefore(this.game.canvas, t), e.removeChild(t)
            }
            this._createdFullScreenTarget = null
        }, prepScreenMode: function (t) {
            var e = !!this._createdFullScreenTarget, i = this._createdFullScreenTarget || this.fullScreenTarget;
            t ? (e || this.fullScreenScaleMode === j.ScaleManager.EXACT_FIT) && i !== this.game.canvas && (this._fullScreenRestore = {
                targetWidth: i.style.width,
                targetHeight: i.style.height
            }, i.style.width = "100%", i.style.height = "100%") : (this._fullScreenRestore && (i.style.width = this._fullScreenRestore.targetWidth, i.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
        }, fullScreenChange: function (t) {
            this.event = t, this.isFullScreen ? this.prepScreenMode(!0) : (this.prepScreenMode(!1), this.cleanupCreatedTarget()), this.updateLayout(), this.queueUpdate(!0), this.onFullScreenChange.dispatch(this, this.width, this.height)
        }, fullScreenError: function (t) {
            this.event = t, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this)
        }, scaleSprite: function (t, e, i, s) {
            if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
            if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
            var n = e, r = t.height * e / t.width, o = t.width * i / t.height, a = i, h = e < o;
            return h = h ? s : !s, t.height = h ? (t.width = Math.floor(n), Math.floor(r)) : (t.width = Math.floor(o), Math.floor(a)), t
        }, destroy: function () {
            this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
        }
    },j.ScaleManager.prototype.constructor = j.ScaleManager,Object.defineProperty(j.ScaleManager.prototype, "boundingParent", {
        get: function () {
            return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "scaleMode", {
        get: function () {
            return this._scaleMode
        }, set: function (t) {
            return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "fullScreenScaleMode", {
        get: function () {
            return this._fullScreenScaleMode
        }, set: function (t) {
            return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "currentScaleMode", {
        get: function () {
            return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "pageAlignHorizontally", {
        get: function () {
            return this._pageAlignHorizontally
        }, set: function (t) {
            t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "pageAlignVertically", {
        get: function () {
            return this._pageAlignVertically
        }, set: function (t) {
            t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "isFullScreen", {
        get: function () {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "isPortrait", {
        get: function () {
            return "portrait" === this.classifyOrientation(this.screenOrientation)
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "isLandscape", {
        get: function () {
            return "landscape" === this.classifyOrientation(this.screenOrientation)
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "isGamePortrait", {
        get: function () {
            return this.height > this.width
        }
    }),Object.defineProperty(j.ScaleManager.prototype, "isGameLandscape", {
        get: function () {
            return this.width > this.height
        }
    }),j.Utils.Debug = function (t) {
        this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
    },j.Utils.Debug.prototype = {
        boot: function () {
            this.game.renderType === j.CANVAS ? this.context = this.game.context : (this.bmd = new j.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"))
        }, resize: function (t, e, i) {
            this.bmd.resize(e, i), this.canvas.width = e, this.canvas.height = i
        }, preUpdate: function () {
            this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
        }, reset: function () {
            this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
        }, start: function (t, e, i, s) {
            "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = s, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
        }, stop: function () {
            this.context.restore()
        }, line: function () {
            for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
            this.currentY += this.lineHeight
        }, soundInfo: function (t, e, i, s) {
            this.start(e, i, s), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
        }, cameraInfo: function (t, e, i, s) {
            this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.line("Total in view: " + t.totalInView), this.stop()
        }, timer: function (t, e, i, s) {
            this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
        }, pointer: function (t, e, i, s, n) {
            null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = s, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
        }, spriteInputInfo: function (t, e, i, s) {
            this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
        }, key: function (t, e, i, s) {
            this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
        }, inputInfo: function (t, e, i) {
            this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
        }, spriteBounds: function (t, e, i) {
            var s = t.getBounds();
            s.x += this.game.camera.x, s.y += this.game.camera.y, this.rectangle(s, e, i)
        }, ropeSegments: function (t, e, i) {
            var s = t.segments, n = this;
            s.forEach(function (t) {
                n.rectangle(t, e, i)
            }, this)
        }, spriteInfo: function (t, e, i, s) {
            this.start(e, i, s), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop()
        }, spriteCoords: function (t, e, i, s) {
            this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
        }, lineInfo: function (t, e, i, s) {
            this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
        }, pixel: function (t, e, i, s) {
            s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
        }, geom: function (t, e, i, s) {
            void 0 === i && (i = !0), void 0 === s && (s = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof j.Rectangle || 1 === s ? i ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof j.Circle || 2 === s ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), i ? this.context.fill() : this.context.stroke()) : t instanceof j.Point || 3 === s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof j.Line || 4 === s) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
        }, rectangle: function (t, e, i) {
            void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
        }, text: function (t, e, i, s, n) {
            s = s || "rgb(255,255,255)", n = n || "16px Courier", this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
        }, quadTree: function (t, e) {
            e = e || "rgba(255,0,0,0.3)", this.start();
            var i = t.bounds;
            if (0 === t.nodes.length) {
                this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                for (var s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
            } else for (s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
            this.stop()
        }, body: function (t, e, i) {
            t.body && (this.start(), t.body.type === j.Physics.ARCADE ? j.Physics.Arcade.Body.render(this.context, t.body, e, i) : t.body.type === j.Physics.NINJA ? j.Physics.Ninja.Body.render(this.context, t.body, e, i) : t.body.type === j.Physics.BOX2D && j.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
        }, bodyInfo: function (t, e, i, s) {
            t.body && (this.start(e, i, s, 210), t.body.type === j.Physics.ARCADE ? j.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === j.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
        }, box2dWorld: function () {
            this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
        }, box2dBody: function (t, e) {
            this.start(), j.Physics.Box2D.renderBody(this.context, t, e), this.stop()
        }, displayList: function (t) {
            if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID") ? console.log("[" + t.renderOrderID + "]", t) : console.log("[]", t), t.children && 0 < t.children.length) for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
        }, destroy: function () {
            PIXI.CanvasPool.remove(this)
        }
    },j.Utils.Debug.prototype.constructor = j.Utils.Debug,j.DOM = {
        getOffset: function (t, e) {
            e = e || new j.Point;
            var i = t.getBoundingClientRect(), s = j.DOM.scrollY, n = j.DOM.scrollX,
                r = document.documentElement.clientTop, o = document.documentElement.clientLeft;
            return e.x = i.left + n - o, e.y = i.top + s - r, e
        }, getBounds: function (t, e) {
            return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
        }, calibrate: function (t, e) {
            e = +e || 0;
            var i = {width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0};
            return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
        }, getAspectRatio: function (t) {
            var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width, i = t.height;
            return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
        }, inLayoutViewport: function (t, e) {
            var i = this.getBounds(t, e);
            return !!i && 0 <= i.bottom && 0 <= i.right && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
        }, getScreenOrientation: function (t) {
            var e = window.screen, i = e.orientation || e.mozOrientation || e.msOrientation;
            if (i && "string" == typeof i.type) return i.type;
            if ("string" == typeof i) return i;
            var s = "portrait-primary", n = "landscape-primary";
            if ("screen" === t) return e.height > e.width ? s : n;
            if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s : n;
            if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s : n;
            if (window.matchMedia) {
                if (window.matchMedia("(orientation: portrait)").matches) return s;
                if (window.matchMedia("(orientation: landscape)").matches) return n
            }
            return this.visualBounds.height > this.visualBounds.width ? s : n
        }, visualBounds: new j.Rectangle, layoutBounds: new j.Rectangle, documentBounds: new j.Rectangle
    },j.Device.whenReady(function (t) {
        var e = window && "pageXOffset" in window ? function () {
            return window.pageXOffset
        } : function () {
            return document.documentElement.scrollLeft
        }, i = window && "pageYOffset" in window ? function () {
            return window.pageYOffset
        } : function () {
            return document.documentElement.scrollTop
        };
        if (Object.defineProperty(j.DOM, "scrollX", {get: e}), Object.defineProperty(j.DOM, "scrollY", {get: i}), Object.defineProperty(j.DOM.visualBounds, "x", {get: e}), Object.defineProperty(j.DOM.visualBounds, "y", {get: i}), Object.defineProperty(j.DOM.layoutBounds, "x", {value: 0}), Object.defineProperty(j.DOM.layoutBounds, "y", {value: 0}), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
            var s = function () {
                return Math.max(window.innerWidth, document.documentElement.clientWidth)
            }, n = function () {
                return Math.max(window.innerHeight, document.documentElement.clientHeight)
            };
            Object.defineProperty(j.DOM.visualBounds, "width", {get: s}), Object.defineProperty(j.DOM.visualBounds, "height", {get: n}), Object.defineProperty(j.DOM.layoutBounds, "width", {get: s}), Object.defineProperty(j.DOM.layoutBounds, "height", {get: n})
        } else Object.defineProperty(j.DOM.visualBounds, "width", {
            get: function () {
                return window.innerWidth
            }
        }), Object.defineProperty(j.DOM.visualBounds, "height", {
            get: function () {
                return window.innerHeight
            }
        }), Object.defineProperty(j.DOM.layoutBounds, "width", {
            get: function () {
                var t = document.documentElement.clientWidth, e = window.innerWidth;
                return t < e ? e : t
            }
        }), Object.defineProperty(j.DOM.layoutBounds, "height", {
            get: function () {
                var t = document.documentElement.clientHeight, e = window.innerHeight;
                return t < e ? e : t
            }
        });
        Object.defineProperty(j.DOM.documentBounds, "x", {value: 0}), Object.defineProperty(j.DOM.documentBounds, "y", {value: 0}), Object.defineProperty(j.DOM.documentBounds, "width", {
            get: function () {
                var t = document.documentElement;
                return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
            }
        }), Object.defineProperty(j.DOM.documentBounds, "height", {
            get: function () {
                var t = document.documentElement;
                return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
            }
        })
    }, null, !0),j.ArraySet = function (t) {
        this.position = 0, this.list = t || []
    },j.ArraySet.prototype = {
        add: function (t) {
            return this.exists(t) || this.list.push(t), t
        }, getIndex: function (t) {
            return this.list.indexOf(t)
        }, getByKey: function (t, e) {
            for (var i = this.list.length; i--;) if (this.list[i][t] === e) return this.list[i];
            return null
        }, exists: function (t) {
            return -1 < this.list.indexOf(t)
        }, reset: function () {
            this.list.length = 0
        }, remove: function (t) {
            var e = this.list.indexOf(t);
            if (-1 < e) return this.list.splice(e, 1), t
        }, setAll: function (t, e) {
            for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
        }, callAll: function (t) {
            for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
        }, removeAll: function (t) {
            void 0 === t && (t = !1);
            for (var e = this.list.length; e--;) if (this.list[e]) {
                var i = this.remove(this.list[e]);
                t && i.destroy()
            }
            this.position = 0, this.list = []
        }
    },Object.defineProperty(j.ArraySet.prototype, "total", {
        get: function () {
            return this.list.length
        }
    }),Object.defineProperty(j.ArraySet.prototype, "first", {
        get: function () {
            return (this.position = 0) < this.list.length ? this.list[0] : null
        }
    }),Object.defineProperty(j.ArraySet.prototype, "next", {
        get: function () {
            return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
        }
    }),j.ArraySet.prototype.constructor = j.ArraySet,j.ArrayUtils = {
        getRandomItem: function (t, e, i) {
            if (null === t) return null;
            void 0 === e && (e = 0), void 0 === i && (i = t.length);
            var s = e + Math.floor(Math.random() * i);
            return void 0 === t[s] ? null : t[s]
        }, removeRandomItem: function (t, e, i) {
            if (null == t) return null;
            void 0 === e && (e = 0), void 0 === i && (i = t.length);
            var s = e + Math.floor(Math.random() * i);
            if (s < t.length) {
                var n = t.splice(s, 1);
                return void 0 === n[0] ? null : n[0]
            }
            return null
        }, shuffle: function (t) {
            for (var e = t.length - 1; 0 < e; e--) {
                var i = Math.floor(Math.random() * (e + 1)), s = t[e];
                t[e] = t[i], t[i] = s
            }
            return t
        }, transposeMatrix: function (t) {
            for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                s[n] = new Array(e);
                for (var r = e - 1; -1 < r; r--) s[n][r] = t[r][n]
            }
            return s
        }, rotateMatrix: function (t, e) {
            if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = (t = j.ArrayUtils.transposeMatrix(t)).reverse(); else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = j.ArrayUtils.transposeMatrix(t); else if (180 === Math.abs(e) || "rotate180" === e) {
                for (var i = 0; i < t.length; i++) t[i].reverse();
                t = t.reverse()
            }
            return t
        }, findClosest: function (t, e) {
            if (!e.length) return NaN;
            if (1 === e.length || t < e[0]) return e[0];
            for (var i = 1; e[i] < t;) i++;
            var s = e[i - 1], n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
            return n - t <= t - s ? n : s
        }, rotateRight: function (t) {
            var e = t.pop();
            return t.unshift(e), e
        }, rotateLeft: function (t) {
            var e = t.shift();
            return t.push(e), e
        }, rotate: function (t) {
            var e = t.shift();
            return t.push(e), e
        }, numberArray: function (t, e) {
            for (var i = [], s = t; s <= e; s++) i.push(s);
            return i
        }, numberArrayStep: function (t, e, i) {
            null == t && (t = 0), null == e && (e = t, t = 0), void 0 === i && (i = 1);
            for (var s = [], n = Math.max(j.Math.roundAwayFromZero((e - t) / (i || 1)), 0), r = 0; r < n; r++) s.push(t), t += i;
            return s
        }
    },j.LinkedList = function () {
        this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
    },j.LinkedList.prototype = {
        add: function (t) {
            return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, ((this.next = t).prev = this).total++) : ((this.last.next = t).prev = this.last, this.last = t, this.total++), t
        }, reset: function () {
            this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
        }, remove: function (t) {
            if (1 === this.total) return this.reset(), void (t.next = t.prev = null);
            t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
        }, callAll: function (t) {
            if (this.first && this.last) for (var e = this.first; e && e[t] && e[t].call(e), (e = e.next) !== this.last.next;) ;
        }
    },j.LinkedList.prototype.constructor = j.LinkedList,j.Create = function (t) {
        this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
            0: "#000",
            1: "#9D9D9D",
            2: "#FFF",
            3: "#BE2633",
            4: "#E06F8B",
            5: "#493C2B",
            6: "#A46422",
            7: "#EB8931",
            8: "#F7E26B",
            9: "#2F484E",
            A: "#44891A",
            B: "#A3CE27",
            C: "#1B2632",
            D: "#005784",
            E: "#31A2F2",
            F: "#B2DCEF"
        }, {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#f5f4eb"
        }, {
            0: "#000",
            1: "#2234d1",
            2: "#0c7e45",
            3: "#44aacc",
            4: "#8a3622",
            5: "#5c2e78",
            6: "#aa5c3d",
            7: "#b5b5b5",
            8: "#5e606e",
            9: "#4c81fb",
            A: "#6cd947",
            B: "#7be2f9",
            C: "#eb8a60",
            D: "#e23d69",
            E: "#ffd93f",
            F: "#fff"
        }, {
            0: "#000",
            1: "#fff",
            2: "#8b4131",
            3: "#7bbdc5",
            4: "#8b41ac",
            5: "#6aac41",
            6: "#3931a4",
            7: "#d5de73",
            8: "#945a20",
            9: "#5a4100",
            A: "#bd736a",
            B: "#525252",
            C: "#838383",
            D: "#acee8b",
            E: "#7b73de",
            F: "#acacac"
        }, {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#fff"
        }]
    },j.Create.PALETTE_ARNE = 0,j.Create.PALETTE_JMP = 1,j.Create.PALETTE_CGA = 2,j.Create.PALETTE_C64 = 3,j.Create.PALETTE_JAPANESE_MACHINE = 4,j.Create.prototype = {
        texture: function (t, e, i, s, n) {
            void 0 === i && (i = 8), void 0 === s && (s = i), void 0 === n && (n = 0);
            var r = e[0].length * i, o = e.length * s;
            null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(r, o), this.bmd.clear();
            for (var a = 0; a < e.length; a++) for (var h = e[a], l = 0; l < h.length; l++) {
                var c = h[l];
                "." !== c && " " !== c && (this.ctx.fillStyle = this.palettes[n][c], this.ctx.fillRect(l * i, a * s, i, s))
            }
            return this.bmd.generateTexture(t)
        }, grid: function (t, e, i, s, n, r) {
            null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = r;
            for (var o = 0; o < i; o += n) this.ctx.fillRect(0, o, e, 1);
            for (var a = 0; a < e; a += s) this.ctx.fillRect(a, 0, 1, i);
            return this.bmd.generateTexture(t)
        }
    },j.Create.prototype.constructor = j.Create,j.Color = {
        valueToColor: function (t, e) {
            if ("string" == typeof t) return 0 === t.indexOf("rgb") ? j.Color.webToColor(t, e) : (e.a = 1, j.Color.hexToColor(t, e));
            if ("number" != typeof t) return e;
            var i = j.Color.getRGB(t);
            return e.r = i.r, e.g = i.g, e.b = i.b, e.a = i.a / 255, e
        }, getRGB: function (t) {
            return 16777215 < t ? {
                alpha: t >>> 24,
                red: t >> 16 & 255,
                green: t >> 8 & 255,
                blue: 255 & t,
                a: t >>> 24,
                r: t >> 16 & 255,
                g: t >> 8 & 255,
                b: 255 & t
            } : {
                alpha: 255,
                red: t >> 16 & 255,
                green: t >> 8 & 255,
                blue: 255 & t,
                a: 255,
                r: t >> 16 & 255,
                g: t >> 8 & 255,
                b: 255 & t
            }
        }, webToColor: function (t, e) {
            var i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
            return i && (e.r = parseInt(i[1], 10), e.g = parseInt(i[2], 10), e.b = parseInt(i[3], 10), e.a = void 0 !== i[4] ? parseFloat(i[4]) : 1, j.Color.updateColor(e)), e
        }, hexToColor: function (t, e) {
            t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (t, e, i, s) {
                return e + e + i + i + s + s
            });
            var i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
            if (i) {
                var s = parseInt(i[1], 16), n = parseInt(i[2], 16), r = parseInt(i[3], 16);
                e.r = s, e.g = n, e.b = r
            }
            return e
        }, updateColor: function (t) {
            return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = j.Color.getColor(t.r, t.g, t.b), t.color32 = j.Color.getColor32(t.a, t.r, t.g, t.b), t
        }, getColor32: function (t, e, i, s) {
            return t << 24 | e << 16 | i << 8 | s
        }, getColor: function (t, e, i) {
            return t << 16 | e << 8 | i
        }
    },j.Physics = function (t, e) {
        e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
    },j.Physics.ARCADE = 0,j.Physics.P2JS = 1,j.Physics.NINJA = 2,j.Physics.BOX2D = 3,j.Physics.CHIPMUNK = 4,j.Physics.MATTERJS = 5,j.Physics.prototype = {
        parseConfig: function () {
            this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !j.Physics.hasOwnProperty("Arcade") || (this.arcade = new j.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && j.Physics.hasOwnProperty("Ninja") && (this.ninja = new j.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && j.Physics.hasOwnProperty("P2") && (this.p2 = new j.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && j.Physics.hasOwnProperty("BOX2D") && (this.box2d = new j.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && j.Physics.hasOwnProperty("Matter") && (this.matter = new j.Physics.Matter(this.game, this.config))
        }, startSystem: function (t) {
            t === j.Physics.ARCADE ? this.arcade = new j.Physics.Arcade(this.game) : t === j.Physics.P2JS ? null === this.p2 ? this.p2 = new j.Physics.P2(this.game, this.config) : this.p2.reset() : t === j.Physics.NINJA ? this.ninja = new j.Physics.Ninja(this.game) : t === j.Physics.BOX2D ? null === this.box2d ? this.box2d = new j.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === j.Physics.MATTERJS && (null === this.matter ? this.matter = new j.Physics.Matter(this.game, this.config) : this.matter.reset())
        }, enable: function (t, e, i) {
            void 0 === e && (e = j.Physics.ARCADE), void 0 === i && (i = !1), e === j.Physics.ARCADE ? this.arcade.enable(t) : e === j.Physics.P2JS && this.p2 ? this.p2.enable(t, i) : e === j.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === j.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === j.Physics.MATTERJS && this.matter ? this.matter.enable(t) : console.warn(t.key + " is attempting to enable a physics body using an unknown physics system.")
        }, preUpdate: function () {
            this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
        }, update: function () {
            this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
        }, setBoundsToWorld: function () {
            this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
        }, clear: function () {
            this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
        }, reset: function () {
            this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
        }, destroy: function () {
            this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
        }
    },j.Physics.prototype.constructor = j.Physics,j.Physics.Arcade = function (t) {
        this.game = t, this.gravity = new j.Point, this.bounds = new j.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
            up: !0,
            down: !0,
            left: !0,
            right: !0
        }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = j.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new j.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
    },j.Physics.Arcade.prototype.constructor = j.Physics.Arcade,j.Physics.Arcade.SORT_NONE = 0,j.Physics.Arcade.LEFT_RIGHT = 1,j.Physics.Arcade.RIGHT_LEFT = 2,j.Physics.Arcade.TOP_BOTTOM = 3,j.Physics.Arcade.BOTTOM_TOP = 4,j.Physics.Arcade.prototype = {
        setBounds: function (t, e, i, s) {
            this.bounds.setTo(t, e, i, s)
        }, setBoundsToWorld: function () {
            this.bounds.copyFrom(this.game.world.bounds)
        }, enable: function (t, e) {
            void 0 === e && (e = !0);
            var i = 1;
            if (Array.isArray(t)) for (i = t.length; i--;) t[i] instanceof j.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]), e && t[i].hasOwnProperty("children") && 0 < t[i].children.length && this.enable(t[i], !0)); else t instanceof j.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && 0 < t.children.length && this.enable(t.children, !0))
        }, enableBody: function (t) {
            t.hasOwnProperty("body") && null === t.body && (t.body = new j.Physics.Arcade.Body(t), t.parent && t.parent instanceof j.Group && t.parent.addToHash(t))
        }, updateMotion: function (t) {
            var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
            t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
        }, computeVelocity: function (t, e, i, s, n, r) {
            return void 0 === r && (r = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), s ? i += s * this.game.time.physicsElapsed : n && (0 < i - (n *= this.game.time.physicsElapsed) ? i -= n : i + n < 0 ? i += n : i = 0), r < i ? i = r : i < -r && (i = -r), i
        }, overlap: function (t, e, i, s, n) {
            if (i = i || null, s = s || null, n = n || i, this._total = 0, !Array.isArray(t) && Array.isArray(e)) for (var r = 0; r < e.length; r++) this.collideHandler(t, e[r], i, s, n, !0); else if (Array.isArray(t) && !Array.isArray(e)) for (r = 0; r < t.length; r++) this.collideHandler(t[r], e, i, s, n, !0); else if (Array.isArray(t) && Array.isArray(e)) for (r = 0; r < t.length; r++) for (var o = 0; o < e.length; o++) this.collideHandler(t[r], e[o], i, s, n, !0); else this.collideHandler(t, e, i, s, n, !0);
            return 0 < this._total
        }, collide: function (t, e, i, s, n) {
            if (i = i || null, s = s || null, n = n || i, this._total = 0, !Array.isArray(t) && Array.isArray(e)) for (var r = 0; r < e.length; r++) this.collideHandler(t, e[r], i, s, n, !1); else if (Array.isArray(t) && !Array.isArray(e)) for (r = 0; r < t.length; r++) this.collideHandler(t[r], e, i, s, n, !1); else if (Array.isArray(t) && Array.isArray(e)) for (r = 0; r < t.length; r++) for (var o = 0; o < e.length; o++) this.collideHandler(t[r], e[o], i, s, n, !1); else this.collideHandler(t, e, i, s, n, !1);
            return 0 < this._total
        }, sortLeftRight: function (t, e) {
            return t.body && e.body ? t.body.x - e.body.x : 0
        }, sortRightLeft: function (t, e) {
            return t.body && e.body ? e.body.x - t.body.x : 0
        }, sortTopBottom: function (t, e) {
            return t.body && e.body ? t.body.y - e.body.y : 0
        }, sortBottomTop: function (t, e) {
            return t.body && e.body ? e.body.y - t.body.y : 0
        }, sort: function (t, e) {
            null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === j.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === j.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === j.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === j.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
        }, collideHandler: function (t, e, i, s, n, r) {
            if (void 0 === e && t.physicsType === j.GROUP) return this.sort(t), void this.collideGroupVsSelf(t, i, s, n, r);
            t && e && t.exists && e.exists && (this.sortDirection !== j.Physics.Arcade.SORT_NONE && (t.physicsType === j.GROUP && this.sort(t), e.physicsType === j.GROUP && this.sort(e)), t.physicsType === j.SPRITE ? e.physicsType === j.SPRITE ? this.collideSpriteVsSprite(t, e, i, s, n, r) : e.physicsType === j.GROUP ? this.collideSpriteVsGroup(t, e, i, s, n, r) : e.physicsType === j.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, i, s, n, r) : t.physicsType === j.GROUP ? e.physicsType === j.SPRITE ? this.collideSpriteVsGroup(e, t, i, s, n, r) : e.physicsType === j.GROUP ? this.collideGroupVsGroup(t, e, i, s, n, r) : e.physicsType === j.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, i, s, n, r) : t.physicsType === j.TILEMAPLAYER && (e.physicsType === j.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, i, s, n, r) : e.physicsType === j.GROUP && this.collideGroupVsTilemapLayer(e, t, i, s, n, r)))
        }, collideSpriteVsSprite: function (t, e, i, s, n, r) {
            return !(!t.body || !e.body) && (this.separate(t.body, e.body, s, n, r) && (i && i.call(n, t, e), this._total++), !0)
        }, collideSpriteVsGroup: function (t, e, i, s, n, r) {
            if (0 !== e.length && t.body) if (this.skipQuadTree || t.body.skipQuadTree) for (var o = {}, a = 0; a < e.hash.length; a++) {
                var h = e.hash[a];
                if (h && h.exists && h.body) {
                    if (o = h.body.getBounds(o), this.sortDirection === j.Physics.Arcade.LEFT_RIGHT) {
                        if (t.body.right < o.x) break;
                        if (o.right < t.body.x) continue
                    } else if (this.sortDirection === j.Physics.Arcade.RIGHT_LEFT) {
                        if (t.body.x > o.right) break;
                        if (o.x > t.body.right) continue
                    } else if (this.sortDirection === j.Physics.Arcade.TOP_BOTTOM) {
                        if (t.body.bottom < o.y) break;
                        if (o.bottom < t.body.y) continue
                    } else if (this.sortDirection === j.Physics.Arcade.BOTTOM_TOP) {
                        if (t.body.y > o.bottom) break;
                        if (o.y > t.body.bottom) continue
                    }
                    this.collideSpriteVsSprite(t, h, i, s, n, r)
                }
            } else {
                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                var l = this.quadTree.retrieve(t);
                for (a = 0; a < l.length; a++) this.separate(t.body, l[a], s, n, r) && (i && i.call(n, t, l[a].sprite), this._total++)
            }
        }, collideGroupVsSelf: function (t, e, i, s, n) {
            if (0 !== t.length) for (var r = 0; r < t.hash.length; r++) {
                var o = {}, a = t.hash[r];
                if (a && a.exists && a.body) {
                    o = a.body.getBounds(o);
                    for (var h = r + 1; h < t.hash.length; h++) {
                        var l = {}, c = t.hash[h];
                        if (c && c.exists && c.body) {
                            if (l = c.body.getBounds(l), this.sortDirection === j.Physics.Arcade.LEFT_RIGHT) {
                                if (o.right < l.x) break;
                                if (l.right < o.x) continue
                            } else if (this.sortDirection === j.Physics.Arcade.RIGHT_LEFT) {
                                if (o.x > l.right) continue;
                                if (l.x > o.right) break
                            } else if (this.sortDirection === j.Physics.Arcade.TOP_BOTTOM) {
                                if (o.bottom < l.y) continue;
                                if (l.bottom < o.y) break
                            } else if (this.sortDirection === j.Physics.Arcade.BOTTOM_TOP) {
                                if (o.y > l.bottom) continue;
                                if (l.y > a.body.bottom) break
                            }
                            this.collideSpriteVsSprite(a, c, e, i, s, n)
                        }
                    }
                }
            }
        }, collideGroupVsGroup: function (t, e, i, s, n, r) {
            if (0 !== t.length && 0 !== e.length) for (var o = 0; o < t.children.length; o++) t.children[o].exists && (t.children[o].physicsType === j.GROUP ? this.collideGroupVsGroup(t.children[o], e, i, s, n, r) : this.collideSpriteVsGroup(t.children[o], e, i, s, n, r))
        }, separate: function (t, e, i, s, n) {
            if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
            if (i && !1 === i.call(s, t.sprite, e.sprite)) return !1;
            if (t.isCircle && e.isCircle) return this.separateCircle(t, e, n);
            if (t.isCircle !== e.isCircle) {
                var r = t.isCircle ? e : t, o = t.isCircle ? t : e, a = r.x, h = r.y, l = r.right, c = r.bottom,
                    u = o.x + o.radius, d = o.y + o.radius;
                if ((d < h || c < d) && (u < a || l < u)) return this.separateCircle(t, e, n)
            }
            var p = !1, f = !1;
            this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (p = this.separateX(t, e, n), this.intersects(t, e) && (f = this.separateY(t, e, n))) : (f = this.separateY(t, e, n), this.intersects(t, e) && (p = this.separateX(t, e, n)));
            var g = p || f;
            return g && (n ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), g
        }, intersects: function (t, e) {
            return t !== e && (t.isCircle ? e.isCircle ? j.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom))))
        }, circleBodyIntersects: function (t, e) {
            var i = j.Math.clamp(t.center.x, e.left, e.right), s = j.Math.clamp(t.center.y, e.top, e.bottom);
            return (t.center.x - i) * (t.center.x - i) + (t.center.y - s) * (t.center.y - s) <= t.radius * t.radius
        }, separateCircle: function (t, e, i) {
            this.getOverlapX(t, e), this.getOverlapY(t, e);
            var s = e.center.x - t.center.x, n = e.center.y - t.center.y, r = Math.atan2(n, s), o = 0;
            if (t.isCircle !== e.isCircle) {
                var a = {
                    x: e.isCircle ? t.position.x : e.position.x,
                    y: e.isCircle ? t.position.y : e.position.y,
                    right: e.isCircle ? t.right : e.right,
                    bottom: e.isCircle ? t.bottom : e.bottom
                }, h = {
                    x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                    y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                    radius: t.isCircle ? t.radius : e.radius
                };
                h.y < a.y ? h.x < a.x ? o = j.Math.distance(h.x, h.y, a.x, a.y) - h.radius : a.right < h.x && (o = j.Math.distance(h.x, h.y, a.right, a.y) - h.radius) : a.bottom < h.y && (h.x < a.x ? o = j.Math.distance(h.x, h.y, a.x, a.bottom) - h.radius : a.right < h.x && (o = j.Math.distance(h.x, h.y, a.right, a.bottom) - h.radius)), o *= -1
            } else o = t.radius + e.radius - j.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y);
            if (i || 0 === o || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== o && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== o;
            var l = t.velocity.x * Math.cos(r) + t.velocity.y * Math.sin(r),
                c = t.velocity.x * Math.sin(r) - t.velocity.y * Math.cos(r),
                u = e.velocity.x * Math.cos(r) + e.velocity.y * Math.sin(r),
                d = e.velocity.x * Math.sin(r) - e.velocity.y * Math.cos(r),
                p = ((t.mass - e.mass) * l + 2 * e.mass * u) / (t.mass + e.mass),
                f = (2 * t.mass * l + (e.mass - t.mass) * u) / (t.mass + e.mass);
            return t.immovable || (t.velocity.x = (p * Math.cos(r) - c * Math.sin(r)) * t.bounce.x, t.velocity.y = (c * Math.cos(r) + p * Math.sin(r)) * t.bounce.y), e.immovable || (e.velocity.x = (f * Math.cos(r) - d * Math.sin(r)) * e.bounce.x, e.velocity.y = (d * Math.cos(r) + f * Math.sin(r)) * e.bounce.y), Math.abs(r) < Math.PI / 2 ? 0 < t.velocity.x && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : 0 < t.velocity.y && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(r) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : 0 < e.velocity.x && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : 0 < e.velocity.y && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - o * Math.cos(r), t.y += t.velocity.y * this.game.time.physicsElapsed - o * Math.sin(r)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + o * Math.cos(r), e.y += e.velocity.y * this.game.time.physicsElapsed + o * Math.sin(r)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0
        }, getOverlapX: function (t, e, i) {
            var s = 0, n = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
            return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? n < (s = t.right - e.x) && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && (n < -(s = t.x - e.width - e.x) && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = s, e.overlapX = s
        }, getOverlapY: function (t, e, i) {
            var s = 0, n = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
            return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? n < (s = t.bottom - e.y) && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && (n < -(s = t.y - e.bottom) && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = s, e.overlapY = s
        }, separateX: function (t, e, i) {
            var s = this.getOverlapX(t, e, i);
            if (i || 0 === s || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== s || t.embedded && e.embedded;
            var n = t.velocity.x, r = e.velocity.x;
            if (t.immovable || e.immovable) t.immovable ? (e.x += s, e.velocity.x = n - r * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= s, t.velocity.x = r - n * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y)); else {
                s *= .5, t.x -= s, e.x += s;
                var o = Math.sqrt(r * r * e.mass / t.mass) * (0 < r ? 1 : -1),
                    a = Math.sqrt(n * n * t.mass / e.mass) * (0 < n ? 1 : -1), h = .5 * (o + a);
                o -= h, a -= h, t.velocity.x = h + o * t.bounce.x, e.velocity.x = h + a * e.bounce.x
            }
            return !0
        }, separateY: function (t, e, i) {
            var s = this.getOverlapY(t, e, i);
            if (i || 0 === s || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== s || t.embedded && e.embedded;
            var n = t.velocity.y, r = e.velocity.y;
            if (t.immovable || e.immovable) t.immovable ? (e.y += s, e.velocity.y = n - r * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= s, t.velocity.y = r - n * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x)); else {
                s *= .5, t.y -= s, e.y += s;
                var o = Math.sqrt(r * r * e.mass / t.mass) * (0 < r ? 1 : -1),
                    a = Math.sqrt(n * n * t.mass / e.mass) * (0 < n ? 1 : -1), h = .5 * (o + a);
                o -= h, a -= h, t.velocity.y = h + o * t.bounce.y, e.velocity.y = h + a * e.bounce.y
            }
            return !0
        }, getObjectsUnderPointer: function (t, e, i, s) {
            if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, s, t)
        }, getObjectsAtLocation: function (t, e, i, s, n, r) {
            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(i);
            for (var o = new j.Rectangle(t, e, 1, 1), a = [], h = this.quadTree.retrieve(o), l = 0; l < h.length; l++) h[l].hitTest(t, e) && (s && s.call(n, r, h[l].sprite), a.push(h[l].sprite));
            return a
        }, moveToObject: function (t, e, i, s) {
            void 0 === i && (i = 60), void 0 === s && (s = 0);
            var n = Math.atan2(e.y - t.y, e.x - t.x);
            return 0 < s && (i = this.distanceBetween(t, e) / (s / 1e3)), t.body.velocity.x = Math.cos(n) * i, t.body.velocity.y = Math.sin(n) * i, n
        }, moveToPointer: function (t, e, i, s) {
            void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === s && (s = 0);
            var n = this.angleToPointer(t, i);
            return 0 < s && (e = this.distanceToPointer(t, i) / (s / 1e3)), t.body.velocity.x = Math.cos(n) * e, t.body.velocity.y = Math.sin(n) * e, n
        }, moveToXY: function (t, e, i, s, n) {
            void 0 === s && (s = 60), void 0 === n && (n = 0);
            var r = Math.atan2(i - t.y, e - t.x);
            return 0 < n && (s = this.distanceToXY(t, e, i) / (n / 1e3)), t.body.velocity.x = Math.cos(r) * s, t.body.velocity.y = Math.sin(r) * s, r
        }, velocityFromAngle: function (t, e, i) {
            return void 0 === e && (e = 60), (i = i || new j.Point).setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
        }, velocityFromRotation: function (t, e, i) {
            return void 0 === e && (e = 60), (i = i || new j.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
        }, accelerationFromRotation: function (t, e, i) {
            return void 0 === e && (e = 60), (i = i || new j.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
        }, accelerateToObject: function (t, e, i, s, n) {
            void 0 === i && (i = 60), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
            var r = this.angleBetween(t, e);
            return t.body.acceleration.setTo(Math.cos(r) * i, Math.sin(r) * i), t.body.maxVelocity.setTo(s, n), r
        }, accelerateToPointer: function (t, e, i, s, n) {
            void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
            var r = this.angleToPointer(t, e);
            return t.body.acceleration.setTo(Math.cos(r) * i, Math.sin(r) * i), t.body.maxVelocity.setTo(s, n), r
        }, accelerateToXY: function (t, e, i, s, n, r) {
            void 0 === s && (s = 60), void 0 === n && (n = 1e3), void 0 === r && (r = 1e3);
            var o = this.angleToXY(t, e, i);
            return t.body.acceleration.setTo(Math.cos(o) * s, Math.sin(o) * s), t.body.maxVelocity.setTo(n, r), o
        }, distanceBetween: function (t, e, i) {
            void 0 === i && (i = !1);
            var s = i ? t.world.x - e.world.x : t.x - e.x, n = i ? t.world.y - e.world.y : t.y - e.y;
            return Math.sqrt(s * s + n * n)
        }, distanceToXY: function (t, e, i, s) {
            void 0 === s && (s = !1);
            var n = s ? t.world.x - e : t.x - e, r = s ? t.world.y - i : t.y - i;
            return Math.sqrt(n * n + r * r)
        }, distanceToPointer: function (t, e, i) {
            void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
            var s = i ? t.world.x - e.worldX : t.x - e.worldX, n = i ? t.world.y - e.worldY : t.y - e.worldY;
            return Math.sqrt(s * s + n * n)
        }, angleBetween: function (t, e, i) {
            return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
        }, angleBetweenCenters: function (t, e) {
            var i = e.centerX - t.centerX, s = e.centerY - t.centerY;
            return Math.atan2(s, i)
        }, angleToXY: function (t, e, i, s) {
            return void 0 === s && (s = !1), s ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
        }, angleToPointer: function (t, e, i) {
            return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
        }, worldAngleToPointer: function (t, e) {
            return this.angleToPointer(t, e, !0)
        }
    },j.Physics.Arcade.Body = function (t) {
        this.sprite = t, this.game = t.game, this.type = j.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new j.Point, this.position = new j.Point(t.x, t.y), this.prev = new j.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new j.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new j.Point, this.newVelocity = new j.Point, this.deltaMax = new j.Point, this.acceleration = new j.Point, this.drag = new j.Point, this.allowGravity = !0, this.gravity = new j.Point, this.bounce = new j.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new j.Point(1e4, 1e4), this.friction = new j.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = j.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
            none: !1,
            any: !0,
            up: !0,
            down: !0,
            left: !0,
            right: !0
        }, this.touching = {none: !0, up: !1, down: !1, left: !1, right: !1}, this.wasTouching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        }, this.blocked = {
            up: !1,
            down: !1,
            left: !1,
            right: !1
        }, this.tilePadding = new j.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new j.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
    },j.Physics.Arcade.Body.prototype = {
        updateBounds: function () {
            if (this.syncBounds) {
                var t = this.sprite.getBounds();
                t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
            } else {
                var e = Math.abs(this.sprite.scale.x), i = Math.abs(this.sprite.scale.y);
                e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
            }
            this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
        }, preUpdate: function () {
            this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
        }, updateMovement: function () {
            var t = 0, e = 0 !== this.overlapX || 0 !== this.overlapY;
            if (t = 0 < this.moveDuration ? (this.moveTimer += this.game.time.elapsedMS, this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
            return !(e || 1 <= t || void 0 !== i && !0 !== i) || (this.stopMovement(1 <= t || this.stopVelocityOnCollide && e), !1)
        }, stopMovement: function (t) {
            this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
        }, postUpdate: function () {
            this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = j.LEFT : 0 < this.deltaX() && (this.facing = j.RIGHT), this.deltaY() < 0 ? this.facing = j.UP : 0 < this.deltaY() && (this.facing = j.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : 0 < this._dx && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : 0 < this._dy && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
        }, checkWorldBounds: function () {
            var t = this.position, e = this.game.physics.arcade.bounds, i = this.game.physics.arcade.checkCollision,
                s = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                n = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
            if (this.isCircle) {
                var r = this.center.x - this.radius, o = this.center.y - this.radius, a = this.center.x + this.radius,
                    h = this.center.y + this.radius;
                r < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius, this.velocity.x *= s, this.blocked.left = !0) : a > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius, this.velocity.x *= s, this.blocked.right = !0), o < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius, this.velocity.y *= n, this.blocked.up = !0) : h > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius, this.velocity.y *= n, this.blocked.down = !0)
            } else t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= s, this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= s, this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= n, this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= n, this.blocked.down = !0);
            return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
        }, moveFrom: function (t, e, i) {
            return void 0 === e && (e = this.speed), 0 !== e && (void 0 === i ? (s = this.angle, i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(s) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * e) : this.velocity.set(Math.cos(s) * e, Math.sin(s) * e), this.isMoving = !0);
            var s
        }, moveTo: function (t, e, i) {
            var s, n = e / (t / 1e3);
            return 0 !== n && (void 0 === i ? (s = this.angle, i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new j.Line, this.moveEnd = new j.Point), this.moveTarget.fromAngle(this.x, this.y, s, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === i || 180 === i ? this.velocity.set(Math.cos(s) * n, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * n) : this.velocity.set(Math.cos(s) * n, Math.sin(s) * n), this.isMoving = !0)
        }, setSize: function (t, e, i, s) {
            void 0 === i && (i = this.offset.x), void 0 === s && (s = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, s), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
        }, setCircle: function (t, e, i) {
            void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), 0 < t ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
        }, reset: function (t, e) {
            this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
        }, getBounds: function (t) {
            return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t
        }, hitTest: function (t, e) {
            return this.isCircle ? j.Circle.contains(this, t, e) : j.Rectangle.contains(this, t, e)
        }, onFloor: function () {
            return this.blocked.down
        }, onCeiling: function () {
            return this.blocked.up
        }, onWall: function () {
            return this.blocked.left || this.blocked.right
        }, deltaAbsX: function () {
            return 0 < this.deltaX() ? this.deltaX() : -this.deltaX()
        }, deltaAbsY: function () {
            return 0 < this.deltaY() ? this.deltaY() : -this.deltaY()
        }, deltaX: function () {
            return this.position.x - this.prev.x
        }, deltaY: function () {
            return this.position.y - this.prev.y
        }, deltaZ: function () {
            return this.rotation - this.preRotation
        }, destroy: function () {
            this.sprite.parent && this.sprite.parent instanceof j.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
        }
    },Object.defineProperty(j.Physics.Arcade.Body.prototype, "left", {
        get: function () {
            return this.position.x
        }
    }),Object.defineProperty(j.Physics.Arcade.Body.prototype, "right", {
        get: function () {
            return this.position.x + this.width
        }
    }),Object.defineProperty(j.Physics.Arcade.Body.prototype, "top", {
        get: function () {
            return this.position.y
        }
    }),Object.defineProperty(j.Physics.Arcade.Body.prototype, "bottom", {
        get: function () {
            return this.position.y + this.height
        }
    }),Object.defineProperty(j.Physics.Arcade.Body.prototype, "x", {
        get: function () {
            return this.position.x
        }, set: function (t) {
            this.position.x = t
        }
    }),Object.defineProperty(j.Physics.Arcade.Body.prototype, "y", {
        get: function () {
            return this.position.y
        }, set: function (t) {
            this.position.y = t
        }
    }),j.Physics.Arcade.Body.render = function (t, e, i, s) {
        void 0 === s && (s = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), s ? t.fill() : t.stroke()) : s ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
    },j.Physics.Arcade.Body.renderBodyInfo = function (t, e) {
        t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
    },j.Physics.Arcade.Body.prototype.constructor = j.Physics.Arcade.Body,j.Physics.Arcade.TilemapCollision = function () {
    },j.Physics.Arcade.TilemapCollision.prototype = {
        TILE_BIAS: 16, collideSpriteVsTilemapLayer: function (t, e, i, s, n, r) {
            if (t.body) {
                var o = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                if (0 !== o.length) for (var a = 0; a < o.length; a++) s ? s.call(n, t, o[a]) && this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(n, t, o[a])) : this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(n, t, o[a]))
            }
        }, collideGroupVsTilemapLayer: function (t, e, i, s, n, r) {
            if (0 !== t.length) for (var o = 0; o < t.children.length; o++) t.children[o].exists && this.collideSpriteVsTilemapLayer(t.children[o], e, i, s, n, r)
        }, separateTile: function (t, e, i, s, n) {
            if (!e.enable) return !1;
            var r = s.fixedToCamera ? 0 : s.position.x, o = s.fixedToCamera ? 0 : s.position.y;
            if (!i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !1;
            if (n) return !0;
            if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
            if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
            if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
            var a = 0, h = 0, l = 0, c = 1;
            if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - r - i.right), Math.abs(e.right - r - i.left)), c = Math.min(Math.abs(e.position.y - o - i.bottom), Math.abs(e.bottom - o - i.top))), l < c) {
                if ((i.faceLeft || i.faceRight) && 0 !== (a = this.tileCheckX(e, i, s)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !0;
                (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, s))
            } else {
                if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, s)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !0;
                (i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, s))
            }
            return 0 !== a || 0 !== h
        }, tileCheckX: function (t, e, i) {
            var s = 0, n = i.fixedToCamera ? 0 : i.position.x;
            return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - n < e.right && (s = t.x - n - e.right) < -this.TILE_BIAS && (s = 0) : 0 < t.deltaX() && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - n > e.left && (s = t.right - n - e.left) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateX ? t.overlapX = s : this.processTileSeparationX(t, s)), s
        }, tileCheckY: function (t, e, i) {
            var s = 0, n = i.fixedToCamera ? 0 : i.position.y;
            return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - n < e.bottom && (s = t.y - n - e.bottom) < -this.TILE_BIAS && (s = 0) : 0 < t.deltaY() && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - n > e.top && (s = t.bottom - n - e.top) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateY ? t.overlapY = s : this.processTileSeparationY(t, s)), s
        }, processTileSeparationX: function (t, e) {
            e < 0 ? t.blocked.left = !0 : 0 < e && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
        }, processTileSeparationY: function (t, e) {
            e < 0 ? t.blocked.up = !0 : 0 < e && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
        }
    },j.Utils.mixinPrototype(j.Physics.Arcade.prototype, j.Physics.Arcade.TilemapCollision.prototype),j.ImageCollection = function (t, e, i, s, n, r, o) {
        (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | s, this.imageMargin = 0 | n, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0
    },j.ImageCollection.prototype = {
        containsImageIndex: function (t) {
            return t >= this.firstgid && t < this.firstgid + this.total
        }, addImage: function (t, e) {
            this.images.push({gid: t, image: e}), this.total++
        }
    },j.ImageCollection.prototype.constructor = j.ImageCollection,j.Tile = function (t, e, i, s, n, r) {
        this.layer = t, this.index = e, this.x = i, this.y = s, this.rotation = 0, this.flipped = !1, this.worldX = i * n, this.worldY = s * r, this.width = n, this.height = r, this.centerX = Math.abs(n / 2), this.centerY = Math.abs(r / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
    },j.Tile.prototype = {
        containsPoint: function (t, e) {
            return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
        }, intersects: function (t, e, i, s) {
            return !(i <= this.worldX) && (!(s <= this.worldY) && (!(t >= this.worldX + this.width) && !(e >= this.worldY + this.height)))
        }, setCollisionCallback: function (t, e) {
            this.collisionCallback = t, this.collisionCallbackContext = e
        }, destroy: function () {
            this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
        }, setCollision: function (t, e, i, s) {
            this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = s, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = s
        }, resetCollision: function () {
            this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
        }, isInteresting: function (t, e) {
            return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
        }, copy: function (t) {
            this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
        }
    },j.Tile.prototype.constructor = j.Tile,Object.defineProperty(j.Tile.prototype, "collides", {
        get: function () {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
        }
    }),Object.defineProperty(j.Tile.prototype, "canCollide", {
        get: function () {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
        }
    }),Object.defineProperty(j.Tile.prototype, "left", {
        get: function () {
            return this.worldX
        }
    }),Object.defineProperty(j.Tile.prototype, "right", {
        get: function () {
            return this.worldX + this.width
        }
    }),Object.defineProperty(j.Tile.prototype, "top", {
        get: function () {
            return this.worldY
        }
    }),Object.defineProperty(j.Tile.prototype, "bottom", {
        get: function () {
            return this.worldY + this.height
        }
    }),j.Tilemap = function (t, e, i, s, n, r) {
        this.game = t, this.key = e;
        var o = j.TilemapParser.parse(this.game, e, i, s, n, r);
        null !== o && (this.width = o.width, this.height = o.height, this.tileWidth = o.tileWidth, this.tileHeight = o.tileHeight, this.orientation = o.orientation, this.format = o.format, this.version = o.version, this.properties = o.properties, this.widthInPixels = o.widthInPixels, this.heightInPixels = o.heightInPixels, this.layers = o.layers, this.tilesets = o.tilesets, this.imagecollections = o.imagecollections, this.tiles = o.tiles, this.objects = o.objects, this.collideIndexes = [], this.collision = o.collision, this.images = o.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
    },j.Tilemap.CSV = 0,j.Tilemap.TILED_JSON = 1,j.Tilemap.NORTH = 0,j.Tilemap.EAST = 1,j.Tilemap.SOUTH = 2,j.Tilemap.WEST = 3,j.Tilemap.prototype = {
        create: function (t, e, i, s, n, r) {
            return void 0 === r && (r = this.game.world), this.width = e, this.height = i, this.setTileSize(s, n), this.layers.length = 0, this.createBlankLayer(t, e, i, s, n, r)
        }, setTileSize: function (t, e) {
            this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
        }, addTilesetImage: function (t, e, i, s, n, r, o) {
            if (void 0 === t) return null;
            void 0 === i && (i = this.tileWidth), void 0 === s && (s = this.tileHeight), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), 0 === i && (i = 32), 0 === s && (s = 32);
            var a = null;
            if (null == e && (e = t), e instanceof j.BitmapData) a = e.canvas; else {
                if (!this.game.cache.checkImageKey(e)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + e + '"'), null;
                a = this.game.cache.getImage(e)
            }
            var h = this.getTilesetIndex(t);
            if (null === h && this.format === j.Tilemap.TILED_JSON) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + t + '"'), null;
            if (this.tilesets[h]) return this.tilesets[h].setImage(a), this.tilesets[h];
            var l = new j.Tileset(t, o, i, s, n, r, {});
            l.setImage(a), this.tilesets.push(l);
            for (var c = this.tilesets.length - 1, u = n, d = n, p = 0, f = 0, g = 0, m = o; m < o + l.total && (this.tiles[m] = [u, d, c], u += i + r, ++p !== l.total) && (++f !== l.columns || (u = n, d += s + r, f = 0, ++g !== l.rows)); m++) ;
            return l
        }, createFromObjects: function (t, e, i, s, n, r, o, a, h) {
            if (void 0 === n && (n = !0), void 0 === r && (r = !1), void 0 === o && (o = this.game.world), void 0 === a && (a = j.Sprite), void 0 === h && (h = !0), this.objects[t]) for (var l = 0; l < this.objects[t].length; l++) {
                var c = !1, u = this.objects[t][l];
                if (void 0 !== u.gid && "number" == typeof e && u.gid === e ? c = !0 : void 0 !== u.id && "number" == typeof e && u.id === e ? c = !0 : void 0 !== u.name && "string" == typeof e && u.name === e && (c = !0), c) {
                    var d = new a(this.game, parseFloat(u.x, 10), parseFloat(u.y, 10), i, s);
                    for (var p in d.name = u.name, d.visible = u.visible, d.autoCull = r, d.exists = n, u.width && (d.width = u.width), u.height && (d.height = u.height), u.rotation && (d.angle = u.rotation), h && (d.y -= d.height), o.add(d), u.properties) o.set(d, p, u.properties[p], !1, !1, 0, !0)
                }
            } else console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + t)
        }, createFromTiles: function (t, e, i, s, n, r) {
            "number" == typeof t && (t = [t]), null == e ? e = [] : "number" == typeof e && (e = [e]), s = this.getLayer(s), void 0 === n && (n = this.game.world), void 0 === r && (r = {}), void 0 === r.customClass && (r.customClass = j.Sprite), void 0 === r.adjustY && (r.adjustY = !0);
            var o = this.layers[s].width, a = this.layers[s].height;
            if (this.copy(0, 0, o, a, s), this._results.length < 2) return 0;
            for (var h, l = 0, c = 1, u = this._results.length; c < u; c++) if (-1 !== t.indexOf(this._results[c].index)) {
                for (var d in h = new r.customClass(this.game, this._results[c].worldX, this._results[c].worldY, i), r) h[d] = r[d];
                n.add(h), l++
            }
            if (1 === e.length) for (c = 0; c < t.length; c++) this.replace(t[c], e[0], 0, 0, o, a, s); else if (1 < e.length) for (c = 0; c < t.length; c++) this.replace(t[c], e[c], 0, 0, o, a, s);
            return l
        }, createLayer: function (t, e, i, s) {
            void 0 === e && (e = this.game.width), void 0 === i && (i = this.game.height), void 0 === s && (s = this.game.world);
            var n = t;
            if ("string" == typeof t && (n = this.getLayerIndex(t)), !(null === n || n > this.layers.length)) {
                void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[n].widthInPixels) : e > this.game.width && (e = this.game.width), void 0 === i || i <= 0 ? i = Math.min(this.game.height, this.layers[n].heightInPixels) : i > this.game.height && (i = this.game.height), this.enableDebug && (console.group("Tilemap.createLayer"), console.log("Name:", this.layers[n].name), console.log("Size:", e, "x", i), console.log("Tileset:", this.tilesets[0].name, "index:", n));
                var r = s.add(new j.TilemapLayer(this.game, this, n, e, i));
                return this.enableDebug && console.groupEnd(), r
            }
            console.warn("Tilemap.createLayer: Invalid layer ID given: " + n)
        }, createBlankLayer: function (t, e, i, s, n, r) {
            if (void 0 === r && (r = this.game.world), null === this.getLayerIndex(t)) {
                for (var o, a = {
                    name: t,
                    x: 0,
                    y: 0,
                    width: e,
                    height: i,
                    widthInPixels: e * s,
                    heightInPixels: i * n,
                    alpha: 1,
                    visible: !0,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: [],
                    data: null
                }, h = [], l = 0; l < i; l++) {
                    o = [];
                    for (var c = 0; c < e; c++) o.push(new j.Tile(a, -1, c, l, s, n));
                    h.push(o)
                }
                a.data = h, this.layers.push(a), this.currentLayer = this.layers.length - 1;
                var u = a.widthInPixels, d = a.heightInPixels;
                return u > this.game.width && (u = this.game.width), d > this.game.height && (d = this.game.height), (h = new j.TilemapLayer(this.game, this, this.layers.length - 1, u, d)).name = t, r.add(h)
            }
            console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + t)
        }, getIndex: function (t, e) {
            for (var i = 0; i < t.length; i++) if (t[i].name === e) return i;
            return null
        }, getLayerIndex: function (t) {
            return this.getIndex(this.layers, t)
        }, getTilesetIndex: function (t) {
            return this.getIndex(this.tilesets, t)
        }, getImageIndex: function (t) {
            return this.getIndex(this.images, t)
        }, setTileIndexCallback: function (t, e, i, s) {
            if (s = this.getLayer(s), "number" == typeof t) this.layers[s].callbacks[t] = {
                callback: e,
                callbackContext: i
            }; else for (var n = 0, r = t.length; n < r; n++) this.layers[s].callbacks[t[n]] = {
                callback: e,
                callbackContext: i
            }
        }, setTileLocationCallback: function (t, e, i, s, n, r, o) {
            if (o = this.getLayer(o), this.copy(t, e, i, s, o), !(this._results.length < 2)) for (var a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(n, r)
        }, setCollision: function (t, e, i, s) {
            if (void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
            if (Array.isArray(t)) {
                for (var n = 0; n < t.length; n++) this.setCollisionByIndex(t[n], e, i, !1);
                s && this.calculateFaces(i)
            }
        }, setCollisionBetween: function (t, e, i, s, n) {
            if (void 0 === i && (i = !0), void 0 === n && (n = !0), s = this.getLayer(s), !(e < t)) {
                for (var r = t; r <= e; r++) this.setCollisionByIndex(r, i, s, !1);
                n && this.calculateFaces(s)
            }
        }, setCollisionByExclusion: function (t, e, i, s) {
            void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i);
            for (var n = 0, r = this.tiles.length; n < r; n++) -1 === t.indexOf(n) && this.setCollisionByIndex(n, e, i, !1);
            s && this.calculateFaces(i)
        }, setCollisionByIndex: function (t, e, i, s) {
            if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === s && (s = !0), e) this.collideIndexes.push(t); else {
                var n = this.collideIndexes.indexOf(t);
                -1 < n && this.collideIndexes.splice(n, 1)
            }
            for (var r = 0; r < this.layers[i].height; r++) for (var o = 0; o < this.layers[i].width; o++) {
                var a = this.layers[i].data[r][o];
                a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(), a.faceTop = e, a.faceBottom = e, a.faceLeft = e, a.faceRight = e)
            }
            return s && this.calculateFaces(i), i
        }, getLayer: function (t) {
            return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof j.TilemapLayer && (t = t.index), t
        }, setPreventRecalculate: function (t) {
            if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                for (var e in this.preventingRecalculate = !1, this.needToRecalculate) this.calculateFaces(e);
                this.needToRecalculate = !1
            }
        }, calculateFaces: function (t) {
            if (this.preventingRecalculate) this.needToRecalculate[t] = !0; else for (var e = null, i = null, s = null, n = null, r = 0, o = this.layers[t].height; r < o; r++) for (var a = 0, h = this.layers[t].width; a < h; a++) {
                var l = this.layers[t].data[r][a];
                l && (e = this.getTileAbove(t, a, r), i = this.getTileBelow(t, a, r), s = this.getTileLeft(t, a, r), n = this.getTileRight(t, a, r), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), s && s.collides && (l.faceLeft = !1), n && n.collides && (l.faceRight = !1))
            }
        }, getTileAbove: function (t, e, i) {
            return 0 < i ? this.layers[t].data[i - 1][e] : null
        }, getTileBelow: function (t, e, i) {
            return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
        }, getTileLeft: function (t, e, i) {
            return 0 < e ? this.layers[t].data[i][e - 1] : null
        }, getTileRight: function (t, e, i) {
            return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
        }, setLayer: function (t) {
            t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
        }, hasTile: function (t, e, i) {
            return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && -1 < this.layers[i].data[e][t].index
        }, removeTile: function (t, e, i) {
            if (i = this.getLayer(i), 0 <= t && t < this.layers[i].width && 0 <= e && e < this.layers[i].height && this.hasTile(t, e, i)) {
                var s = this.layers[i].data[e][t];
                return this.layers[i].data[e][t] = new j.Tile(this.layers[i], -1, t, e, this.tileWidth, this.tileHeight), this.layers[i].dirty = !0, this.calculateFaces(i), s
            }
        }, removeTileWorldXY: function (t, e, i, s, n) {
            return n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.removeTile(t, e, n)
        }, putTile: function (t, e, i, s) {
            return null === t ? this.removeTile(e, i, s) : (s = this.getLayer(s), 0 <= e && e < this.layers[s].width && 0 <= i && i < this.layers[s].height ? (t instanceof j.Tile ? (n = t.index, this.hasTile(e, i, s) ? this.layers[s].data[i][e].copy(t) : this.layers[s].data[i][e] = new j.Tile(s, n, e, i, t.width, t.height)) : (n = t, this.hasTile(e, i, s) ? this.layers[s].data[i][e].index = n : this.layers[s].data[i][e] = new j.Tile(this.layers[s], n, e, i, this.tileWidth, this.tileHeight)), -1 < this.collideIndexes.indexOf(n) ? this.layers[s].data[i][e].setCollision(!0, !0, !0, !0) : this.layers[s].data[i][e].resetCollision(), this.layers[s].dirty = !0, this.calculateFaces(s), this.layers[s].data[i][e]) : null);
            var n
        }, putTileWorldXY: function (t, e, i, s, n, r) {
            return r = this.getLayer(r), e = this.game.math.snapToFloor(e, s) / s, i = this.game.math.snapToFloor(i, n) / n, this.putTile(t, e, i, r)
        }, searchTileIndex: function (t, e, i, s) {
            void 0 === e && (e = 0), void 0 === i && (i = !1), s = this.getLayer(s);
            var n = 0;
            if (i) {
                for (var r = this.layers[s].height - 1; 0 <= r; r--) for (var o = this.layers[s].width - 1; 0 <= o; o--) if (this.layers[s].data[r][o].index === t) {
                    if (n === e) return this.layers[s].data[r][o];
                    n++
                }
            } else for (r = 0; r < this.layers[s].height; r++) for (o = 0; o < this.layers[s].width; o++) if (this.layers[s].data[r][o].index === t) {
                if (n === e) return this.layers[s].data[r][o];
                n++
            }
            return null
        }, getTile: function (t, e, i, s) {
            return void 0 === s && (s = !1), i = this.getLayer(i), 0 <= t && t < this.layers[i].width && 0 <= e && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? s ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
        }, getTileWorldXY: function (t, e, i, s, n, r) {
            return void 0 === i && (i = this.tileWidth), void 0 === s && (s = this.tileHeight), n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.getTile(t, e, n, r)
        }, copy: function (t, e, i, s, n) {
            if (n = this.getLayer(n), this.layers[n]) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[n].width), void 0 === s && (s = this.layers[n].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[n].width && (i = this.layers[n].width), s > this.layers[n].height && (s = this.layers[n].height), this._results.length = 0, this._results.push({
                    x: t,
                    y: e,
                    width: i,
                    height: s,
                    layer: n
                });
                for (var r = e; r < e + s; r++) for (var o = t; o < t + i; o++) this._results.push(this.layers[n].data[r][o]);
                return this._results
            }
            this._results.length = 0
        }, paste: function (t, e, i, s) {
            if (void 0 === t && (t = 0), void 0 === e && (e = 0), s = this.getLayer(s), i && !(i.length < 2)) {
                for (var n = t - i[1].x, r = e - i[1].y, o = 1; o < i.length; o++) this.layers[s].data[r + i[o].y][n + i[o].x].copy(i[o]);
                this.layers[s].dirty = !0, this.calculateFaces(s)
            }
        }, swap: function (t, e, i, s, n, r, o) {
            o = this.getLayer(o), this.copy(i, s, n, r, o), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, s, this._results, o))
        }, swapHandler: function (t) {
            t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
        }, forEach: function (t, e, i, s, n, r, o) {
            o = this.getLayer(o), this.copy(i, s, n, r, o), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, s, this._results, o))
        }, replace: function (t, e, i, s, n, r, o) {
            if (o = this.getLayer(o), this.copy(i, s, n, r, o), !(this._results.length < 2)) {
                for (var a = 1; a < this._results.length; a++) this._results[a].index === t && (this._results[a].index = e);
                this.paste(i, s, this._results, o)
            }
        }, random: function (t, e, i, s, n) {
            if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                for (var r = [], o = 1; o < this._results.length; o++) if (this._results[o].index) {
                    var a = this._results[o].index;
                    -1 === r.indexOf(a) && r.push(a)
                }
                for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(r);
                this.paste(t, e, this._results, n)
            }
        }, shuffle: function (t, e, i, s, n) {
            if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                for (var r = [], o = 1; o < this._results.length; o++) this._results[o].index && r.push(this._results[o].index);
                j.ArrayUtils.shuffle(r);
                for (var a = 1; a < this._results.length; a++) this._results[a].index = r[a - 1];
                this.paste(t, e, this._results, n)
            }
        }, fill: function (t, e, i, s, n, r) {
            if (r = this.getLayer(r), this.copy(e, i, s, n, r), !(this._results.length < 2)) {
                for (var o = 1; o < this._results.length; o++) this._results[o].index = t;
                this.paste(e, i, this._results, r)
            }
        }, removeAllLayers: function () {
            this.layers.length = 0, this.currentLayer = 0
        }, dump: function () {
            for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                for (var s = 0; s < this.layers[this.currentLayer].width; s++) t += "%c  ", 1 < this.layers[this.currentLayer].data[i][s] ? this.debugMap[this.layers[this.currentLayer].data[i][s]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][s]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                t += "\n"
            }
            e[0] = t, console.log.apply(console, e)
        }, destroy: function () {
            this.removeAllLayers(), this.data = [], this.game = null
        }
    },j.Tilemap.prototype.constructor = j.Tilemap,Object.defineProperty(j.Tilemap.prototype, "layer", {
        get: function () {
            return this.layers[this.currentLayer]
        }, set: function (t) {
            t !== this.currentLayer && this.setLayer(t)
        }
    }),j.TilemapLayer = function (t, e, i, s, n) {
        s |= 0, n |= 0, j.Sprite.call(this, t, 0, 0), this.map = e, this.index = i, this.layer = e.layers[i], this.canvas = PIXI.CanvasPool.create(this, s, n), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = j.TILEMAPLAYER, this.physicsType = j.TILEMAPLAYER, this.renderSettings = {
            enableScrollDelta: !1,
            overdrawRatio: .2,
            copyCanvas: null
        }, this.debug = !1, this.exists = !0, this.debugSettings = {
            missingImageFill: "rgb(255,255,255)",
            debuggedTileOverfill: "rgba(0,255,0,0.4)",
            forceFullRedraw: !0,
            debugAlpha: .5,
            facingEdgeStroke: "rgba(0,255,0,1)",
            collidingTileOverfill: "rgba(0,255,0,0.2)"
        }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
            scrollX: 0,
            scrollY: 0,
            renderWidth: 0,
            renderHeight: 0,
            tileWidth: e.tileWidth,
            tileHeight: e.tileHeight,
            cw: e.tileWidth,
            ch: e.tileHeight,
            tilesets: []
        }, this._scrollX = 0, this._scrollY = 0, this._results = [], t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = j.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0
    },j.TilemapLayer.prototype = Object.create(j.Sprite.prototype),j.TilemapLayer.prototype.constructor = j.TilemapLayer,j.TilemapLayer.prototype.preUpdateCore = j.Component.Core.preUpdate,j.TilemapLayer.sharedCopyCanvas = null,j.TilemapLayer.ensureSharedCopyCanvas = function () {
        return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
    },j.TilemapLayer.prototype.preUpdate = function () {
        return this.preUpdateCore()
    },j.TilemapLayer.prototype.postUpdate = function () {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
    },j.TilemapLayer.prototype._renderCanvas = function (t) {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t)
    },j.TilemapLayer.prototype._renderWebGL = function (t) {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t)
    },j.TilemapLayer.prototype.destroy = function () {
        PIXI.CanvasPool.remove(this), j.Component.Destroy.prototype.destroy.call(this)
    },j.TilemapLayer.prototype.resize = function (t, e) {
        this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
    },j.TilemapLayer.prototype.resizeWorld = function () {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
    },j.TilemapLayer.prototype._fixX = function (t) {
        return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
    },j.TilemapLayer.prototype._unfixX = function (t) {
        return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
    },j.TilemapLayer.prototype._fixY = function (t) {
        return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
    },j.TilemapLayer.prototype._unfixY = function (t) {
        return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
    },j.TilemapLayer.prototype.getTileX = function (t) {
        return Math.floor(this._fixX(t) / this._mc.tileWidth)
    },j.TilemapLayer.prototype.getTileY = function (t) {
        return Math.floor(this._fixY(t) / this._mc.tileHeight)
    },j.TilemapLayer.prototype.getTileXY = function (t, e, i) {
        return i.x = this.getTileX(t), i.y = this.getTileY(e), i
    },j.TilemapLayer.prototype.getRayCastTiles = function (t, e, i, s) {
        e || (e = this.rayStepRate), void 0 === i && (i = !1), void 0 === s && (s = !1);
        var n = this.getTiles(t.x, t.y, t.width, t.height, i, s);
        if (0 === n.length) return [];
        for (var r = t.coordinatesOnLine(e), o = [], a = 0; a < n.length; a++) for (var h = 0; h < r.length; h++) {
            var l = n[a], c = r[h];
            if (l.containsPoint(c[0], c[1])) {
                o.push(l);
                break
            }
        }
        return o
    },j.TilemapLayer.prototype.getTiles = function (t, e, i, s, n, r) {
        void 0 === n && (n = !1), void 0 === r && (r = !1);
        var o = !(n || r);
        t = this._fixX(t), e = this._fixY(e);
        for (var a = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - a, c = Math.ceil((e + s) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
        for (var u = h; u < h + c; u++) for (var d = a; d < a + l; d++) {
            var p = this.layer.data[u];
            p && p[d] && (o || p[d].isInteresting(n, r)) && this._results.push(p[d])
        }
        return this._results.slice()
    },j.TilemapLayer.prototype.resolveTileset = function (t) {
        var e = this._mc.tilesets;
        if (t < 2e3) for (; e.length < t;) e.push(void 0);
        var i = this.map.tiles[t] && this.map.tiles[t][2];
        if (null !== i) {
            var s = this.map.tilesets[i];
            if (s && s.containsTileIndex(t)) return e[t] = s
        }
        return e[t] = null
    },j.TilemapLayer.prototype.resetTilesetCache = function () {
        for (var t = this._mc.tilesets; t.length;) t.pop()
    },j.TilemapLayer.prototype.setScale = function (t, e) {
        t = t || 1, e = e || t;
        for (var i = 0; i < this.layer.data.length; i++) for (var s = this.layer.data[i], n = 0; n < s.length; n++) {
            var r = s[n];
            r.width = this.map.tileWidth * t, r.height = this.map.tileHeight * e, r.worldX = r.x * r.width, r.worldY = r.y * r.height
        }
        this.scale.setTo(t, e)
    },j.TilemapLayer.prototype.shiftCanvas = function (t, e, i) {
        var s = t.canvas, n = s.width - Math.abs(e), r = s.height - Math.abs(i), o = 0, a = 0, h = e, l = i;
        e < 0 && (o = -e, h = 0), i < 0 && (a = -i, l = 0);
        var c = this.renderSettings.copyCanvas;
        if (c) {
            (c.width < n || c.height < r) && (c.width = n, c.height = r);
            var u = c.getContext("2d");
            u.clearRect(0, 0, n, r), u.drawImage(s, o, a, n, r, 0, 0, n, r), t.clearRect(h, l, n, r), t.drawImage(c, 0, 0, n, r, h, l, n, r)
        } else t.save(), t.globalCompositeOperation = "copy", t.drawImage(s, o, a, n, r, h, l, n, r), t.restore()
    },j.TilemapLayer.prototype.renderRegion = function (t, e, i, s, n, r) {
        var o = this.context, a = this.layer.width, h = this.layer.height, l = this._mc.tileWidth,
            c = this._mc.tileHeight, u = this._mc.tilesets, d = NaN;
        this._wrap || (i <= n && (i = Math.max(0, i), n = Math.min(a - 1, n)), s <= r && (s = Math.max(0, s), r = Math.min(h - 1, r)));
        var p, f, g, m, y, v, x = i * l - t, b = (i + (1 << 20) * a) % a;
        for (m = (s + (1 << 20) * h) % h, v = r - s, f = s * c - e; 0 <= v; m++, v--, f += c) {
            h <= m && (m -= h);
            var _ = this.layer.data[m];
            for (g = b, y = n - i, p = x; 0 <= y; g++, y--, p += l) {
                a <= g && (g -= a);
                var w = _[g];
                if (w && !(w.index < 0)) {
                    var T = w.index, P = u[T];
                    void 0 === P && (P = this.resolveTileset(T)), w.alpha === d || this.debug || (o.globalAlpha = w.alpha, d = w.alpha), P ? w.rotation || w.flipped ? (o.save(), o.translate(p + w.centerX, f + w.centerY), o.rotate(w.rotation), w.flipped && o.scale(-1, 1), P.draw(o, -w.centerX, -w.centerY, T), o.restore()) : P.draw(o, p, f, T) : this.debugSettings.missingImageFill && (o.fillStyle = this.debugSettings.missingImageFill, o.fillRect(p, f, l, c)), w.debug && this.debugSettings.debuggedTileOverfill && (o.fillStyle = this.debugSettings.debuggedTileOverfill, o.fillRect(p, f, l, c))
                }
            }
        }
    },j.TilemapLayer.prototype.renderDeltaScroll = function (t, e) {
        var i = this._mc.scrollX, s = this._mc.scrollY, n = this.canvas.width, r = this.canvas.height,
            o = this._mc.tileWidth, a = this._mc.tileHeight, h = 0, l = -o, c = 0, u = -a;
        if (t < 0 ? (h = n + t, l = n - 1) : 0 < t && (l = t), e < 0 ? (c = r + e, u = r - 1) : 0 < e && (u = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / o), l = Math.floor((l + i) / o), c = Math.floor((c + s) / a), u = Math.floor((u + s) / a), h <= l) {
            this.context.clearRect(h * o - i, 0, (l - h + 1) * o, r);
            var d = Math.floor((0 + s) / a), p = Math.floor((r - 1 + s) / a);
            this.renderRegion(i, s, h, d, l, p)
        }
        if (c <= u) {
            this.context.clearRect(0, c * a - s, n, (u - c + 1) * a);
            var f = Math.floor((0 + i) / o), g = Math.floor((n - 1 + i) / o);
            this.renderRegion(i, s, f, c, g, u)
        }
    },j.TilemapLayer.prototype.renderFull = function () {
        var t = this._mc.scrollX, e = this._mc.scrollY, i = this.canvas.width, s = this.canvas.height,
            n = this._mc.tileWidth, r = this._mc.tileHeight, o = Math.floor(t / n), a = Math.floor((i - 1 + t) / n),
            h = Math.floor(e / r), l = Math.floor((s - 1 + e) / r);
        this.context.clearRect(0, 0, i, s), this.renderRegion(t, e, o, h, a, l)
    },j.TilemapLayer.prototype.render = function () {
        var t = !1;
        if (this.visible) {
            (this.dirty || this.layer.dirty) && (t = !(this.layer.dirty = !1));
            var e = this.canvas.width, i = this.canvas.height, s = 0 | this._scrollX, n = 0 | this._scrollY,
                r = this._mc, o = r.scrollX - s, a = r.scrollY - n;
            if (t || 0 !== o || 0 !== a || r.renderWidth !== e || r.renderHeight !== i) return this.context.save(), r.scrollX = s, r.scrollY = n, r.renderWidth === e && r.renderHeight === i || (r.renderWidth = e, r.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(o) + Math.abs(a) < Math.min(e, i) ? this.renderDeltaScroll(o, a) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
        }
    },j.TilemapLayer.prototype.renderDebug = function () {
        var t, e, i, s, n, r, o = this._mc.scrollX, a = this._mc.scrollY, h = this.context, l = this.canvas.width,
            c = this.canvas.height, u = this.layer.width, d = this.layer.height, p = this._mc.tileWidth,
            f = this._mc.tileHeight, g = Math.floor(o / p), m = Math.floor((l - 1 + o) / p), y = Math.floor(a / f),
            v = Math.floor((c - 1 + a) / f), x = g * p - o, b = y * f - a, _ = (g + (1 << 20) * u) % u,
            w = (y + (1 << 20) * d) % d;
        for (h.strokeStyle = this.debugSettings.facingEdgeStroke, s = w, r = v - y, e = b; 0 <= r; s++, r--, e += f) {
            d <= s && (s -= d);
            var T = this.layer.data[s];
            for (i = _, n = m - g, t = x; 0 <= n; i++, n--, t += p) {
                u <= i && (i -= u);
                var P = T[i];
                !P || P.index < 0 || !P.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill, h.fillRect(t, e, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (h.beginPath(), P.faceTop && (h.moveTo(t, e), h.lineTo(t + this._mc.cw, e)), P.faceBottom && (h.moveTo(t, e + this._mc.ch), h.lineTo(t + this._mc.cw, e + this._mc.ch)), P.faceLeft && (h.moveTo(t, e), h.lineTo(t, e + this._mc.ch)), P.faceRight && (h.moveTo(t + this._mc.cw, e), h.lineTo(t + this._mc.cw, e + this._mc.ch)), h.closePath(), h.stroke()))
            }
        }
    },Object.defineProperty(j.TilemapLayer.prototype, "wrap", {
        get: function () {
            return this._wrap
        }, set: function (t) {
            this._wrap = t, this.dirty = !0
        }
    }),Object.defineProperty(j.TilemapLayer.prototype, "scrollX", {
        get: function () {
            return this._scrollX
        }, set: function (t) {
            this._scrollX = t
        }
    }),Object.defineProperty(j.TilemapLayer.prototype, "scrollY", {
        get: function () {
            return this._scrollY
        }, set: function (t) {
            this._scrollY = t
        }
    }),Object.defineProperty(j.TilemapLayer.prototype, "collisionWidth", {
        get: function () {
            return this._mc.cw
        }, set: function (t) {
            this._mc.cw = 0 | t, this.dirty = !0
        }
    }),Object.defineProperty(j.TilemapLayer.prototype, "collisionHeight", {
        get: function () {
            return this._mc.ch
        }, set: function (t) {
            this._mc.ch = 0 | t, this.dirty = !0
        }
    }),j.TilemapParser = {
        INSERT_NULL: !1, parse: function (t, e, i, s, n, r) {
            if (void 0 === i && (i = 32), void 0 === s && (s = 32), void 0 === n && (n = 10), void 0 === r && (r = 10), void 0 === e) return this.getEmptyData();
            if (null === e) return this.getEmptyData(i, s, n, r);
            var o = t.cache.getTilemapData(e);
            if (o) {
                if (o.format === j.Tilemap.CSV) return this.parseCSV(e, o.data, i, s);
                if (!o.format || o.format === j.Tilemap.TILED_JSON) return this.parseTiledJSON(o.data)
            } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + e)
        }, parseCSV: function (t, e, i, s) {
            for (var n = this.getEmptyData(), r = [], o = (e = e.trim()).split("\n"), a = o.length, h = 0, l = 0; l < o.length; l++) {
                r[l] = [];
                for (var c = o[l].split(","), u = 0; u < c.length; u++) r[l][u] = new j.Tile(n.layers[0], parseInt(c[u], 10), u, l, i, s);
                0 === h && (h = c.length)
            }
            return n.format = j.Tilemap.CSV, n.name = t, n.width = h, n.height = a, n.tileWidth = i, n.tileHeight = s, n.widthInPixels = h * i, n.heightInPixels = a * s, n.layers[0].width = h, n.layers[0].height = a, n.layers[0].widthInPixels = n.widthInPixels, n.layers[0].heightInPixels = n.heightInPixels, n.layers[0].data = r, n
        }, getEmptyData: function (t, e, i, s) {
            return {
                width: null != i ? i : 0,
                height: null != s ? s : 0,
                tileWidth: null != t ? t : 0,
                tileHeight: null != e ? e : 0,
                orientation: "orthogonal",
                version: "1",
                properties: {},
                widthInPixels: 0,
                heightInPixels: 0,
                layers: [{
                    name: "layer",
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    widthInPixels: 0,
                    heightInPixels: 0,
                    alpha: 1,
                    visible: !0,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: [],
                    data: []
                }],
                images: [],
                objects: {},
                collision: {},
                tilesets: [],
                tiles: []
            }
        }, parseTiledJSON: function (t) {
            if ("orthogonal" !== t.orientation) return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"), null;
            for (var e = {
                width: t.width,
                height: t.height,
                tileWidth: t.tilewidth,
                tileHeight: t.tileheight,
                orientation: t.orientation,
                format: j.Tilemap.TILED_JSON,
                version: t.version,
                properties: t.properties,
                widthInPixels: t.width * t.tilewidth,
                heightInPixels: t.height * t.tileheight
            }, i = [], s = 0; s < t.layers.length; s++) if ("tilelayer" === t.layers[s].type) {
                var n = t.layers[s];
                if (!n.compression && n.encoding && "base64" === n.encoding) {
                    for (var r = window.atob(n.data), o = r.length, a = new Array(o), h = 0; h < o; h += 4) a[h / 4] = (r.charCodeAt(h) | r.charCodeAt(h + 1) << 8 | r.charCodeAt(h + 2) << 16 | r.charCodeAt(h + 3) << 24) >>> 0;
                    n.data = a, delete n.encoding
                } else if (n.compression) {
                    console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + n.name + "'");
                    continue
                }
                var l = {
                    name: n.name,
                    x: n.x,
                    y: n.y,
                    width: n.width,
                    height: n.height,
                    widthInPixels: n.width * t.tilewidth,
                    heightInPixels: n.height * t.tileheight,
                    alpha: n.opacity,
                    visible: n.visible,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: []
                };
                n.properties && (l.properties = n.properties);
                var c, u, d, p = 0, f = [], g = [], m = 0;
                for (o = n.data.length; m < o; m++) {
                    if (u = !1, d = c = 0, 536870912 < (C = n.data[m])) switch (2147483648 < C && (C -= 2147483648, d += 4), 1073741824 < C && (C -= 1073741824, d += 2), 536870912 < C && (C -= 536870912, d += 1), d) {
                        case 5:
                            c = Math.PI / 2;
                            break;
                        case 6:
                            c = Math.PI;
                            break;
                        case 3:
                            c = 3 * Math.PI / 2;
                            break;
                        case 4:
                            u = !(c = 0);
                            break;
                        case 7:
                            c = Math.PI / 2, u = !0;
                            break;
                        case 2:
                            c = Math.PI, u = !0;
                            break;
                        case 1:
                            c = 3 * Math.PI / 2, u = !0
                    }
                    if (0 < C) (I = new j.Tile(l, C, p, g.length, t.tilewidth, t.tileheight)).rotation = c, I.flipped = u, 0 !== d && (I.flippedVal = d), f.push(I); else j.TilemapParser.INSERT_NULL ? f.push(null) : f.push(new j.Tile(l, -1, p, g.length, t.tilewidth, t.tileheight));
                    ++p === n.width && (g.push(f), p = 0, f = [])
                }
                l.data = g, i.push(l)
            }
            e.layers = i;
            var y = [];
            for (s = 0; s < t.layers.length; s++) if ("imagelayer" === t.layers[s].type) {
                var v = t.layers[s], x = {
                    name: v.name,
                    image: v.image,
                    x: v.x,
                    y: v.y,
                    alpha: v.opacity,
                    visible: v.visible,
                    properties: {}
                };
                v.properties && (x.properties = v.properties), y.push(x)
            }
            e.images = y;
            var b = [], _ = [], w = null;
            for (s = 0; s < t.tilesets.length; s++) {
                if ((B = t.tilesets[s]).image) {
                    var T = new j.Tileset(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
                    B.tileproperties && (T.tileProperties = B.tileproperties), T.updateTileData(B.imagewidth, B.imageheight), b.push(T)
                } else {
                    var P = new j.ImageCollection(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
                    for (var S in B.tiles) {
                        x = B.tiles[S].image;
                        var C = B.firstgid + parseInt(S, 10);
                        P.addImage(C, x)
                    }
                    _.push(P)
                }
                w && (w.lastgid = B.firstgid - 1), w = B
            }
            e.tilesets = b, e.imagecollections = _;
            var I, M, E = {}, A = {};

            function R(t, e) {
                var i = {};
                for (var s in e) {
                    var n = e[s];
                    void 0 !== t[n] && (i[n] = t[n])
                }
                return i
            }

            for (s = 0; s < t.layers.length; s++) if ("objectgroup" === t.layers[s].type) {
                var O = t.layers[s];
                E[O.name] = [], A[O.name] = [];
                var L = 0;
                for (o = O.objects.length; L < o; L++) if (O.objects[L].gid) {
                    var k = {
                        gid: O.objects[L].gid,
                        name: O.objects[L].name,
                        type: O.objects[L].hasOwnProperty("type") ? O.objects[L].type : "",
                        x: O.objects[L].x,
                        y: O.objects[L].y,
                        visible: O.objects[L].visible,
                        properties: O.objects[L].properties
                    };
                    O.objects[L].rotation && (k.rotation = O.objects[L].rotation), E[O.name].push(k)
                } else if (O.objects[L].polyline) {
                    k = {
                        name: O.objects[L].name,
                        type: O.objects[L].type,
                        x: O.objects[L].x,
                        y: O.objects[L].y,
                        width: O.objects[L].width,
                        height: O.objects[L].height,
                        visible: O.objects[L].visible,
                        properties: O.objects[L].properties
                    };
                    O.objects[L].rotation && (k.rotation = O.objects[L].rotation), k.polyline = [];
                    for (var D = 0; D < O.objects[L].polyline.length; D++) k.polyline.push([O.objects[L].polyline[D].x, O.objects[L].polyline[D].y]);
                    A[O.name].push(k), E[O.name].push(k)
                } else if (O.objects[L].polygon) {
                    (k = R(O.objects[L], ["name", "type", "x", "y", "visible", "rotation", "properties"])).polygon = [];
                    for (D = 0; D < O.objects[L].polygon.length; D++) k.polygon.push([O.objects[L].polygon[D].x, O.objects[L].polygon[D].y]);
                    E[O.name].push(k)
                } else if (O.objects[L].ellipse) {
                    k = R(O.objects[L], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                    E[O.name].push(k)
                } else {
                    (k = R(O.objects[L], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).rectangle = !0, E[O.name].push(k)
                }
            }
            e.objects = E, e.collision = A, e.tiles = [];
            for (s = 0; s < e.tilesets.length; s++) {
                p = (B = e.tilesets[s]).tileMargin;
                var B, F = B.tileMargin, U = 0, G = 0, X = 0;
                for (m = B.firstgid; m < B.firstgid + B.total && (e.tiles[m] = [p, F, s], p += B.tileWidth + B.tileSpacing, ++U !== B.total) && (++G !== B.columns || (p = B.tileMargin, F += B.tileHeight + B.tileSpacing, G = 0, ++X !== B.rows)); m++) ;
            }
            for (s = 0; s < e.layers.length; s++) {
                l = e.layers[s], B = null;
                for (h = 0; h < l.data.length; h++) {
                    f = l.data[h];
                    for (var N = 0; N < f.length; N++) null === (I = f[N]) || I.index < 0 || (M = e.tiles[I.index][2], (B = e.tilesets[M]).tileProperties && B.tileProperties[I.index - B.firstgid] && (I.properties = j.Utils.mixin(B.tileProperties[I.index - B.firstgid], I.properties)))
                }
            }
            return e
        }
    },j.Tileset = function (t, e, i, s, n, r, o) {
        (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | s, this.tileMargin = 0 | n, this.tileSpacing = 0 | r, this.properties = o || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
    },j.Tileset.prototype = {
        draw: function (t, e, i, s) {
            var n = s - this.firstgid << 1;
            0 <= n && n + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[n], this.drawCoords[n + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
        }, containsTileIndex: function (t) {
            return t >= this.firstgid && t < this.firstgid + this.total
        }, setImage: function (t) {
            this.image = t, this.updateTileData(t.width, t.height)
        }, setSpacing: function (t, e) {
            this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height)
        }, updateTileData: function (t, e) {
            var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                s = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
            i % 1 == 0 && s % 1 == 0 || console.warn("Phaser.Tileset - " + this.name + " image tile area is not an even multiple of tile size"), i = Math.floor(i), s = Math.floor(s), (this.rows && this.rows !== i || this.columns && this.columns !== s) && console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"), this.rows = i, this.columns = s, this.total = i * s, this.drawCoords.length = 0;
            for (var n = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) {
                for (var a = 0; a < this.columns; a++) this.drawCoords.push(n), this.drawCoords.push(r), n += this.tileWidth + this.tileSpacing;
                n = this.tileMargin, r += this.tileHeight + this.tileSpacing
            }
        }
    },j.Tileset.prototype.constructor = j.Tileset,j.Particle = function (t, e, i, s, n) {
        j.Sprite.call(this, t, e, i, s, n), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
    },j.Particle.prototype = Object.create(j.Sprite.prototype),j.Particle.prototype.constructor = j.Particle,j.Particle.prototype.update = function () {
        this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
    },j.Particle.prototype.onEmit = function () {
    },j.Particle.prototype.setAlphaData = function (t) {
        this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
    },j.Particle.prototype.setScaleData = function (t) {
        this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
    },j.Particle.prototype.reset = function (t, e, i) {
        return j.Component.Reset.prototype.reset.call(this, t, e, i), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
    },j.Particles = function (t) {
        this.game = t, this.emitters = {}, this.ID = 0
    },j.Particles.prototype = {
        add: function (t) {
            return this.emitters[t.name] = t
        }, remove: function (t) {
            delete this.emitters[t.name]
        }, update: function () {
            for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update()
        }
    },j.Particles.prototype.constructor = j.Particles,j.Particles.Arcade = {},j.Particles.Arcade.Emitter = function (t, e, i, s) {
        this.maxParticles = s || 50, j.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = j.EMITTER, this.physicsType = j.GROUP, this.area = new j.Rectangle(e, i, 1, 1), this.minParticleSpeed = new j.Point(-100, -100), this.maxParticleSpeed = new j.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = j.Particle, this.particleDrag = new j.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new j.Point, this.on = !1, this.particleAnchor = new j.Point(.5, .5), this.blendMode = j.blendModes.NORMAL, this.emitX = e, this.emitY = i, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new j.Point(1, 1), this._maxParticleScale = new j.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
    },j.Particles.Arcade.Emitter.prototype = Object.create(j.Group.prototype),j.Particles.Arcade.Emitter.prototype.constructor = j.Particles.Arcade.Emitter,j.Particles.Arcade.Emitter.prototype.update = function () {
        if (this.on && this.game.time.time >= this._timer) if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal) if (0 < this._flowQuantity) {
            for (var t = 0; t < this._flowQuantity; t++) if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                this.on = !1;
                break
            }
        } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1)); else this.emitParticle() && (this._counter++, 0 < this._quantity && this._counter >= this._quantity && (this.on = !1));
        for (t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
    },j.Particles.Arcade.Emitter.prototype.makeParticles = function (t, e, i, s, n) {
        var r;
        void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === s && (s = !1), void 0 === n && (n = !1);
        var o = 0, a = t, h = e;
        for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); o < i;) Array.isArray(t) && (a = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), r = new this.particleClass(this.game, 0, 0, a, h), this.game.physics.arcade.enable(r, !1), r.body.checkCollision.none = !s || !(r.body.checkCollision.any = !0), r.body.collideWorldBounds = n, r.body.skipQuadTree = !0, r.exists = !1, r.visible = !1, r.anchor.copyFrom(this.particleAnchor), this.add(r), o++;
        return this
    },j.Particles.Arcade.Emitter.prototype.kill = function () {
        return this.on = !1, this.alive = !1, this.exists = !1, this
    },j.Particles.Arcade.Emitter.prototype.revive = function () {
        return this.alive = !0, this.exists = !0, this
    },j.Particles.Arcade.Emitter.prototype.explode = function (t, e) {
        return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
    },j.Particles.Arcade.Emitter.prototype.flow = function (t, e, i, s, n) {
        return void 0 !== i && 0 !== i || (i = 1), void 0 === s && (s = -1), void 0 === n && (n = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = s, n ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
    },j.Particles.Arcade.Emitter.prototype.start = function (t, e, i, s, n) {
        if (void 0 === t && (t = !0), void 0 === e && (e = 0), null == i && (i = 250), void 0 === s && (s = 0), void 0 === n && (n = !1), s > this.maxParticles && (s = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || n) for (var r = 0; r < s; r++) this.emitParticle(); else this.on = !0, this._quantity = s, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
        return this
    },j.Particles.Arcade.Emitter.prototype.emitParticle = function (t, e, i, s) {
        void 0 === t && (t = null), void 0 === e && (e = null);
        var n = this.getFirstExists(!1);
        if (null === n) return !1;
        var r = this.game.rnd;
        void 0 !== i && void 0 !== s ? n.loadTexture(i, s) : void 0 !== i && n.loadTexture(i);
        var o = this.emitX, a = this.emitY;
        null !== t ? o = t : 1 < this.width && (o = r.between(this.left, this.right)), null !== e ? a = e : 1 < this.height && (a = r.between(this.top, this.bottom)), n.reset(o, a), n.angle = 0, n.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(n) : this.particleSendToBack && this.sendToBack(n), this.autoScale ? n.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? n.scale.set(r.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || n.scale.set(r.realInRange(this._minParticleScale.x, this._maxParticleScale.x), r.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === s && (Array.isArray(this._frames) ? n.frame = this.game.rnd.pick(this._frames) : n.frame = this._frames), this.autoAlpha ? n.setAlphaData(this.alphaData) : n.alpha = r.realInRange(this.minParticleAlpha, this.maxParticleAlpha), n.blendMode = this.blendMode;
        var h = n.body;
        return h.updateBounds(), h.bounce.copyFrom(this.bounce), h.drag.copyFrom(this.particleDrag), h.velocity.x = r.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), h.velocity.y = r.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), h.angularVelocity = r.between(this.minRotation, this.maxRotation), h.gravity.y = this.gravity, h.angularDrag = this.angularDrag, n.onEmit(), !0
    },j.Particles.Arcade.Emitter.prototype.destroy = function () {
        this.game.particles.remove(this), j.Group.prototype.destroy.call(this, !0, !1)
    },j.Particles.Arcade.Emitter.prototype.setSize = function (t, e) {
        return this.area.width = t, this.area.height = e, this
    },j.Particles.Arcade.Emitter.prototype.setXSpeed = function (t, e) {
        return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
    },j.Particles.Arcade.Emitter.prototype.setYSpeed = function (t, e) {
        return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
    },j.Particles.Arcade.Emitter.prototype.setRotation = function (t, e) {
        return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
    },j.Particles.Arcade.Emitter.prototype.setAlpha = function (t, e, i, s, n) {
        if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 0), void 0 === s && (s = j.Easing.Linear.None), void 0 === n && (n = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, 0 < i && t !== e) {
            var r = {v: t}, o = this.game.make.tween(r).to({v: e}, i, s);
            o.yoyo(n), this.alphaData = o.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
        }
        return this
    },j.Particles.Arcade.Emitter.prototype.setScale = function (t, e, i, s, n, r, o) {
        if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1), void 0 === n && (n = 0), void 0 === r && (r = j.Easing.Linear.None), void 0 === o && (o = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, i), this._maxParticleScale.set(e, s), this.autoScale = !1, 0 < n && (t !== e || i !== s)) {
            var a = {x: t, y: i}, h = this.game.make.tween(a).to({x: e, y: s}, n, r);
            h.yoyo(o), this.scaleData = h.generateData(60), this.scaleData.reverse(), this.autoScale = !0
        }
        return this
    },j.Particles.Arcade.Emitter.prototype.at = function (t) {
        return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
    },Object.defineProperty(j.Particles.Arcade.Emitter.prototype, "width", {
        get: function () {
            return this.area.width
        }, set: function (t) {
            this.area.width = t
        }
    }),Object.defineProperty(j.Particles.Arcade.Emitter.prototype, "height", {
        get: function () {
            return this.area.height
        }, set: function (t) {
            this.area.height = t
        }
    }),Object.defineProperty(j.Particles.Arcade.Emitter.prototype, "x", {
        get: function () {
            return this.emitX
        }, set: function (t) {
            this.emitX = t
        }
    }),Object.defineProperty(j.Particles.Arcade.Emitter.prototype, "y", {
        get: function () {
            return this.emitY
        }, set: function (t) {
            this.emitY = t
        }
    }),Object.defineProperty(j.Particles.Arcade.Emitter.prototype, "left", {
        get: function () {
            return Math.floor(this.x - this.area.width / 2)
        }
    }),Object.defineProperty(j.Particles.Arcade.Emitter.prototype, "right", {
        get: function () {
            return Math.floor(this.x + this.area.width / 2)
        }
    }),Object.defineProperty(j.Particles.Arcade.Emitter.prototype, "top", {
        get: function () {
            return Math.floor(this.y - this.area.height / 2)
        }
    }),Object.defineProperty(j.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function () {
            return Math.floor(this.y + this.area.height / 2)
        }
    }),j.Video = function (t, e, i) {
        if (void 0 === e && (e = null), void 0 === i && (i = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = j.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new j.Signal, this.onChangeSource = new j.Signal, this.onComplete = new j.Signal, this.onAccess = new j.Signal, this.onError = new j.Signal, this.onTimeout = new j.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e)) {
            var s = this.game.cache.getVideo(e);
            s.isBlob ? this.createVideoFromBlob(s.data) : this.video = s.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
        } else i && this.createVideoFromURL(i, !1);
        this.video && !i ? this.baseTexture = new PIXI.BaseTexture(this.video) : this.baseTexture = new PIXI.BaseTexture(j.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new j.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, j.BitmapData && (this.snapshot = new j.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : s && (s.locked = !1)
    },j.Video.prototype = {
        connectToMediaStream: function (t, e) {
            return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
        }, startMediaStream: function (t, e, i) {
            if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
            null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
            try {
                navigator.getUserMedia({
                    audio: t,
                    video: !0
                }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
            } catch (t) {
                this.getUserMediaError(t)
            }
            return this
        }, getUserMediaTimeout: function () {
            clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
        }, getUserMediaError: function (t) {
            clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
        }, getUserMediaSuccess: function (t) {
            clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
            var n = this;
            this.video.onloadeddata = function () {
                var s = 10;
                !function t() {
                    if (0 < s) if (0 < n.video.videoWidth) {
                        var e = n.video.videoWidth, i = n.video.videoHeight;
                        isNaN(n.video.videoHeight) && (i = e / (4 / 3)), n.video.play(), n.isStreaming = !0, n.baseTexture.source = n.video, n.updateTexture(null, e, i), n.onAccess.dispatch(n)
                    } else window.setTimeout(t, 500); else console.warn("Unable to connect to video stream. Webcam error?");
                    s--
                }()
            }
        }, createVideoFromBlob: function (t) {
            var e = this;
            return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function (t) {
                e.updateTexture(t)
            }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
        }, createVideoFromURL: function (t, e) {
            return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
        }, updateTexture: function (t, e, i) {
            var s = !1;
            null == e && (e = this.video.videoWidth, s = !0), null == i && (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), s && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
        }, complete: function () {
            this.onComplete.dispatch(this)
        }, play: function (t, e) {
            return void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this
        }, playHandler: function () {
            this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
        }, stop: function () {
            return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function (t) {
                t.stop()
            }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
        }, add: function (t) {
            if (Array.isArray(t)) for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this); else t.loadTexture(this);
            return this
        }, addToWorld: function (t, e, i, s, n, r) {
            n = n || 1, r = r || 1;
            var o = this.game.add.image(t, e, this);
            return o.anchor.set(i, s), o.scale.set(n, r), o
        }, render: function () {
            !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
        }, setMute: function () {
            this._muted || (this._muted = !0, this.video.muted = !0)
        }, unsetMute: function () {
            this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
        }, setPause: function () {
            this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
        }, setResume: function () {
            !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
        }, changeSource: function (t, e) {
            return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), (this._autoplay = e) || (this.paused = !0), this
        }, checkVideoProgress: function () {
            4 === this.video.readyState ? this.updateTexture() : (this.retry--, 0 < this.retry ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming))
        }, setTouchLock: function () {
            this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0
        }, unlock: function () {
            if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                var t = this.game.cache.getVideo(this.key);
                t && !t.isBlob && (t.locked = !1)
            }
            return !0
        }, grab: function (t, e, i) {
            if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot;
            console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable")
        }, removeVideoElement: function () {
            if (this.video) {
                for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
            }
        }, destroy: function () {
            this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
        }
    },Object.defineProperty(j.Video.prototype, "currentTime", {
        get: function () {
            return this.video ? this.video.currentTime : 0
        }, set: function (t) {
            this.video.currentTime = t
        }
    }),Object.defineProperty(j.Video.prototype, "duration", {
        get: function () {
            return this.video ? this.video.duration : 0
        }
    }),Object.defineProperty(j.Video.prototype, "progress", {
        get: function () {
            return this.video ? this.video.currentTime / this.video.duration : 0
        }
    }),Object.defineProperty(j.Video.prototype, "mute", {
        get: function () {
            return this._muted
        }, set: function (t) {
            if (t = t || null) {
                if (this._muted) return;
                this._codeMuted = !0, this.setMute()
            } else {
                if (!this._muted) return;
                this._codeMuted = !1, this.unsetMute()
            }
        }
    }),Object.defineProperty(j.Video.prototype, "paused", {
        get: function () {
            return this._paused
        }, set: function (t) {
            if (t = t || null, !this.touchLocked) if (t) {
                if (this._paused) return;
                this._codePaused = !0, this.setPause()
            } else {
                if (!this._paused) return;
                this._codePaused = !1, this.setResume()
            }
        }
    }),Object.defineProperty(j.Video.prototype, "volume", {
        get: function () {
            return this.video ? this.video.volume : 1
        }, set: function (t) {
            t < 0 ? t = 0 : 1 < t && (t = 1), this.video && (this.video.volume = t)
        }
    }),Object.defineProperty(j.Video.prototype, "playbackRate", {
        get: function () {
            return this.video ? this.video.playbackRate : 1
        }, set: function (t) {
            this.video && (this.video.playbackRate = t)
        }
    }),Object.defineProperty(j.Video.prototype, "loop", {
        get: function () {
            return !!this.video && this.video.loop
        }, set: function (t) {
            t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
        }
    }),Object.defineProperty(j.Video.prototype, "playing", {
        get: function () {
            return !(this.video.paused && this.video.ended)
        }
    }),j.Video.prototype.constructor = j.Video,void 0 === PIXI.blendModes && (PIXI.blendModes = j.blendModes),void 0 === PIXI.scaleModes && (PIXI.scaleModes = j.scaleModes),void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)),void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix),void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix),PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = j.POLYGON, PIXI.Graphics.RECT = j.RECTANGLE, PIXI.Graphics.CIRC = j.CIRCLE, PIXI.Graphics.ELIP = j.ELLIPSE, PIXI.Graphics.RREC = j.ROUNDEDRECTANGLE),PIXI.TextureSilentFail = !0,"undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = j), exports.Phaser = j) : "undefined" != typeof define && define.amd ? define("Phaser", t.Phaser = j) : t.Phaser = j,j
}.call(this);
